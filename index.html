<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="技术博客与软件分享">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiao Zhang&#39;blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Xiao Zhang&#39;blog">
<meta property="og:description" content="技术博客与软件分享">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiao Zhang">
<meta name="twitter:card" content="summary"><title>Xiao Zhang'blog</title><link ref="canonical" href="http://example.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">menu.Blog</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/software/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">menu.software</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Xiao Zhang's Blod</div><div class="header-banner-info__subtitle">Blod for Xiao Zhang</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%20Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/">《疯狂Java讲义——Java基础类库》</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="第七章-Java基础类库"   >
          <a href="#第七章-Java基础类库" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七章-Java基础类库" class="headerlink" title="第七章 Java基础类库"></a>第七章 Java基础类库</h1>
      <p> Oracle为java提供了丰富的基础类库，java8提供了4000多个基础类(包括下一章将要介绍的集合框架),通过这些基础类库可以提高开发效率，降低开发难度。对于合格的Java程序员而言，至少要熟悉 Java SE中70%以上的类(当然本书并不是让读者去背诵 Java API文档),但在反复查阅API文档  的过程中，会自动记住大部分类的功能、方法，因此程序员一定要多练，多敲代码。</p>
<p>Java提供了 String、 StringBuffer和 StringBuilder来理字符串，它们之间存在少许差别，本章会详细介绍它们之间的差别，以及如何选择合适的字符串类。Java还提供了Date和 Calendar来处理日期、  时间，其中Date是一个已经过时的API,通常推荐使用 Calendar来处理日期、时间。 </p>
<p> 正则表达式是一个强大的文本处理工具，通过正则表达式可以对文本内容进行查找、替换、分割等  操作。从K1.4以后，Java也增加了对正则表达式的支持，包括新增的 Pattem和 Matcher两个类，并  改写了 String类，让 String类增加了正则表达式支，增加了正则表达式功能后的 String类更加强大。  </p>
<p>Java还提供了非常简单的国际化支持， Java使用 Locale对象封装一个国家、语言环境，再使用   ResourceBundle根据 Locale加载语言资源包，当 ResourceBundle加载了指定 Locale对应的语言资源文件后， ResourceBundle对象就可调用 getString()方法来取出指定key所对应的消息字符串。</p>

        <h2 id="7-1-与用户交互"   >
          <a href="#7-1-与用户交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-与用户交互" class="headerlink" title="7.1 与用户交互"></a>7.1 与用户交互</h2>
      <p>本节主要介绍如何获得用户的键盘输入</p>

        <h3 id="7-1-1-运行Java程序的参数"   >
          <a href="#7-1-1-运行Java程序的参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-1-运行Java程序的参数" class="headerlink" title="7.1.1 运行Java程序的参数"></a>7.1.1 运行Java程序的参数</h3>
      <p>main()方法的方法签名</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java程序入口:main()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>public 修饰符：Java类由JVM调用，为了让JVM可以自由调用这个main()方法，所以用public修饰符把这个方法暴露出来。</li>
<li>static 修饰符：JVM调用这个主方法时，会创建该主类的对象，然后通过对象来调用该主方法。JVM直接通过该类来调用主方法，因此使用static修饰该方法。</li>
<li>void 返回值：因为主方法被JVM调用，该方法的返回值将返回给JVM,这没有任何意义，因此main()方法没有返回值。</li>
</ul>
<p>根据方法调用规则：谁调用方法，谁负责为形参赋值。也就是说main()方法由JVM调用，即args形参应该由JVM负责赋值，但JVM怎么知道如何为args赋值呢，看如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		输出args数组的长度</span></span><br><span class="line">		System.out.println(args.length);</span><br><span class="line"><span class="comment">//		遍历args数组的每个元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> arg : args)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(arg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序输出0，表明args数组是一个长度为0的数组——这是合理的。因为计算机是没有思考能力的，他只能忠实地执行用户交给它的任务，既然程序没有给args数组设定参数值，那么JVM就不知道args数组的元素，所以JVM将args数组设置成一个长度为0的数组。</p>
<p>改为一下命令运行此程序：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ArgsTest.java Java Spring</span><br></pre></td></tr></table></div></figure>

<p>即可看到如下结果</p>
<p><img src="C:\Users\MingyangLiu\Desktop\张智超\image\Snipaste_2021-03-19_16-17-33.png"></p>
<p>如果在类名后紧跟一个或多个字符串（多个字符串之间以空格隔开），JVM就会把这些字符串依次赋给args数组元素。运行Java程序时的参数与args数组之间的对应关系：</p>
<p><img src="C:\Users\MingyangLiu\Desktop\张智超\image\P10319-162517(1)(1).jpg"></p>
<p>如果某参数本身包含了空格，则应该将该参数用双引用引用，否则JVM会把这个空格当成参数分隔符，而不是参数本身。</p>

        <h3 id="7-1-2-使用Scanner获取键盘输入"   >
          <a href="#7-1-2-使用Scanner获取键盘输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-2-使用Scanner获取键盘输入" class="headerlink" title="7.1.2 使用Scanner获取键盘输入"></a>7.1.2 使用Scanner获取键盘输入</h3>
      <ol>
<li>创建Scannner对象，接收从控制台输入	<strong>Scanner input&#x3D;new Scanner(System.in);</strong></li>
<li>接收语句由接收类型决定     <strong>int n&#x3D;input.nextInt();</strong></li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo59</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建Scanner对象，接受从控制台输入</span></span><br><span class="line">		Scanner input=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="comment">//接受String类型</span></span><br><span class="line">		String str=input.next();</span><br><span class="line">		<span class="comment">//输出结果</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用Scanner类可以很方便地获取用户键盘输入，Scanner是一个基于正则表达式的文本扫描器，他可以用文件，输入流，字符串作为数据源，用于文件、输入流、字符串中解析数据。</p>
<p>Scanner主要看以下两个方法进行扫描输入：</p>
<ol>
<li>hasNextXxx()：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串。则直接用hasNext()。</li>
<li>nextXxx():获取下一个输入项。Xxx的含义与前一个方法中的Xxx相同。</li>
</ol>
<p>在默认情况下，Scanner使用空白（空格，tab，回车）作为多个输入项之间的分隔符。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerKeyBoardTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span>(sc.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span>+sc.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的程序可以不断地输入输出。</p>
<p>如果希望改变Scanner的分隔符（不使用空白作为分隔符），例如，程序需要每次读取一行，不管这一行中是否包含空格，Scanner都把它当成一个输入项。在这种需求下，可以把Scanner的分隔符设置为回车符，不在使用默认的空白作为分隔符。</p>
<p>Scanner的读取操作可能被阻塞（当前执行顺序流暂停）来等待信息的输入，如果输入源没有结束，Scanner有读取不到更多输入项时（尤其在键盘输入时比较常见），Scanner的hasNext()和next()方法都有可能阻塞，hasNext()方法是否阻塞与其相关的next()方法是否阻塞无关。</p>
<p>为Scanner设置分隔符使用useDelimiter(String pattern)方法即可，该方法的参数应该是一个正则表达式，，只要把上面程序中粗体字代码行的注释去掉，该程序就会把键盘的每行输入当成一个输入项，不会以空格、TAB空白等作为分隔符。事实上，Scanner提供了两个简单的方法来逐行读取。</p>
<ul>
<li>boolean hasNextLine()：返回输入源中是否还有下一行。</li>
<li>String nextLine()：返回输入源中下一行的字符串。</li>
</ul>
<p>Scanner不仅可以获取字符串输入项，也可以获取任何基本类型的输入项：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerLongTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">var</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in) ;</span><br><span class="line">    <span class="comment">//控制输入的格式</span></span><br><span class="line"><span class="keyword">while</span>(sc.hasNextLong())<span class="comment">//粗</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;键盘输入的是：&quot;</span></span><br><span class="line">                           +sc.nextLong());		<span class="comment">//粗</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>注意粗，正如通过hasNextLong()和nextLong()两个方法，Scanner可以直接从输入流中获得long型证书输入项。与此类似，如果需要输入其他基本类型的输入项，则可以使用相应的方法。</p>
<p>&#x3D;&#x3D;上面的程序不如ScannerKeyBoardTest程序适应性强，因为这个程序要求必须输入的格式，否则退出。</p>
<p>Scanner不仅能读取用户的键盘键入，还可以读取文件输入。只要在创建Scanner对象时传入了一个File对象作为参数，就可以让Scanner读取该文件的内容。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerFileTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将一个File对象作为Scanner的构造器参数，Scanner读取文件内容</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;ScannerFileTest.java&quot;</span>));<span class="comment">//粗体字</span></span><br><span class="line">			System.out.println(<span class="string">&quot;ScannerFileTest.java文件内容如下&quot;</span>);</span><br><span class="line">			<span class="comment">//判断是否还有下一行</span></span><br><span class="line">			<span class="keyword">while</span>(sc.hasNextLine())<span class="comment">//粗体字</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//输出文件中的下一行</span></span><br><span class="line">				System.out.println(sc.nextLine());<span class="comment">//粗体字</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>上面程序创建Scanner对象时传入一个File对象作为参数，这表明该程序将会读取ScannerFileTest.java文件中的内容。上面程序使用了hasNextLine()和nextLine()两个方法来读取文件内容。这表明该程序将逐行读取ScannerFileTest.java文件的内容。</p>
<p>因为上面程序涉及文件输入，可能引发文件IO相关异常，故主程序声明throws Exception表明main方法不处理任何异常。</p>

        <h2 id="7-2-系统相关"   >
          <a href="#7-2-系统相关" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-系统相关" class="headerlink" title="7.2 系统相关"></a>7.2 系统相关</h2>
      <p>Java提供了System类和Runtime类来与程序的运行平台进行交互。</p>

        <h3 id="7-2-1-System类"   >
          <a href="#7-2-1-System类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-1-System类" class="headerlink" title="7.2.1 System类"></a>7.2.1 System类</h3>
      <p>System类代表当前Java程序的运行平台，程序不能创建System类的对象，System提供了一些类变量和类方法，允许直接通过System类来条用这些类变量和类方法。</p>
<p> System类提供了代表标准输入、标准输出和错误输出类变量，并提供了一些静态方法用  环境变量、系统属性的方法，还提供了加载文件和动态链接库的方法。下面程序通过 System类  操作的环境变量和系统属性。</p>
<p>注意：   加载文件和动态链接库主要对 native方法有用，对于一些特殊的功能(如访问操作系统底层硬件设备等)Java程序无法实现，必须借助C语言来完成，此时需要使用C语言为Java方法提供实现。其实现步骤如下：  ①Java程序中声明 native修饰的方法，类似于abstract方法，只有方法签名，没有实现。使用带h选项的 Javac命令编译该Java程序，将生成一个class文件和一个h头文件  ②写一个.cpp文件实现 native方法，这一步需要包含1步产生的.h文件(这个h  文件中又包含了JDK带的jni.h文件)  ③将第2步的.cpp文件编译成动态链接库文件  ④在Java中用 System类的loadLibrary..()方法加载第3步产生的动态链接库文件，Java程序中就可以调用这个 natIve方法了。</p>
<p>注  在Java9以前， Javac命令没有-h选项，因此JDK提供了 javah命令来为. class文件生.成h头文件。Java10彻底删除了 javah命令  , Javac的-h选项代替了 javah。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取系统所有的环境变量</span></span><br><span class="line">		Map &lt; String, String &gt; env = System.getenv();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> name : env.keySet())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(name + <span class="string">&quot;---&gt;&quot;</span> + env.get(name));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取指定环境变量的值</span></span><br><span class="line">		System.out.println(System.getenv(<span class="string">&quot;JAVA_HOME&quot;</span>));</span><br><span class="line">		<span class="comment">//获取所有的系统属性</span></span><br><span class="line">		<span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">		props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;props.txt&quot;</span>), <span class="string">&quot;System Properties&quot;</span>);</span><br><span class="line">		<span class="comment">//输出特定的系统属性</span></span><br><span class="line">		System.out.println(System.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该程序运行结束之后还会在当前路径下生产一个Props.txt文件，该文件中记录了当前平台所有系统属性。</p>
<p> System类提供了通知系统进行垃圾回收的gc()方法，以及通知系统进行资源清理的   runFinalization(方法。关于这两个方法的用法请参考本书6.10节的内容</p>
<p>System类还有两个获取系统当前时间的方法  : currentTimeMillis()和nanoTime(),它们都返回一个long型整数。实际上它们都返回当前时间与UTC1970年1月1日午夜的时间差，前者以毫秒作为单位，  后者以纳秒作为单位。必须指出的是，这两个方法返回的间粒度取决于底层操作系统，可能所在的操作系统根本不支持以毫秒、纳秒作为计时单位。例如，许多操作系统以几十毫秒为单位测量时间，currentTimeMillis()方法不可能返回精确的毫秒数，而nanoTime()方法很少用，因为大部分操作系统都不支持使用纳秒作为计时单位。</p>
<p>除此之外， System类的in、out和err分别代表系统的标准输入(通常是键盘)、标准输出(通常是  显示器)和错误输出流，并提供了 setIn(),setout()和setErr()方法来改变系统的标准输入、标准输出和标准错误输出流。关于如何改变系统的标准输入、输出的方法，可以参考本书第15章的内容。</p>
<p>System类还提供了一个 identityHashCode( Object X)方法，该方法返回指定对象的精确 hashCode值  也就是根据该对象的地址计算得到的 hashCode值。当某个类的 hashCode方法被重写后，该类实例的   hashCode()方法就不能唯一地标识该对象；但通过 identityHashCode()方法返回的 hash Code值，依然是根据该对象的地址计算得到的 hash Code值。所以如果两个对象的 identityHashCode值相同，则两个对象绝对是同一个对象。如下程序所示:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityHashCodeTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		下面程序中的s1和s2是两个不同的对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//		String重写了hasCode()方法——改为根据字符序列计算hashCode值</span></span><br><span class="line"><span class="comment">//		因为S1和S2的字符序列相同，所以他们的hasCode()方法返回值相同</span></span><br><span class="line">		System.out.println(s1.hashCode()+<span class="string">&quot;-----&quot;</span>+s2.hashCode());</span><br><span class="line"><span class="comment">//		s1和s2的不同的字符串对象，所以他们的identityHashCode值不同</span></span><br><span class="line">		System.out.println(System.identityHashCode(s1) + <span class="string">&quot;----&quot;</span>+System.identityHashCode(s2));</span><br><span class="line">		<span class="type">var</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">//		s3和s4是相同的字符串对象，所以他们的identityHashCode值相同。</span></span><br><span class="line">		System.out.println(System.identityHashCode(s3)+<span class="string">&quot;---&quot;</span>+System.identityHashCode(s4));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过 identityHashCode(Object x)方法可以获得对象的 identityHashCode值，这个特殊的identityHashCode值可以唯一地标识该对象。因为identityHashCode值是根据对象的地址计算得到的，  所以任何两个对象的 identityHashCode值总是不相等。</p>

        <h3 id="7-2-2-Runtime类与java9的-ProcessHandle"   >
          <a href="#7-2-2-Runtime类与java9的-ProcessHandle" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-2-Runtime类与java9的-ProcessHandle" class="headerlink" title="7.2.2 Runtime类与java9的 ProcessHandle"></a>7.2.2 Runtime类与java9的 ProcessHandle</h3>
      <p> Runtime类代表Java程序的运行时环境，每个Java程序都有一个与之对应的 Runtime实例，应用程序通过该对象与其运行时环境相连。应用程序不能创建自己的 Runtime实例，但可以通过 getRuntime()  方法获取与之关联的 Runtime对象。</p>
<p>与System类似的是， Runtime类也提供了 gc() 方法和 runFinalization() 方法来通知系统进行垃圾回收清理系统资源，并提供了 load(String filename) 和 loadLibrary( String libname)方法来加载文件和动态链接库。</p>
<p>Runtime类代表Java程序的运行时环境，可以访问JM的相关信息，如处理器数量、内存信息等。  如下程序所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		获取Java程序关联的运行时的环境</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">		System.out.println(<span class="string">&quot;处理器数量：&quot;</span>+rt.availableProcessors());</span><br><span class="line">		System.out.println(<span class="string">&quot;空闲内存数：&quot;</span>+rt.freeMemory());</span><br><span class="line">		System.out.println(<span class="string">&quot;总内存数：&quot;</span>+rt.totalMemory());</span><br><span class="line">		System.out.println(<span class="string">&quot;可用最大内存数：&quot;</span>+rt.maxMemory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Runtime类还有一个功能——他可以直接启动一个进程来运行操作系统的命令：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//		运行记事本</span></span><br><span class="line">		rt.exec(<span class="string">&quot;notepad.exe&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字代码将启动 Windows系统里的“记事本”程序。 Runtime提供了一系列 exec() 来运行操作系统命令，关于它们之间的细微差别，请读者自行查阅API文档。  </p>
<p>通过exec启动平台上的命令之后，它就变成了一个进程，Java使用 Process来代表进程java9还新增了一个ProcessHandle接口，通过该接口可获取进程的ID、父进程和后代进程：通过该接口的onExit() 方法可在进程结束时完成某些行为。   </p>
<p>ProcessHandle还提供了一个 ProcessHandle.Info类，用于获取进程的命令、参数、启动时间、累计运行时间、用户等信息。下面程序示范了通过 ProcessHandle获取进程的相关信息。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessHandleTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//		运行记事本程序</span></span><br><span class="line">		<span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> rt.exec(<span class="string">&quot;notepad.exe&quot;</span>);</span><br><span class="line">		<span class="type">ProcessHandle</span> <span class="variable">ph</span> <span class="operator">=</span> p.toHandle();</span><br><span class="line">		System.out.println(<span class="string">&quot;进程是否运行：&quot;</span>+ph.isAlive());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程ID：&quot;</span>+ph.pid());</span><br><span class="line">		System.out.println(<span class="string">&quot;父进程：&quot;</span>+ph.parent());</span><br><span class="line"><span class="comment">//		获取ProcessHandle.Info信息</span></span><br><span class="line">		ProcessHandle.<span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> ph.info();</span><br><span class="line"><span class="comment">//		通过ProcessHandle.Info信息获取进程相关信息</span></span><br><span class="line">		System.out.println(<span class="string">&quot;进程命令：&quot;</span>+info.command());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程参数：&quot;</span>+info.arguments());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程启动时间：&quot;</span>+info.startInstant());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程累计运行时间：&quot;</span>+info.totalCpuDuration());</span><br><span class="line"><span class="comment">//		通过CompletableFuture在进程结束后运行某个任务</span></span><br><span class="line">		CompletableFuture&lt;ProcessHandle&gt;cf = ph.onExit();</span><br><span class="line">		cf.thenRunAsync(()-&gt;&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;程序退出&quot;</span>);&#125;);</span><br><span class="line">		Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过粗体字获取Process对象的ProcessHandle对象，接下来即可通过ProcessHandle对象来获取进程相关信息。</p>

        <h2 id="7-3-常用类"   >
          <a href="#7-3-常用类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-常用类" class="headerlink" title="7.3 常用类"></a>7.3 常用类</h2>
      
        <h3 id="7-3-1-Object类"   >
          <a href="#7-3-1-Object类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-1-Object类" class="headerlink" title="7.3.1 Object类"></a>7.3.1 Object类</h3>
      <p> Object类是所有类、数组、枚举类的父类，也就是说，java允许把任何类型的对象赋给 Object类型的变量。当定义一个类时没有使用 extends关键字为它显式指定父类，则该类默认继承 Object父类。  因为所有的Java类都是 Object类的子类，所以任何对象都可以调用 Object类的方法。 Object  类提供了如下几个常用方法。</p>
<ul>
<li>boolean equals( Object obj)：判断指定对象该对象是否相等。此处相等的标准是，两个对象是  同一个对象，因此该 equals方法通常没有太大的实用价值。   </li>
<li>protected void finalize()：当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。</li>
<li>Class&lt;?&gt;getClass()：返回该对象的运行时类，该方法在本书第18章还有更详细的介绍。</li>
<li>int hashCode():返回该对象的 hashCode()值。在默认情况下， Object类的hashCode()方法根据该对象的地址来计算(即与 System.identityHashCode( Object x)方法的计算结果相同)。但很多类都重写了 Object 类的 hashCode()方法，不再根据地址计算其 hashCode()方法值。   </li>
<li>String toString()返回该对象的字符串表示，当程序使用System.out.printlm()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的 toString()方法返回该对象的字符串表示。Object类的toString()方法返回”运行时类名@十六进制 hash Code值”格式的字符串，但很多类都重写了Object类的 toString()方法，用于返回可以表述该对象信息的字符串。</li>
</ul>
<p>除此之外， Object类还提供了 wait()、 notify()、notifyAll()几个方法，通过这几个方法可以控制线程的暂停和运行。</p>
<p>Java还提供了一个 protected修饰的 clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于Object类提供的clone()方法使用了protected修饰，因此该方法只能被子类重写或调用。</p>
<p>自定义类实现“克隆”的步骤如下： </p>
<p>​	①自定义类实现 Cloneable接口。这是一个标记性的接口，实现该接口的对象可以实现“自我克隆”,接口里没有定义任何方法。  </p>
<p>​	②自定义类实现自己的 clone()方法。  </p>
<p>​	③实现 clone()方法时通过super.clone()；调用 Object实现的clone()方法来得到该对象的副本，并返回该对象的副本。如下程序示范了如何实现“自我克隆”。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span></span><br><span class="line">&#123;</span><br><span class="line">	String detail;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String detail)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.detail = detail;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Cloneable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	Address address;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		address = <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;广州天河&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过调用supre.clone()来实现clone()方法</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line">			<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">return</span>(User) <span class="built_in">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">		<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">29</span>);</span><br><span class="line"><span class="comment">//		clone得到u1对象的副本</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">u2</span> <span class="operator">=</span> u1.clone();</span><br><span class="line"><span class="comment">//		判断u1和u2是否相等</span></span><br><span class="line">		System.out.println(u1 == u2);  <span class="comment">//①</span></span><br><span class="line"><span class="comment">//		判断u1和u2的address是否相等</span></span><br><span class="line">		System.out.println(u1.address = u2.address); <span class="comment">//②</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序让User类实现了Cloneable接口，而且实现clone()方法，因此User对象就可实现“自我克隆”——克隆出来的对象只是原有对象的副本。程序在①号粗体字代码处判断原有的User对象与克隆出来的User对象是否想到，程序返回false。</p>
<p>Object类提供的Clone机制只对对象里各类变量进行“简单复制”，如果实例变量的类型是引用类型，Object的clone机制也只是简单地复制这个引用变量，这样原有类型的引用类型的实例变量与克隆对象的引用类型的实例变量依然指向内存中的同一实例，所以上面程序在②时输出true。上面克隆出来的u1，u2所指向的独享在内存中的存储示意图：</p>
<p>![](C:\Program Files\Typora\image\de3267f363f41df5b666c846be80dfd.jpg)</p>
<p>Object类提供的clone()方法不仅能简单地处理“复制”对象的问题，而且这之前“自我克隆”的机制十分高效。比如clone一个包含100个元素的int[]数组，用系统默认的clone方法比静态copy方法快近2倍。</p>
<p>需要指出的是，Object类的clone()方法虽然简单、易用，但它只是一种“浅克隆”——他只克隆该对象的所有成员变量值，不会对引用类型的成员变量值所引用的对象进行克隆。如果开发者需要对对象进行“深克隆”，那么开发者需要自己进行“递归克隆”，保证所有引用类型的成员变量值所引用的对象都被复制了。</p>

        <h3 id="7-3-2-操作对象的Object工具类"   >
          <a href="#7-3-2-操作对象的Object工具类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-2-操作对象的Object工具类" class="headerlink" title="7.3.2 操作对象的Object工具类"></a>7.3.2 操作对象的Object工具类</h3>
      <p>Java 7 提供了一个Object工具类，他提供了一些工具来操作对象，这些工具方法大多是“空指针”安全的。比如不能确定一个引用变量是否为null，如果贸然的调用该对象的toString()方法，则有可能引发异常：如果使用Object使用的toString(Object o)方法，则不会引发空指针异常，当o为null时，程序将返回一个null字符串。</p>
<p>提示：Java为工具类的命名习惯是提供一个字母s，比如操作系统的工具类是Arrays，操作集合的工具类是Collections。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectsTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义一个obj变量，它的默认值为null</span></span><br><span class="line">	<span class="keyword">static</span> ObjectsTest obj;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		输出一个null对象的hashCode值，输出0</span></span><br><span class="line">		System.out.println(Objects.hash(obj));</span><br><span class="line"><span class="comment">//		输出一个null对象的toString，输出null</span></span><br><span class="line">		System.out.println(Objects.toString(obj));</span><br><span class="line"><span class="comment">//		要求obj不能为null，如果obj为null则引发异常</span></span><br><span class="line">		System.out.println(Objects.requireNonNull(obj,<span class="string">&quot;obj参数不能是null!&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序还示范了Objects提供的requireNonNull()方法，当传入的参数不为null时，该方法返回参数本身；否则会引发NullPointerException异常。该方法主要是对方法形参输入校验，例如如下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Foo</span><span class="params">(Bar bar)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//校验bar参数，如果bar参数为null将引发异常；否则this.bar被赋值为bar参数</span></span><br><span class="line">	<span class="built_in">this</span>.bar = Objects.requireNull(bar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-3-3-Java-9改进的String、StringBuffer和StringBuilder类"   >
          <a href="#7-3-3-Java-9改进的String、StringBuffer和StringBuilder类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-3-Java-9改进的String、StringBuffer和StringBuilder类" class="headerlink" title="7.3.3 Java 9改进的String、StringBuffer和StringBuilder类"></a>7.3.3 Java 9改进的String、StringBuffer和StringBuilder类</h3>
      <p>字符串就是一连串的字符序列，Java提供了 String, StringBuffer和 StringBuilder三个类来封装字符串，并提供了一系列方法来操作字符串对象。 </p>
<p>String类是不可变类，即一旦一个对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p>
<p>StringBuffer对象则代表一个字符序列可变的字符串，当一个 StringBuffer被创建以后，通过StringBuffer提供的 append()、insert()、 reverse()、 setCharAt()、 setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个 String对象。</p>
<p>StringBuilder类是JDK1.5新增的类，它也代表可变字符对象。实际上， StringBuilder和StringBuffer  基本相似，两个类的构造器和方法也基本相同。不同的是， StringBuffer是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用 StringBuilder类。</p>
<p> 提示：String、StringBuilder、StringBuffer 都实现了 CharSequence接口，因此CharSequence可认为是一个字符串的协议接口。</p>
<p>Java 9改进了字符串(包括 String、StringBulider,、StringBuilder)  的实现。在Java 9以前字符串采用  char[ ]数组来保存字符，因此字符串的每个字符占2字节；而Java 9及更新版本的JDK的字符串采用byte[ ] 数组再加一个 encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。所以Java 9及更新版本的JDK的字符串更加节省空间，但字符串的功能方法没有受到任何影响。</p>
<p>char charAt(int index)：获取字符串中指定位置的字符，其中index指的是字符串的序数，字符串的序数从0开始到length()-1。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;fkit..org&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s.charAt(5):&quot;</span>+s.charAt(<span class="number">5</span>));</span><br></pre></td></tr></table></div></figure>

<p>int compareTo(String anotherString)：比较两个字符串的大小。如果两个字符串的字符串序列相等，则返回0,；不相等时，从两个字符串的第0个字符开始比较，返回第一个不相等的字符差。另一种情况，较长的字符串的前面部分刚好是较短的字符串，返回长度差。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcdefghigklmnopq&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abcdefghig&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abcdefghigrstuvw&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s1.compareTo(s2)：&quot;</span>+s1.compareTo(s2)); <span class="comment">//返回长度差</span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.compareTo(s3)：&quot;</span>+s1.compareTo(s3)); <span class="comment">//返回&#x27;k&#x27;-&#x27;r&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>​	boolean ends With(String suffix)：返回String是否一suffix结尾。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;fkit.org&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;.org&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s4.endsWith(s5)：&quot;</span>+s4.endsWith(s5));</span><br></pre></td></tr></table></div></figure>

<p>void getChar(int scrBegin,int scrEnd,char [ ] dst,int dstBegin)：该方法将字符串中从scrBegin开始，到scrEnd结束的字符串复制到dst字符串数组中，其中dstBegin为目标字符数组的起始复制位置。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> [] s6 = &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;ejb&quot;</span>;</span><br><span class="line">s7.getChars(<span class="number">0</span>, <span class="number">3</span>, s6, <span class="number">7</span>);  <span class="comment">//s6 = I love ejba</span></span><br><span class="line">System.out.println(s6);</span><br></pre></td></tr></table></div></figure>

<p>int indexOf(String str,int fromIndex)：找出str子字符串在该字符串中从fromIndex开始后第一次出现的位置。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;www.fkit.org&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s9</span> <span class="operator">=</span> <span class="string">&quot;it&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s8.indexOf(&#x27;r&#x27;)：&quot;</span>+s8.indexOf(<span class="string">&#x27;r&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;s8.indexOf(&#x27;r&#x27;,2)：&quot;</span>+s8.indexOf(<span class="string">&#x27;r&#x27;</span>,<span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;s8.indexOf(s9)：&quot;</span>+s8.indexOf(s9));</span><br></pre></td></tr></table></div></figure>

<p>剩下的读者可以查阅API自己学习。</p>
<p>因为String是不可变的，多以会额外产生很多零食变量，使用StringBuffer或StringBulider就可以避免这个问题。</p>
<p>StringBulider提供了一系列的插入、追加、改变该字符串里包含的字符序列的方法。而StringBuffer与其用法完全相同，只是StringBuffer是线程安全的。</p>
<p>StringBulider、StringBuffer有两个属性：length和capaity，其中lengith，其中length属性表示其包含的字符序列的长度。与String对象的length对象的length不同的是，StringBulider、StringBuffer的length是可以改变的，可以通过length()、setLength(int len)方法来访问和修改其字符序列的长度。capaity属性表示StringBuilder类的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		通过StringBuilder类，创建一个内容可变的字符串变量</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="comment">//		追加字符串</span></span><br><span class="line">		sb.append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">//		插入</span></span><br><span class="line">		sb.insert(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//		替换</span></span><br><span class="line">		sb.replace(<span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//		删除</span></span><br><span class="line">		sb.delete(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">		System.out.println(sb);</span><br><span class="line"><span class="comment">//		反转</span></span><br><span class="line">		sb.reverse();</span><br><span class="line">		System.out.println(sb);</span><br><span class="line">		System.out.println(sb.length());</span><br><span class="line">		System.out.println(sb.capacity());<span class="comment">//输出16</span></span><br><span class="line"><span class="comment">//		改变StringBuilder的长度，将只保留前面部分</span></span><br><span class="line">		sb.setLength(<span class="number">5</span>);</span><br><span class="line">		System.out.println(sb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字部分师范看StringBulider类的追加、插入、替换、删除等操作，这些操作改变了StringBulider里的字符序列，这就是StringBulider与String之间最大的区别：StringBulider的字符序列是可变的。从程序可看到StringBulider的Length()方法返回其字符序列的长度，而capacity()返回值则比length()返回值大。</p>

        <h3 id="7-3-4-Math类"   >
          <a href="#7-3-4-Math类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-4-Math类" class="headerlink" title="7.3.4 Math类"></a>7.3.4 Math类</h3>
      <p>Java提供了的基本的+、-、*、&#x2F;、%等基本算术运算的运算符，但对于更复杂的数学运算，例如，三角函数、对数运算、指数运算等无能为力。Java提供了Math工具类来完成这些复杂的运算，Math类是一个工具类、它的构造器被定义成private的，因此无法创建Math类的对象：Math类中的所有方法都是类方法，可以直接通过类名来调用他们。Math类提供了大量静态方法之外，还提供了两个类变量：PI和E，指π和e。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*----------下面是三角运算-----------*/</span></span><br><span class="line">		<span class="comment">// 将弧度转换成角度</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Math.toDegrees(1.57)：&quot;</span> + Math.toDegrees(<span class="number">1.57</span>));</span><br><span class="line">		<span class="comment">// 将角度转换为弧度</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Math.toRadians(90)：&quot;</span> + Math.toRadians(<span class="number">90</span>));</span><br><span class="line"><span class="comment">//		计算反余弦，返回的角度范围在0.0到pi之间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Math.acos(1.2)&quot;</span> + Math.acos(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		计算反正弦，返回的角度范围在-pi/2到pi/2之间</span></span><br><span class="line">		System.out.println(Math.asin(<span class="number">0.8</span>));</span><br><span class="line"><span class="comment">//		计算反正切，返回角度范围在-pi/2到pi/2之间</span></span><br><span class="line">		System.out.println(Math.atan(<span class="number">2.3</span>));</span><br><span class="line"><span class="comment">//		计算三角余弦</span></span><br><span class="line">		System.out.println(Math.cos(<span class="number">1.57</span>));</span><br><span class="line"><span class="comment">//		计算双曲余弦</span></span><br><span class="line">		System.out.println(Math.cosh(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		计算正弦</span></span><br><span class="line">		System.out.println(Math.sin(<span class="number">1.57</span>));</span><br><span class="line"><span class="comment">//		计算双曲正弦</span></span><br><span class="line">		System.out.println(Math.sin(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		计算三角正切</span></span><br><span class="line">		System.out.println(Math.tan(<span class="number">0.8</span>));</span><br><span class="line"><span class="comment">//		计算双曲正切</span></span><br><span class="line">		System.out.println(Math.tanh(<span class="number">2.1</span>));</span><br><span class="line"><span class="comment">//		将矩形坐标（x，y）转换成极坐标（r，thet）</span></span><br><span class="line">		System.out.println(Math.atan2(<span class="number">0.1</span>,<span class="number">0.2</span>));</span><br><span class="line">		<span class="comment">/*----------下面是取整运算-----------*/</span></span><br><span class="line"><span class="comment">//		取整，返回小于目标数的最大整数</span></span><br><span class="line">		System.out.println(Math.floor(-<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		取整，返回大于目标数的最小整数</span></span><br><span class="line">		System.out.println(Math.ceil(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		四舍五入取整</span></span><br><span class="line">		System.out.println(Math.round(<span class="number">2.3</span>));</span><br><span class="line">		<span class="comment">/*----------下面是乘方、开方、指数运算-----------*/</span></span><br><span class="line"><span class="comment">//		计算平方根</span></span><br><span class="line">		System.out.println(Math.sqrt(<span class="number">2.3</span>));</span><br><span class="line"><span class="comment">//		其余Math功能省略，读者可查阅Math API自行学习</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-3-5-ThreadLocalRandom与Random"   >
          <a href="#7-3-5-ThreadLocalRandom与Random" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-5-ThreadLocalRandom与Random" class="headerlink" title="7.3.5 ThreadLocalRandom与Random"></a>7.3.5 ThreadLocalRandom与Random</h3>
      <p>Rondom类专门用于生成一个伪随机数，他有两个构造器：一个构造器舒勇默认的种子（以当前时间为种子），另一个构造器需要程序员显式传入一个long整数的种子。</p>
<p>ThreadLocalRandom类是Java 7新增的一个类，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程资源竞争，最终保证系统具有更好的线程安全性。</p>
<p>ThreadLocalRandom类的用法与Random类的用法基本相同，他提供了一个静态的current()方法来获取ThreadLocalRandom对象，获取该对象之后即可调用各种nextXxx()方法来获取伪随机数了。</p>
<p>可以生成浮点类型的伪随机数，也可以生成整数类型的伪随机数，也可以指定生成随机数的范围。下面关于Random类的用法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="comment">//		从这个随机数生成器的序列中返回下一个伪随机、均匀分布的布尔值。</span></span><br><span class="line"><span class="comment">//		nextBoolean的一般约定是，伪随机生成并返回一个布尔值。</span></span><br><span class="line"><span class="comment">//		值true和false产生的概率(大约)相等。</span></span><br><span class="line">		System.out.println(rand.nextBoolean());</span><br><span class="line">		<span class="type">var</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//		生成随机字节并将它们放入用户提供的字节数组中。</span></span><br><span class="line"><span class="comment">//		产生的随机字节数等于字节数组的长度。</span></span><br><span class="line">		rand.nextBytes(buffer);</span><br><span class="line">		System.out.println(Arrays.toString(buffer));</span><br><span class="line"><span class="comment">//		生成0.0~1.0之间的伪随机double数</span></span><br><span class="line">		System.out.println(rand.nextDouble());</span><br><span class="line"><span class="comment">//		生成0.0~1.0之间的伪随机float数</span></span><br><span class="line">		System.out.println(rand.nextFloat());</span><br><span class="line"><span class="comment">//		生成平均值是0.0，标准差是1.0的伪高斯数</span></span><br><span class="line">		System.out.println(rand.nextGaussian());</span><br><span class="line"><span class="comment">//		生成一个处于int整数取值范围的伪随机数</span></span><br><span class="line">		System.out.println(rand.nextInt());</span><br><span class="line"><span class="comment">//		生成0~26之间的伪随机数</span></span><br><span class="line">		System.out.println(rand.nextInt(<span class="number">26</span>));</span><br><span class="line"><span class="comment">//		生成一个处于long整数须知范围的伪随机整数</span></span><br><span class="line">		System.out.println(rand.nextLong());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Random使用一个48位的种子，如果这个类的两个实例使用同一个种子创建的，对他们以同样的顺序调用方法，则他们会产生相同的数字序列。</p>
<p>下面做了一个实验，可以看到当两个Random对象种子相同时，他们会产生相同的数字序列。值得指出的是，当使用默认的种子构造Random对象时，他们属于同一个种子。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeedTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">50</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;第一个种子为50的Random对象&quot;</span>);</span><br><span class="line">		System.out.println(r1.nextBoolean());</span><br><span class="line">		System.out.println(r1.nextDouble());</span><br><span class="line">		System.out.println(r1.nextFloat());</span><br><span class="line">		System.out.println(r1.nextGaussian());</span><br><span class="line">		<span class="type">var</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">50</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;第二个种子为50的Random对象&quot;</span>);</span><br><span class="line">		System.out.println(r2.nextBoolean());</span><br><span class="line">		System.out.println(r2.nextDouble());</span><br><span class="line">		System.out.println(r2.nextFloat());</span><br><span class="line">		System.out.println(r2.nextGaussian());</span><br><span class="line">		<span class="type">var</span> <span class="variable">r3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;种子为100的Random对象&quot;</span>);</span><br><span class="line">		System.out.println(r3.nextBoolean());</span><br><span class="line">		System.out.println(r3.nextDouble());</span><br><span class="line">		System.out.println(r3.nextFloat());</span><br><span class="line">		System.out.println(r3.nextGaussian());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上面的运行结果可以看出，只要两个Random对象的种子相同，而且&#x3D;&#x3D;方法的调用顺序也相同&#x3D;&#x3D;，他们就会产生相同的数字序列。也就是说，Random产生的数字并不是随机的，而是伪随机。</p>
<p>为了避免两个Random对象产生相同的数字序列，通常建议使用当前时间作为Random对象的种子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br></pre></td></tr></table></div></figure>

<p>在多线程环境下使用ThreadLocalRandom的方式使用Random基本类似，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadLocalRandom</span> <span class="variable">rand</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line"><span class="comment">//生成一个4~20之间的随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">vall</span> <span class="operator">=</span> rand.nextInt(<span class="number">4</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//生成一个2.0~10.0之间的伪随机浮点数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> rand.nextDouble(<span class="number">2.0</span>~<span class="number">10.0</span>);</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-3-6-BigDecimal类"   >
          <a href="#7-3-6-BigDecimal类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-6-BigDecimal类" class="headerlink" title="7.3.6 BigDecimal类"></a>7.3.6 BigDecimal类</h3>
      <p>前面介绍double、fioat两种基本浮点类型时已经指出，这两个基本类型的浮点数容易丢失精度。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 + 0.01 = &quot;</span>+(<span class="number">0.05</span>+<span class="number">0.01</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;1.0 - 0.42 = &quot;</span>+(<span class="number">1.0</span>-<span class="number">0.42</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;123.3/100 = &quot;</span>+(<span class="number">123.3</span>/<span class="number">100</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;4.015*100 = &quot;</span> + (<span class="number">4.015</span>*<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序运行结果表明，Java的 double类型会发生精度丢失，尤其在进行算术运算时更容易发生这种情况。不仅是Java,很多编程语言也存在这样的问题。</p>
<p>为了能精确表示、计算浮点数，Java提供了BigDecimal类，该类提供了大量的构造器用于创建BigDecimal对象，包括把所有的基本数值类型变量转换成一个BigDecimal对象，也包括利用数字字符串、数字字符数组来创建BigDecimal对象。  </p>
<p>查看 BigDecimal 类的 BigDecimal( double val)构造器的详细说明时，可以看到不推荐使用该构造器的说明，主要是因为使用该构造器时有一定的不可预知性。当程序使用 new BigDecimal(0.1)来创建一个 BigDecimal 对象时，它的值并不是0.1,它实际上等于一个近似0.1的数。这是因为0.1无法准确地表示为double浮点数，所以传入 BigDecimal构造器的不会正好等于0.1(虽然表面上等于该值)。  </p>
<p>如果使用 BigDecimal( String val)构造器的结果是可预知的——写入 new BigDecimall(0.1)将创建  个 BigDecimal,它正好等于预期的0.1。因此通常建议优先使用基于 String的构造器。</p>
<p>如果必须使用 double 浮点数作为 BigDecimal构造器的参数时，不要直接将该 double浮点数作为构造器参数创建 BigDecimal对象，而是应该通过 BigDecimal.valueOf(double value)静态方法来创建 BigDecimal对象。</p>
<p>BigDecimal类提供了add()、 subtract()、 multiply()、dvide()、pow()等方法对精确浮点数进行常规算术的基本运算：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.05&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">f2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.01</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.05</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;使用String作为BigDecimal构造器参数：&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 + 0.01 = &quot;</span> + f1.add(f2));</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 - 0.01 = &quot;</span> + f1.subtract(f2));</span><br><span class="line">		System.out.println(<span class="string">&quot;...............&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;使用double作为BigDecimal构造器参数：&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 + 0.01 = &quot;</span> + f3.add(f2));</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 - 0.01 = &quot;</span> + f3.subtract(f2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210328100130103](C:\Program Files\Typora\image\image-20210328100130103.png)</p>
<p>上面程序中f1和f3都是基于0.05创建的BigDecimal对象，其中f1是基于“0.05”字符串，但是f3是基于0.05的double浮点数。所以创建BigDecimal对象时，一定要使用String对象作为参数构造器，而不是直接使用double数字。</p>
<p>如果程序要求对double浮点数进行加减乘除，则需要现将double类型数值包装厂BigDecimal对象，调用BigDecimal对象的方法执行运算后再将结果转换成double型,比较繁琐，可以使用BigDecimal为基础定义一个Arith工具类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arith</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	默认除法运算精度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEF_DIV_SCALE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//	构造器私有，让这个类不能实例化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Arith</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">//	提供精确的加法运算</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		使用double . tostring (double)方法提供的规范的double字符串表示形式，将double转换为BigDecimal。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(d1);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(d2);</span><br><span class="line"><span class="comment">//		将此BigDecimal转换为double。</span></span><br><span class="line">		<span class="keyword">return</span> b1.add(b2).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	提供精确的减法运算</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sub</span><span class="params">(<span class="type">double</span> d3,<span class="type">double</span> d4)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">b3</span> <span class="operator">=</span> BigDecimal.valueOf(d3);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b4</span> <span class="operator">=</span> BigDecimal.valueOf(d4);</span><br><span class="line">		<span class="keyword">return</span> b3.subtract(b4).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	提供精确的乘法运算</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">mul</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(d1);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(d2);</span><br><span class="line"><span class="comment">//		将此BigDecimal转换为double。</span></span><br><span class="line">		<span class="keyword">return</span> b1.multiply(b2).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	提供（相对）精确的除法运算，当发生除不尽时</span></span><br><span class="line"><span class="comment">//	精确到小数点后10位数字后四舍五入</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">div</span><span class="params">(<span class="type">double</span> d3,<span class="type">double</span> d4)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">b3</span> <span class="operator">=</span> BigDecimal.valueOf(d3);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b4</span> <span class="operator">=</span> BigDecimal.valueOf(d4);</span><br><span class="line"><span class="comment">/*		四舍五入模式向“最近的邻居”舍入，除非两个邻居的距离相等，这种情况下取四舍五入。</span></span><br><span class="line"><span class="comment">		表现为舍入模式。</span></span><br><span class="line"><span class="comment">		discardedfraction≥0.5则为UP;</span></span><br><span class="line"><span class="comment">		否则，表现为舍入模式。down。</span></span><br><span class="line"><span class="comment">		注意，这是学校里常用的舍入模式。</span></span><br><span class="line"><span class="comment">		该模式对应于IEEE 754-2019 round - dingattribute roundTiesToAway。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="keyword">return</span> b3.divide(b4,DEF_DIV_SCALE,RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(Arith.add(<span class="number">0.05</span>, <span class="number">0.01</span>));</span><br><span class="line">		System.out.println(Arith.sub(<span class="number">1.0</span>, <span class="number">0.42</span>));</span><br><span class="line">		System.out.println(Arith.mul(<span class="number">4.015</span>, <span class="number">100</span>));</span><br><span class="line">		System.out.println(Arith.div(<span class="number">123.4</span>, <span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>上面运行的结果才是期望的记过，这也正是使用BigDecimal类的作用。</p>

        <h2 id="7-4-Java-8的日期、时间类"   >
          <a href="#7-4-Java-8的日期、时间类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-Java-8的日期、时间类" class="headerlink" title="7.4 Java 8的日期、时间类"></a>7.4 Java 8的日期、时间类</h2>
      <p>Java原本提供了Date和 Calendar用于处理日期、时间的类，包括创建日期、时间对象，获取系统当前日期、时间等操作。但Date不仅无法实现国际化，而且它对不同属性也使用了前后矛盾的偏移量，  比如月份与小时都是从0开始的，月份中的天数则是从1开始的，年又是从1900开始的，而 java.util.Calendar则显得过于复杂，从下面介绍中会看到传统Java对日期、时间处理的不足。ava8吸取了 Joda-Time库(一个被广泛使用的日期、时间库)的经验，提供了一套全新的日期时间库。</p>

        <h3 id="7-4-1Date类"   >
          <a href="#7-4-1Date类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-1Date类" class="headerlink" title="7.4.1Date类"></a>7.4.1Date类</h3>
      <p>Java提供了Date类来处理日期、时间(此处的Date是指java.util包下的Date类，而不是java.sql 包下的Date类),Date对象既包含日期，也包含时间。Date类从JDK1.0起就开始存在了，但正因为它历史悠久，所以它的大部分构造器、方法都已经过时，不再推荐使用了。  </p>
<p>Date类提供了6个构造器，其中4个已经 Deprecated(java不再推荐使用，使用不再推荐的构造器时编译器会提出警告信息，并导致程序性能、安全性方面的问题),剩下的两个构造器如下 :</p>
<ul>
<li>Date():生成一个代表当前日期时间的date对象。该构造器在底层调用 System. currentTimeMillis()  获得long整数作为日期参数。</li>
<li>Date(long date):根据指定的long型整数来生成一个Date对象。该构造器的参数表示创建的Date  对象和GMT1970年1月1日00:00:00之间的时差，以毫秒作为计时单位与Date构造器相同的是，Date对象的大部分方法也 Deprecated了，剩下为数不多的几个方法。   </li>
<li>boolean after(Date when):测试该日期是否在指定日期when之后。   </li>
<li>boolean before( Date when):测试该日期是否在指定日期when之前。  </li>
<li>long getTime():返回该时间对应的long型整数，即从GMT1970-01-01 00:00:00到该Date对象之间的时间差，以毫秒作为计时单位   </li>
<li>void setTime( (long time):设置该Date对象的时间。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//		获取当前时间之后100ms的时间</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+<span class="number">100</span>);</span><br><span class="line">		System.out.println(d2);</span><br><span class="line">		System.out.println(d1.compareTo(d2));</span><br><span class="line">		System.out.println(d1.before(d2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>总体来说，Date是一个设计相当糟糕的类，因此Java官方推荐尽量少用Date的构造器和方法。如果需要对日期、时间进行加减运算，或者获取指定时间的年、月、日、时、分、秒信息，可使用Calendar工具类。</p>

        <h3 id="7-4-2-Calendar类"   >
          <a href="#7-4-2-Calendar类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-2-Calendar类" class="headerlink" title="7.4.2 Calendar类"></a>7.4.2 Calendar类</h3>
      <p>因为Date类在设计上存在一些缺陷，所以Java提供了Calendar来更好的处理日期和时间。Calendar是一个抽象类，他用来表示日历。</p>
<p>全世界通常选择最普及、最通用的日历：Gregorian Calendar，也就是日常介绍年份时常用的“公元几几年”  。</p>
<p>Calendar类本身是一个抽象类，它是所有日历类的板，并提供了一些所有日历通用的方法；但它本身不能直接实例化，程序只能创建 Calendar子类的实例，Java本身提供了一个 GregorianCalendar类，一个代表格里高利日历的子类，它代表了通常所说的公历。</p>
<p>当然，也可以创建自己的 Calendar子类，然后将它作为 Calendar对象使用(这就是多态)。因为篇幅关系，本章不会详细介绍如何扩展 Calendar子类，读者可通过互联网查看 Calendar各子类的源码来学习。</p>
<p>Calendar类是一个抽象类，所以不能使用构造器来创建 Calendar对象。但它提供了几个静态   getlnstance()方法来获取 Calendar对象，这些方法根据 TImeZone, Locale类来获取特定的 Calendar,如  果不指定TimeZone、 Locale,则使用默认的 TimeZone、 Locale来创建 Calendar.</p>
<p>Calendar与Date都是表示日期的工具类，他们直接可以自由转换：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个默认的Calendar对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//从Calendar中取出Date对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">date</span> <span class="operator">=</span> .getTime();</span><br><span class="line"><span class="comment">//通过Date对象获取对应的Calendar对象</span></span><br><span class="line"><span class="comment">//因为Calendar/GregorianCalendar没有构造函数可以接收Date对象</span></span><br><span class="line"><span class="comment">//所以必须创建一个Calendar实例，然后调用其setTime()方法。</span></span><br><span class="line"><span class="type">var</span> <span class="variable">calendar2</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar2.setTime(date);</span><br></pre></td></tr></table></div></figure>

<p> Calender类提供了大量修改日期时间的方法，常用方如下：</p>
<ul>
<li>void add(int field,int amount ):  根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li>Int get(int field): 返回指定日历字段的值。</li>
<li>int getActualMaximum(int field):返回指定日历字段可能拥有的最大值。例如月，最大值为11</li>
<li>int getActualMinimum(int field):返回指定日历字段可能拥有的最小值。例如月，最小值为0  </li>
<li>void roll(int field, Int amount):与add()方法类似，区别在于加上 amount后超过了该字段所能表示的最大范围时，也不会向上一个字段进位。</li>
<li>void set(int field, int value):将给定的日历字段设置为给定值 。</li>
<li>void set(int year,, int month, int date):设置 Calendar对象的年、月、日三个字段的值。</li>
<li>void set(int year, int month, int date, int hourOfDay, int minute, Int second):设置 Calendar对象的年、  月、日、时  分、秒6个字段的值。</li>
</ul>
<p>上面的很多方法都需要一个int类型的field参数，field是 Calendar类的类变量，如Calendar.YEAR、Calendar. MONTH等分别代表了年、月、日、小时分钟、秒等时间字段。需要指出的是， Calendar. MONTH  字段代表月份，<strong>月份的起始值不是1,而是0</strong>,所以要设置8月时，用7而不是8，如下程序示范了 Calendar  类的常规用法。 </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">YEAR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MONTH</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//		取出年</span></span><br><span class="line">		System.out.println(c.get(YEAR));<span class="comment">//粗</span></span><br><span class="line">		System.out.println(c.get(MONTH));<span class="comment">//粗</span></span><br><span class="line">		System.out.println(c.get(DATE));<span class="comment">//粗</span></span><br><span class="line">		c.set(<span class="number">2003</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">32</span>,<span class="number">23</span>);<span class="comment">//粗//2003-11-23 12.32.23</span></span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">		c.add(YEAR, -<span class="number">1</span>);<span class="comment">//粗//2002-11-23 12.32.23</span></span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">		c.roll(MONTH, -<span class="number">8</span>);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字代码示范了Calendar类的用法，Calendar可以很灵活的改变它对应的日期。</p>
<p>上面程序中使用了静态导入，它导入了Calendar类里的所有类变量，所以上面程序可以直接使用Calendar类的YEAR、MONTH、DATE等类变量。</p>
<p>Calendar类还有如下几个注意点。</p>

        <h4 id="1-add与roll的区别"   >
          <a href="#1-add与roll的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-add与roll的区别" class="headerlink" title="1.add与roll的区别"></a>1.add与roll的区别</h4>
      <p>add(int field,int amount)的功能非常强大，add主要用于改变Calendar的特定字段的值。如果需要增加某字段的值，则让amount为整数；如果需要减少某字段的值，则让amout为负数即可。</p>
<p>add(int field,int amount)有如下两条规则。</p>
<ul>
<li>当被修改的字段超出它允许的范围的时候，会发生进位，即上一级字段也会增大：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">call</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">call.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//2003-8-23</span></span><br><span class="line">call.add(MONTH,<span class="number">6</span>);<span class="comment">//2004-2-23</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>如果下一级字段也需要改变，那么该字段会修正到变化最小的值：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cal2</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">cal2.set(<span class="number">1003</span>,<span class="number">7</span>,<span class="number">31</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//因为进位后月份改为2月，2月没有31日，自动变成29日</span></span><br><span class="line">val2.add(MONTH,<span class="number">6</span>);<span class="comment">//2003-8-31 → 2004-2-29</span></span><br></pre></td></tr></table></div></figure>

<p>对于上面的例子，8-31就会变成2-29.因为MOUTH的下一级字段是DATE，从31到29改变最小，所以上面2003-8-31的MOUTH字段增加6后，不是变成2004-3-2，而是变成2004-2-29。</p>
<p>roll()的规则与add()的处理规则不同：当贝修改的字段超出它允许的范围时，上一级字段不会增大。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cal3</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">cal3.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//MOUTH字段“进位”，但是YEAR并不增加</span></span><br><span class="line">val3.roll(MOUTH,<span class="number">6</span>);<span class="comment">//2003-8-23 → 2003-2-23</span></span><br></pre></td></tr></table></div></figure>

<p>下一级字段的处理规则用户add()相似;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cal4</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">cal3.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">31</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//MOUTH字段“进位”，但是YEAR并不增加</span></span><br><span class="line">val3.roll(MOUTH,<span class="number">6</span>);<span class="comment">//2003-8-23 → 2003-2-28</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="2-设置Calendar的容错率"   >
          <a href="#2-设置Calendar的容错率" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-设置Calendar的容错率" class="headerlink" title="2.设置Calendar的容错率"></a>2.设置Calendar的容错率</h4>
      <p>调用Calendar对象的set()方法来改变指定字符串的值时，有可能传入一个不合法的参数，例如为MOUTH字段设置13，这将会导致如下后果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenientTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOUTH</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Calendar</span> <span class="variable">ca1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//		如果是字段YEAR字段加一，MOUTH字段为1（2月）</span></span><br><span class="line">		ca1.set(MOUTH,<span class="number">13</span>);<span class="comment">//①</span></span><br><span class="line">		System.out.println(ca1.getTime());</span><br><span class="line"><span class="comment">//		关闭容错性</span></span><br><span class="line">		ca1.setLenient(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//		导致运行时异常</span></span><br><span class="line">		ca1.set(MOUTH, <span class="number">13</span>);<span class="comment">//②</span></span><br><span class="line">		System.out.println(ca1.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>①和②完全相似，但他们的结果不同：①处代码可以正常运行，因为设置MOUTH字段的值为13，将导致YEAR字段加一；②处代码将会导致运行时异常，因为设置的MOUTH字段的值超出了MOUTH字段允许的范围。关键在于程序粗体字的运行，Calendar设置了一个setLenient()用于设置它的容错率，Calendar默认支持好的容错性，通过setLenient(false)可以关闭它的容错率，让他进行严格的参数检查。</p>
<p>Calendar有两种日历模式：</p>
<p>​	lenient模式：每个字段可接受超出它允许范围的值</p>
<p>​	non-lenient模式时，如果某个时间字段设置超出了它允许的取值范围，程序将抛出异常。</p>

        <h4 id="3-set-方法延迟修改"   >
          <a href="#3-set-方法延迟修改" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-set-方法延迟修改" class="headerlink" title="3.set()方法延迟修改"></a>3.set()方法延迟修改</h4>
      <p>set(f,value)方法将日历字段f修改为value，此外它还设置了一个内部成员变量，以指示日历字段f已经被更改。尽管日历字段f是立即更改的，但该Calendar所代表的的时间却不会立即修改，直到下次调用get()，set()，getTimeInMillis()，add()，或roll()时才会重新计算日历的时间。这被称为set()方法延迟修改，采用延迟修改的优势是多次调用set()不会触发多次不必要的计算（需要计算出一个代表实际时间的long型整数）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">		cal.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">31</span>);</span><br><span class="line"><span class="comment">//		将月份设置为9月，但是9月没有31日</span></span><br><span class="line"><span class="comment">//		如果立即修改，系统将会把cal自动调整到10月1日</span></span><br><span class="line">		cal.set(Calendar.MONTH, <span class="number">8</span>);</span><br><span class="line"><span class="comment">//		System.out.println(cal.getTime());//①</span></span><br><span class="line"><span class="comment">//		设置DATE字段为5</span></span><br><span class="line">		cal.set(Calendar.DATE,<span class="number">5</span>);<span class="comment">//②</span></span><br><span class="line">		System.out.println(cal.getTime());<span class="comment">//③</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>程序将①注释了，因为Calendar的set()方法具有延迟修改的特性，即调用set()方法后Calendar实际上并未计算真实的日期，他只是使用内部成员变量表记录MOUTH字段被修改为8，接着程序设置DATE字段值为5，程序内部在此记录DATE——就是9月5日，因此③输出2003-9-5。</p>

        <h3 id="7-4-3新的日期、时间包"   >
          <a href="#7-4-3新的日期、时间包" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-3新的日期、时间包" class="headerlink" title="7.4.3新的日期、时间包"></a>7.4.3新的日期、时间包</h3>
      <p>Jva8专门新增了一个java.time包，该包下包含了如下常用的类。   </p>
<ul>
<li><p>Clock:该类用于获取指定时区的当前日期、时间。该类可取代 System类的currentTimeMillis()  方法，而且提供了更多方法来获取当前日期、时间。该类提供了大量静态方法来获取 Clock对象。</p>
</li>
<li><p>Duration:该类代表持续时间。该类可以非常方便地获取一段时间。  </p>
</li>
<li><p>Instant:代表一个具体的时刻，可以精确到纳秒。该类供了静态的now()方法来获取当前时刻，  也提供了静态的 now(Clock clock)方法来获取 clock对应的时刻。除此之外，它还提供了一系列   minusXXX() 方法在当前时刻基础上减去一段时间，也提供了 plusXxx()方法在当前时刻基础上加上一段时间。</p>
</li>
<li><p>LocalDate:该类代表不带时区的日期，例如2007-12-03。该类提供了静态的now方法来获取  当前日期，也提供了静态的now( Clock cloc)方法来获取 clock对应的日期。除此之外，它还提  供了 minusXxx()方法在当前年份基础上减去几年、几月、几周或几日等，也提供了 plusXxx()  方法在当前年份基础上加上几年、几月、几周或几日等</p>
</li>
<li><p>LocalTime:该类代表不带时区的时间，例如10:15:30。该类提供了静态的now方法来获取当  前时间，也提供了静态的now( (Clock clock)方法来获取 clock对应的时间。除此之外，它还提供  了 minus Xxx()方法在当前年份基础上减去几小时、几分、几秒等，也提供了 plusXxx()方法在当  前年份基础上加上几小时、几分、几秒等。</p>
</li>
<li><p>LocaIDate Time:该类代表不带时区的日期、时间，例如2007-12-07T10:15:30。该类提供了静态的now方法来获取当前日期、时间，也提供了静态的now( Clock clock)方法来获取 clock对应的日期、时间。除此之外，它还提供了 minusXxx()方法在当前年份基础上减去几年、几月、几  日、几小时、几分、几秒等，也提供了 plusXxx()方法在当前年份基础上加上几年、几月、几日、  几小时、几分、几秒等。</p>
</li>
<li><p>MonthDay:该类仅代表月日，例如-04-12。该类提供了静态的now方法来获取当前月日，也提供了静态的     now(Clock clock)方法来获取 clock对应的月日  </p>
</li>
<li><p>Year:该类仅代表年，例如2014。该类提供了静态的now方法来获取当前年份，也提供了静态的now (Clock clock)方法来获取 clock对应的年份。除此之外，它还提供了 minusYears()方法  在当前年份基础上减去几年，也提供了 plusYears()方法在当前年份基础上加上几年。</p>
</li>
<li><p>Year Month:该类仅代表年月，例如2014-04。该类提供了静态的now方法来获取当前年月，  也提供了静态的 now(Clock clock)方法来获取clok对应的年月。除此之外，它还提供了minusXxx()方法在当前年月基础上减去几年、几月，也提供了 plusXxx()方法在当前年月基础上  加上几年、几月。</p>
</li>
<li><p>ZonedDateTime:该类代表一个时区化的日期、时间。  </p>
</li>
<li><p>Zoneld:该类代表一个时区。</p>
</li>
<li><p>DayOfWeek：这是一个枚举类，定义了周日到周六的枚举值   </p>
</li>
<li><p>Month:这也是一个枚举类，定义了一月到十二月的枚举值。</p>
</li>
</ul>
<p>下面通过一个简单的程序来示范这些类的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Clock;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"><span class="keyword">import</span> java.time.MonthDay;</span><br><span class="line"><span class="keyword">import</span> java.time.Year;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewDatePackageTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		-------下面关于Clock的用法---------</span></span><br><span class="line"><span class="comment">//		获取当前的Clock</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line"><span class="comment">//		通过Clock获取当前时刻</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前时刻为&quot;</span>+clock.instant());</span><br><span class="line"><span class="comment">//		获取Clock对应的毫秒数，与System.currentTimeMills()输出相同</span></span><br><span class="line">		System.out.println(clock.millis());</span><br><span class="line">		System.out.println(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//		--------下面关于Duration用法--------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> Duration.ofSeconds(<span class="number">6000</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;6000秒相当于&quot;</span>+d.toMinutes()+<span class="string">&quot;分&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;6000秒相当于&quot;</span>+d.toHours()+<span class="string">&quot;小时&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;6000秒相当于&quot;</span>+d.toDays()+<span class="string">&quot;天&quot;</span>);</span><br><span class="line"><span class="comment">//		在clock基础上增加6000秒，返回新的clock</span></span><br><span class="line"><span class="comment">//		offset:获取一个时钟，从添加了指定持续时间的指定时钟返回瞬时值</span></span><br><span class="line">		<span class="type">var</span>  <span class="variable">clock2</span> <span class="operator">=</span> Clock.offset(clock, d);</span><br><span class="line"><span class="comment">//		可以看出clock与clock2相差的时间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前时刻加6000秒为：&quot;</span>+clock2.instant());</span><br><span class="line"><span class="comment">//		-------下面关于Instant的用法---------</span></span><br><span class="line"><span class="comment">//		获取当前时间</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">		System.out.println(instant);</span><br><span class="line">		<span class="type">var</span> <span class="variable">instant2</span> <span class="operator">=</span> instant.plusSeconds(<span class="number">6000</span>);</span><br><span class="line">		System.out.println(instant2);</span><br><span class="line"><span class="comment">//		根据字符串解析instant对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">instant3</span> <span class="operator">=</span> Instant.parse(<span class="string">&quot;2014-02-03T20:18:09Z&quot;</span>);</span><br><span class="line">		System.out.println(instant3);</span><br><span class="line">		<span class="type">var</span> <span class="variable">instant4</span> <span class="operator">=</span> instant3.plus(Duration.ofHours(<span class="number">1</span>).plusMinutes(<span class="number">4</span>));</span><br><span class="line">		System.out.println(instant4);</span><br><span class="line"><span class="comment">//		获取Instant4 5天前的时刻</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">instant5</span> <span class="operator">=</span> instant4.minus(Duration.ofDays(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//		-------下面关于LoaclDate的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">localdate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">		System.out.println(localdate);</span><br><span class="line"><span class="comment">//		获取2021年的第219天</span></span><br><span class="line">		localdate = LocalDate.ofYearDay(<span class="number">2021</span>, <span class="number">219</span>);</span><br><span class="line">		System.out.println(localdate);</span><br><span class="line"><span class="comment">//		设置为2021年5月21日</span></span><br><span class="line">		localdate = LocalDate.of(<span class="number">2021</span>, Month.MAY, <span class="number">21</span>);</span><br><span class="line">		System.out.println(localdate);</span><br><span class="line"><span class="comment">//		-------下面关于LocalTime的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">localtime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">		System.out.println(localtime)</span><br><span class="line">		localtime = LocalTime.of(<span class="number">22</span>, <span class="number">01</span>);</span><br><span class="line">		System.out.println(localtime);</span><br><span class="line"><span class="comment">//		返回一天中的5503秒</span></span><br><span class="line">		localtime = LocalTime.ofSecondOfDay(<span class="number">5503</span>);</span><br><span class="line">		System.out.println(localtime);</span><br><span class="line"><span class="comment">//		-------下面关于LocalDateTime的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">localdatetime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">		System.out.println(localdatetime);</span><br><span class="line">		<span class="type">var</span> <span class="variable">future</span> <span class="operator">=</span> localdatetime.plusHours(<span class="number">25</span>).plusMinutes(<span class="number">3</span>);</span><br><span class="line">		System.out.println(future);</span><br><span class="line"><span class="comment">//		-------下面关于Year,YearMonth,MonthDay的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">year</span> <span class="operator">=</span> Year.now();</span><br><span class="line">		System.out.println(year);</span><br><span class="line">		<span class="type">var</span> <span class="variable">futureyear</span> <span class="operator">=</span> year.plusYears(<span class="number">5</span>);</span><br><span class="line">		System.out.println(futureyear);</span><br><span class="line"><span class="comment">//		根据指定月份获取YearMonth</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ym</span> <span class="operator">=</span> year.atMonth(<span class="number">10</span>);</span><br><span class="line">		System.out.println(ym);</span><br><span class="line">		ym = ym.plusYears(<span class="number">5</span>).minusYears(<span class="number">3</span>);</span><br><span class="line">		System.out.println(ym);</span><br><span class="line">		<span class="type">var</span> <span class="variable">md</span> <span class="operator">=</span> MonthDay.now();</span><br><span class="line">		System.out.println(md);</span><br><span class="line">		<span class="type">var</span> <span class="variable">md2</span> <span class="operator">=</span> MonthDay.of(<span class="number">5</span>, <span class="number">22</span>);</span><br><span class="line">		System.out.println(md2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该程序就是这些常用类的用法示例，这些API和他们的方法都非常简单。</p>

        <h2 id="7-5-正则表达式"   >
          <a href="#7-5-正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-5-正则表达式" class="headerlink" title="7.5 正则表达式"></a>7.5 正则表达式</h2>
      <p>正则表达式是一个强大的字符串处理工具，可以对字符串进行查找、提取、分割、替换等操作。String类里也提供了几个特殊的方法：</p>
<ul>
<li>boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。</li>
<li>String replaceAll(String regex,String replacement)：将该字符串中所匹配regex的子串替换成replacement。</li>
<li>String replaceFirst(String regex,String replacement)：将该字符串中第一个匹配regex的子串替换成replacement。</li>
<li>String[ ] split(String regex)：以regex作为分隔符，把该字符串分割成多个子串。</li>
</ul>
<p>Java还提供Pattern和Matcher两个类专门用于提供正则表达式支持。</p>
<p>Matcher类：一种引擎，通过解释模式对字符序列执行匹配操作。</p>
<p>匹配器是通过调用模式的匹配器方法来创建的。一旦创建，匹配器可用于执行三种不同的匹配操作:</p>
<p>•matcher():方法尝试将整个输入序列与模式匹配。</p>
<p>•lookingAt():方法尝试匹配输入序列，从开头开始，与模式匹配。</p>
<p>•find():方法扫描输入序列，寻找下一个匹配模式的子序列。</p>
<p>每个方法都返回一个指示成功或失败的布尔值。关于成功匹配的更多信息可以通过查询匹配器的状态来获得。</p>
<p>匹配器在称为region的输入子集中查找匹配项。默认情况下，该区域包含匹配器的所有输入。可以通过region方法修改region，通过regionStart和regionEnd方法查询region。区域边界与某些模式结构交互的方式可以改变。</p>
<p>这个类还定义了用新字符串替换匹配的子序列的方法，如果需要，可以从matchresult计算新字符串的内容。<br>可以同时使用appendReplacement和appendTail方法，以便将结果收集到现有的字符串缓冲区或字符串生成器中。<br>或者，可以使用更方便的replaceAll方法创建一个字符串，其中输入序列中的每个匹配子序列都被替换。</p>

        <h3 id="7-5-1-创建正则表达式"   >
          <a href="#7-5-1-创建正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-5-1-创建正则表达式" class="headerlink" title="7.5.1 创建正则表达式"></a>7.5.1 创建正则表达式</h3>
      <p>正则表达式所支持的合法字符</p>
<div class="table-container"><table>
<thead>
<tr>
<th>字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>字符x（x可代表任何合法字符）</td>
</tr>
<tr>
<td>\0mnn</td>
<td>八进制数0mnn所表示的字符</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制xhh所表示的字符</td>
</tr>
<tr>
<td>\uhhhh</td>
<td>十六进制uhhhh所表示的字符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\a</td>
<td>报警符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape符</td>
</tr>
<tr>
<td>\cx</td>
<td>x对应的控制符。例如，\cM匹配ctrl+M。x必须为A~Z或a ~ z之一。</td>
</tr>
</tbody></table></div>
<p>正则表达式中的特殊字符</p>
<div class="table-container"><table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配一行的结尾。要匹配$字符本身，请使用\$</td>
</tr>
<tr>
<td>^</td>
<td>匹配一行的开头。要匹配^字符本身，请使用\ ^</td>
</tr>
<tr>
<td>()</td>
<td>标记子表达式的开始和结束位置。要匹配这些字符，请使用\(和\)</td>
</tr>
<tr>
<td>[ ]</td>
<td>用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\[和\]</td>
</tr>
<tr>
<td>{ }</td>
<td>用于标记前面子表达式的出现频度。要匹配这些字符，请使用\{和\}</td>
</tr>
<tr>
<td>*</td>
<td>指定前面子表达式可以出现零次或多次。要匹配*字符本身，请使用\ *</td>
</tr>
<tr>
<td>+</td>
<td>指定前面子表达式可以出现一次或多次。要匹配+字符本身，请使用\+</td>
</tr>
<tr>
<td>?</td>
<td>指定前面子表达式可以出现零次或一次。要匹?字符本身，请使用\?</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符n之外的任何单字符。要匹配.字符本身，请使用\.</td>
</tr>
<tr>
<td>\</td>
<td>用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符，请用\\</td>
</tr>
<tr>
<td>|</td>
<td>指定两项之间任选一项。如果要匹配|字符本身，请使用\</td>
</tr>
</tbody></table></div>
<p>将上面多个字符拼起来，就可以创建一个正则表达式。例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u0041\\\\&quot;</span><span class="comment">//匹配A\</span></span><br><span class="line"><span class="string">&quot;\u0061\t &quot;</span> <span class="comment">//匹配a&lt;制表符&gt;  </span></span><br><span class="line"><span class="string">&quot;\\?\\[&quot;</span><span class="comment">//匹配?[</span></span><br></pre></td></tr></table></div></figure>

<p>注意：可能有读者觉得第一个正则表达式中怎么有那么多反斜杠啊?这是由于Java字符串中反斜杠本身需要转义，因此两个反斜杠(\\)实际上相当于一个(前一个用于转义)。</p>
<p>上面的正则表达式依然只能匹配单个字符，这是因为还未在正则表达式中使用“通配符”,“通配符是可以匹配多个字符的特殊字符。正则表达式中的通配符”远远超出了普通通配符的功能，它被称  预定义字符，正则表达式支持如下表所示的预定义字符。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>预定义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>可以匹配任何字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配0~9的所有数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有的非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有的单词字符，包括0~9所有数字、26个英文字母和下画线(_)</td>
</tr>
<tr>
<td>\W</td>
<td>匹配所有的非单词字符</td>
</tr>
</tbody></table></div>
<p>提示：上面的7个预定义字符其实很容易记忆，d是dit的意思，代表数字；s是 space  的意思，代表空白；w是word的意思，代表单词。d、s、w的大写形式恰好匹配与之相反的字符。<br>有了上面的预定义字符后，接下来就可以创建更强大的正则表达式了。例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c\\wt  <span class="comment">//可以匹配cat、cbt、cct、cot、c9t等一批字符串</span></span><br><span class="line">\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d <span class="comment">//匹配如000-000-0000形式的电话号码</span></span><br></pre></td></tr></table></div></figure>

<p>在一些特殊情况下，例如，若只想匹配a~f的母，或者匹配除ab之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有如下表所示的几种形式。</p>
<p>方括号表达式</p>
<div class="table-container"><table>
<thead>
<tr>
<th>方括号表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>表示枚举</td>
<td>例如[abc],表示a、b、c其中任意一个字符；[gz]，表示g,z其中任意一个字符</td>
</tr>
<tr>
<td>表示范 围：-</td>
<td>例如[a-f],表示a<del>f范围内的任意字符；[\\u0041-\\u0056],表示十六进制字符\u0041到\u0056范围的字符。表示范围：  范围可以和枚举结合使用，如[a-cx-z],表示a</del>c、x ~z范围内的任意字符</td>
</tr>
<tr>
<td>表示求否：^</td>
<td>例如[^abc],表示非a、b、c的任意字符；[^a-f]表示不是a-f 范围内的任意字符</td>
</tr>
<tr>
<td>表示“与”运算，&amp;&amp;</td>
<td>例如[a-z&amp;&amp;[def]],求a<del>z和[def]的交集，表示d、e或f  <br /> [a-z&amp;&amp;[ ^bc]],a-z范围内的所有字符，除b和c之外，即[ad-z],<br />[a-z&amp;&amp;[ ^m-p]]范围内的所有字符，除m</del>p范围之外的字符，即[a-lq-z]</td>
</tr>
<tr>
<td>表示“并”运算</td>
<td>并运算与前面的枚举类似。例如[a-d[m-p]],表示[a-dm-p]即a~d,m ~p。</td>
</tr>
</tbody></table></div>
<p>提示：方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要  匹配所有的中文字符，就可以利用u0041-056形式因为所有中文字符的 Unicode  值是连续的，只要找出所有中文字符中最小、最大的 Unicode值，就可以利用上面形式来  匹配所有的中文字符。</p>
<p>正则表示还支持圆括号表达式，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符（|）。例如，正则表达式“( (public)|(protected)|(private))”用于匹配Java的三个访问控制符其中之一。</p>
<p>除此之外，Java正则表达式还支持如下表的几个边界匹配符。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>边界匹配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行的开头</td>
</tr>
<tr>
<td>$</td>
<td>行的结尾</td>
</tr>
<tr>
<td>\b</td>
<td>单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词的边界</td>
</tr>
<tr>
<td>\A</td>
<td>输入的开头</td>
</tr>
<tr>
<td>\G</td>
<td>前一个匹配的结尾</td>
</tr>
<tr>
<td>\Z</td>
<td>输入的结尾，仅用于最后的结束符</td>
</tr>
<tr>
<td>\z</td>
<td>输入的结尾</td>
</tr>
</tbody></table></div>
<p>前面例子中需要建一个000-000-0000式的电话号码时，使用了\d\d\d-\d\d\d-\d\d\d\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。</p>
<ul>
<li><p>Greedy(贪婪模式):数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为——你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 </p>
</li>
<li><p>Reluctant(勉强模式):用问号后缀(?)表示，它只会匹配最少的字符。也称为最小匹配模式 。 </p>
</li>
<li><p>PossessIve(占有模式):用加号后缀(+)表示，目前只有Java支持占有模式，通常比较少用。</p>
<p>三种模式的数量表示符</p>
<div class="table-container"><table>
<thead>
<tr>
<th>贪婪模式</th>
<th>勉强模式</th>
<th>占用模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X??</td>
<td>X?+</td>
<td>X表达式出现零次或一次</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>X表达式出现零次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>X表达式出现一次或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>X表达式出现n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X{n,}?</td>
<td>X{n,}+</td>
<td>X表达式最少出现n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X{n,m}?</td>
<td>X{n,m}+</td>
<td>X表达式最少出现n次，最多出现m次</td>
</tr>
</tbody></table></div>
<p>贪婪模式与勉强模式的对比：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello ,world!&quot;</span>;</span><br><span class="line"><span class="comment">//贪婪模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">&quot;\\w*&quot;</span>,<span class="string">&quot;    &quot;</span>));<span class="comment">//输出    ，world!</span></span><br><span class="line"><span class="comment">//勉强模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">&quot;\\w*?&quot;</span>,<span class="string">&quot;    &quot;</span>));<span class="comment">//输出  helle,world!</span></span><br></pre></td></tr></table></div></figure>

<p>当从“Hello，world！”字符串中查找匹配”&#x2F;&#x2F;w*”子串时，因为“&#x2F;&#x2F;w *”使用了贪婪模式，数量表示符（ *）会一直匹配下去，所以该字符串前面的所有的单词字符都会被匹配到，直到遇到空格；如果使用勉强模式，数量表示符      （ *）会尽量匹配最少字符，即匹配0个字符。</p>

        <h3 id="7-5-2-使用正则表达式"   >
          <a href="#7-5-2-使用正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-5-2-使用正则表达式" class="headerlink" title="7.5.2 使用正则表达式"></a>7.5.2 使用正则表达式</h3>
      <p><strong>正则表达式字符串必须先被编译为Pattern对象，然后利用该Pattern对象创建对应的Matcher对象。</strong>执行匹配所涉及的状态保留在Matcher对象中，多个Matcher可共享一个Pattern对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个字符串编译成Pattern对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"><span class="comment">//使用Pattern对象创建Matcher()对象</span></span><br><span class="line"><span class="comment">//matcher()自动把指定字符串编译成匿名的Pattern对象，并执行匹配</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aaaab&quot;</span>);</span><br><span class="line"><span class="comment">/*matches():试图将整个区域与模式进行匹配。</span></span><br><span class="line"><span class="comment">如果匹配成功，则可以通过start、end和group方法获得更多信息。</span></span><br><span class="line"><span class="comment">当且仅当整个区域序列匹配此匹配器的模式时为真*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> m.matches(); <span class="comment">//返回true</span></span><br></pre></td></tr></table></div></figure>

<p>上面定义的Pattern对象可以多次重复使用。如果某个正则表达式只需要一次使用，则可以直接使用Pattern类的matcher方法，此方法可以自动把指定字符串编译成匿名的Pattern对象，并执行匹配</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Pattern.matcher(<span class="string">&quot;a*b&quot;</span>,<span class="string">&quot;aaaab&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>这句等效于以上三局，但采用这种语句都需要重新编译新的Pattern对象，不能重复利用以编译的Pattern对象，所以效率不高。</p>
<p>&#x3D;&#x3D;Matcher类中的几种方法：&#x3D;&#x3D;</p>
<ul>
<li>find():返回目标字符串中是否包含Pattern匹配的子串。</li>
<li>group():返回上一次与Pattern匹配的子串。</li>
<li>start():返回上一次与Pattern匹配的子串在目标字符串中的开始位置。</li>
<li>end():返回上一次与Pattern匹配的子串在目标字符串中的结束位置加1。</li>
<li>lookungAt():返回目标字符串前面部分与Pattern是否匹配。</li>
<li>matches():返回整个目标字符串与Pattern是否匹配。</li>
<li>reset():将现有的Matcher对象应用于一个新的字符串序列。</li>
</ul>
<p>使用Maycher类的find()和group()方法可以从目标字符串中依次取出特定子串（匹配这则表达式的子串），例如互联网的网络爬虫。他们可以自动从网页上识别出所有的电话号码。</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		使用字符串模拟从网络上得到网页的源码</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我想求购一本《疯狂Java讲义》，尽快联系我15333634564&quot;</span></span><br><span class="line">				+<span class="string">&quot;交朋友，电话号码是17333636698&quot;</span></span><br><span class="line">				+<span class="string">&quot;美女的微信是13165489874&quot;</span></span><br><span class="line">				+<span class="string">&quot;出售二手电脑，联系方式15633644562&quot;</span>;</span><br><span class="line"><span class="comment">//		创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line"><span class="comment">//		该正则表达式要抓取17x和15x段的手机号</span></span><br><span class="line"><span class="comment">//		实际要抓取哪些代码只需要修改正则表达式即可</span></span><br><span class="line"><span class="comment">//		compile：将给定的正则表达式编译成模式。</span></span><br><span class="line"><span class="comment">//		matcher():创建一个匹配器，它将根据这个模式匹配给定的输入。</span></span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;((13\\d)|(15\\d))\\d&#123;8&#125;&quot;</span>).matcher(str);</span><br><span class="line"><span class="comment">//		将所有符合正则表达式的子串全部输出</span></span><br><span class="line"><span class="comment">//		find()：尝试查找与模式匹配的输入序列的下一个子序列。</span></span><br><span class="line">		<span class="keyword">while</span>(m.find())</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			group()：返回与前一个匹配项匹配的输入子序列。</span></span><br><span class="line">			System.out.println(m.group());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>find()方法依次查找字符串中与Pattern匹配的子串，一旦找到对应的子串，下次调用find()方法时将接着向下查找。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartEnd</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;Java is very easy!&quot;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;目标字符串是：&quot;</span> + regStr);</span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>).matcher(regStr);</span><br><span class="line">		<span class="keyword">while</span>(m.find())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(m.group()+<span class="string">&quot;子串的起始位置：&quot;</span></span><br><span class="line">					+m.start()+<span class="string">&quot;其结束位置&quot;</span>+m.end());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>上面程序使用find()、group()方法逐项取出字符串与指定正则表达式匹配的子串，并使用start()、end()方法返回子串在目标字符串中的位置。</strong></p>
<p>matches()和lookingAt()方法有点相似，<strong>只是matches()方法要求整个字符串和Pattern完全匹配时，才返回true，而lookingAt()只要以Pattern开头就会返回true。reset()方法可将现有的Matcher对象应用于新的字符序列。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import java.util.regex.Pattern;</span></span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatchesTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] mails = </span><br><span class="line">			&#123;</span><br><span class="line">					<span class="string">&quot;kidhfkd@163.com&quot;</span>,</span><br><span class="line">					<span class="string">&quot;kidhfkd@gmail.com&quot;</span>,</span><br><span class="line">					<span class="string">&quot;sjndbbcdv.org&quot;</span>,</span><br><span class="line">					<span class="string">&quot;whfioavl.xx&quot;</span></span><br><span class="line">			&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">mailRegEx</span> <span class="operator">=</span> <span class="string">&quot;\\w(3,20)@\\w+\\.(com|org|cn|net|gov)&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">mailPattern</span> <span class="operator">=</span> Pattern.compile(mailRegEx);</span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> mail:mails)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(matcher == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				matcher = mailPattern.matcher(mail);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				reset:用一个新的输入序列重置这个匹配器。</span></span><br><span class="line">				matcher.reset(mail);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mail +(matcher.matches()?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;不是&quot;</span>)</span><br><span class="line">					+<span class="string">&quot;一个有效的邮件地址&quot;</span>;</span><br><span class="line">			System.out.println(result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序创建了一个邮件地址的Pattern，接着用这个Pattern与多个邮箱地址进行匹配。当程序的Matcher为null时，程序调用matcher()来创建一个Matcher对象，一旦Mathcer对象被创建，程序就调用reset()方法将Mathcer应用到新的字符序列。</p>
<p>对目标字符串进行分割、查找、替换等操作：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplaceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] msgs =</span><br><span class="line">		&#123; <span class="string">&quot;Java hsa regular expressions in 1.4&quot;</span>, <span class="string">&quot;regular expressions now expressing in Java&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Java represses oracular expressions&quot;</span> &#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;re\\w*&quot;</span>);</span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; msgs.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(matcher == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				matcher = p.matcher(msgs[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				matcher.reset(msgs[i]);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			String replaceAll():将该字符串中所有匹配regex的子串退换成replacement</span></span><br><span class="line">			System.out.println(matcher.replaceAll(<span class="string">&quot;哈哈:)&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序使用了Matcher类提供的replaceAll()把字符串中所有与正则表达式匹配的子串替换成  哈哈：）“，实际上，Mathcer类还提供了一个replaceFirst()，把方法只替换第一个匹配的子串，运行上面程序，会看到字符串中所有以”re“开头的单词都会替换成  哈哈：）”。</p>
<p>String类中也提供了replaceAll()、replaceFirst()、split()等方法，下面的例子直接使用String类提供的正则表达式功能来进行替换和分割。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReg</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] mags =</span><br><span class="line">		&#123; <span class="string">&quot;Java hsa regular expressions in 1.4&quot;</span>, <span class="string">&quot;regular expressions now expressing in Java&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Java represses oracular expressions&quot;</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> mag : mags)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(mag.replaceFirst(<span class="string">&quot;re\\w*&quot;</span>, <span class="string">&quot;哈哈&quot;</span>));</span><br><span class="line">			System.out.println(Arrays.toString(mag.split(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序只使用String类的replaceFirst()和split()方法对目标对目标字符串进行了一次替换和分割。</p>

        <h2 id="7-6-变量处理和方法处理"   >
          <a href="#7-6-变量处理和方法处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-6-变量处理和方法处理" class="headerlink" title="7.6 变量处理和方法处理"></a>7.6 变量处理和方法处理</h2>
      <p>Java 9 引入了一个新的VarHandle类，并增强了原有的MethodHandle类。通过这两个类，允许Java像动态语言一样引用变量、引用方法，并调用它们。</p>

        <h3 id="7-6-1-Java-9-增强的MethodHandle"   >
          <a href="#7-6-1-Java-9-增强的MethodHandle" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-6-1-Java-9-增强的MethodHandle" class="headerlink" title="7.6.1 Java 9 增强的MethodHandle"></a>7.6.1 Java 9 增强的MethodHandle</h3>
      <p>这种方法引用是一种轻量级的引用方式，他不会检查方法的访问权限，也不会管方法所属的类、实例方法或静态方法，MethodHandle就是简单代表特定的方法，并可通过MethodHandle来调用方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodHandleTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个private类方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	定义一个private实例方法</span></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">hello</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行带参数的hello&quot;</span>+ name);</span><br><span class="line">		<span class="keyword">return</span> name +<span class="string">&quot;您好&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义一个返回值为void，不带形参的方法类型。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">type</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line"><span class="comment">//		使用MethodHandles.lookup的findStatic获取类方法。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">mtd</span> <span class="operator">=</span> MethodHandles.lookup()</span><br><span class="line">				.findStatic(MethodHandleTest.class,<span class="string">&quot;hello&quot;</span>,type);</span><br><span class="line"><span class="comment">//		通过MethodHandle执行方法</span></span><br><span class="line">		mtd.invoke();</span><br><span class="line"><span class="comment">//		使用MethodHandles.lookup()的findVirtual获取实例方法</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">mtd2</span> <span class="operator">=</span> MethodHandles.lookup()</span><br><span class="line">				.findVirtual(MethodHandleTest.class,<span class="string">&quot;hello&quot;</span>,</span><br><span class="line"><span class="comment">//						指定获取返回值为String、形参为String的方法类型</span></span><br><span class="line">						MethodType.methodType(String.class,String.class));</span><br><span class="line"><span class="comment">//		通过MethodType执行方法，传入主调对象和参数</span></span><br><span class="line">		System.out.println(mtd2.invoke(<span class="keyword">new</span> <span class="title class_">MethodHandleTest</span>(),<span class="string">&quot;孙悟空&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上面三行粗体字代码中可以看出，程序使用MethodHandles.lookup对象根据类、方法名，方法类型来获取MethodHandle对象。由于此处的方法名只是一个字符串，而该字符串可以来自变量、配置文件等，这意味着MethodHandle可以让Java动态的调用某个方法。</p>

        <h3 id="7-6-2-Java-9-新增的varHandle"   >
          <a href="#7-6-2-Java-9-新增的varHandle" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-6-2-Java-9-新增的varHandle" class="headerlink" title="7.6.2 Java 9 新增的varHandle"></a>7.6.2 Java 9 新增的varHandle</h3>
      <p>用于动态的操作数组或者对象的成员变量。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User7</span></span><br><span class="line">&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> MAX_AGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarHandleTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Kotlin&quot;</span>,<span class="string">&quot;Go&quot;</span>&#125;; </span><br><span class="line"><span class="comment">//		获取一个String[]数组的VarHandle对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">avh</span> <span class="operator">=</span> MethodHandles.arrayElementVarHandle(String[].class);<span class="comment">//粗体·</span></span><br><span class="line"><span class="comment">//		比较并设置：2表示第三个元素，如果第三个元素时Go，则被设置为Lua</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> avh.compareAndSet(sa,<span class="number">2</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Lua&quot;</span>);<span class="comment">//粗体·</span></span><br><span class="line">		System.out.println(r);</span><br><span class="line">		System.out.println(Arrays.toString(sa));</span><br><span class="line"><span class="comment">//		获取并设置：</span></span><br><span class="line">		System.out.println(avh.getAndSet(sa,<span class="number">2</span>,<span class="string">&quot;Swift&quot;</span>));</span><br><span class="line">		System.out.println(Arrays.toString(sa));</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		用findVarHandle方法获取uesr7类中名为name</span></span><br><span class="line"><span class="comment">//		类型为String的实例变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">vh1</span> <span class="operator">=</span> MethodHandles.lookup().findVarHandle(User7.class, </span><br><span class="line">				<span class="string">&quot;name&quot;</span>,String.class);  <span class="comment">//粗体·</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User7</span>();</span><br><span class="line"><span class="comment">//		通过varHandle获取实例变量的值，需要传入对象作为调用者</span></span><br><span class="line">		System.out.println(vh1.get(user));<span class="comment">//粗体·</span></span><br><span class="line"><span class="comment">//		通过varHandle获取实例变量的值，需要传入对象作为调用者</span></span><br><span class="line">		vh1.set(user,<span class="string">&quot;孙悟空&quot;</span>);<span class="comment">//粗体·</span></span><br><span class="line"><span class="comment">//		输出user的name实例的值</span></span><br><span class="line">		System.out.println(user.name);</span><br><span class="line"><span class="comment">//		用findVarHandle方法获取User类中名为MAX_AGE</span></span><br><span class="line"><span class="comment">//		类型为Integer的类变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">vh2</span> <span class="operator">=</span> MethodHandles.lookup().findStaticVarHandle(User7.class, </span><br><span class="line">				<span class="string">&quot;MAX_AGE&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">		System.out.println(vh2.get());</span><br><span class="line">		vh2.set(<span class="number">88</span>);</span><br><span class="line">		System.out.println(User7.MAX_AGE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>粗可以看出，程序调用MethodHandle类的静态方法可获取操作数组的VarHandle对象，接下来程序可以通过VarHandle对象来操作数组的方法，包括比较并设置数组元素、获取并这只数组元素等，VarHandle具体支持哪些方法则可参考API文档。</p>
<p>后三粗示范了使用VarHandle操作实例变量的情景，由于实例变量需要使用对象来访问，因此使用VarHandle操作实例变量时需要传入一个User对象。</p>
<p>操作类变量和实例变量差别不大，区别只是类变量不需要对象，而实例变量需要对象，因此VarHandle操作类变量是无须传入对象作为参数。</p>
<p>当程序通过MethodHandles.Lookup来获取成员变量时，可根据字符串名称来获取成员变量，这个字符串名称同样是可以动态改变的。</p>

        <h2 id="7-7-Java-11改进的国际化与格式化"   >
          <a href="#7-7-Java-11改进的国际化与格式化" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-Java-11改进的国际化与格式化" class="headerlink" title="7.7 Java 11改进的国际化与格式化"></a>7.7 Java 11改进的国际化与格式化</h2>
      <p>国际化（Internationaliaztion）简称I18N。</p>

        <h3 id="7-7-2-Java支持的国家或语言"   >
          <a href="#7-7-2-Java支持的国家或语言" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-2-Java支持的国家或语言" class="headerlink" title="7.7.2 Java支持的国家或语言"></a>7.7.2 Java支持的国家或语言</h3>
      <p>调用Locale类的getAvailableLocales()方法，该方法返回一个Locale数组，该数组中包含了Java所支持的国家和语言。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocaleList</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		返回Java所支持的全部国家和语言的数组</span></span><br><span class="line">		Locale[] localeList = Locale.getAvailableLocales();</span><br><span class="line"><span class="comment">//		遍历每个数组的元素，依次获取所支持的国家和语言</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;localeList.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(localeList[i].getDisplayCountry()</span><br><span class="line">					+<span class="string">&quot;=&quot;</span>+localeList[i].getCountry()+<span class="string">&quot; &quot;</span></span><br><span class="line">					+localeList[i].getDisplayLanguage()</span><br><span class="line">					+<span class="string">&quot;=&quot;</span>+localeList[i].getLanguage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-3-完成程序国际化"   >
          <a href="#7-7-3-完成程序国际化" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-3-完成程序国际化" class="headerlink" title="7.7.3 完成程序国际化"></a>7.7.3 完成程序国际化</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		获得系统默认的国家\语言环境</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">myLocale</span> <span class="operator">=</span> Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line"><span class="comment">//		根据指定的国家/语言环境加载资源文件</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;mess&quot;</span>,myLocale);</span><br><span class="line">		System.out.println(bundle.getString(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-4-使用MessageFormat处理包含占位符的字符串"   >
          <a href="#7-7-4-使用MessageFormat处理包含占位符的字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-4-使用MessageFormat处理包含占位符的字符串" class="headerlink" title="7.7.4 使用MessageFormat处理包含占位符的字符串"></a>7.7.4 使用MessageFormat处理包含占位符的字符串</h3>
      <p>myMess_en_US.properties</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg = Hello,&#123;0&#125;!Today is &#123;1&#125;.</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloArg</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义一个Locale变量</span></span><br><span class="line">		<span class="type">Locale</span> <span class="variable">currentLocale</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//		运行程序指定了两个参数</span></span><br><span class="line">		<span class="keyword">if</span>(args.length == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			使用运行时的两个参数构造Locale实例</span></span><br><span class="line">			currentLocale = <span class="keyword">new</span> <span class="title class_">Locale</span>(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			否则直接用系统默认的Locale</span></span><br><span class="line">			currentLocale = Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		根据Locale加载语言资源</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;myMess&quot;</span>,currentLocale);</span><br><span class="line"><span class="comment">//		取得已加载中的资源文件中的msg对应消息</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">msg</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line"><span class="comment">//		使用MessageFormat为带占位符的字符串传入参数</span></span><br><span class="line">		System.out.println(MessageFormat.format(msg, <span class="string">&quot;Mr.zhang&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对于占位符字符串，只需要使用MessageFormat类的format()方法为消息中的占位符指定参数即可。</p>

        <h3 id="7-7-5-使用类文件代替资源文件"   >
          <a href="#7-7-5-使用类文件代替资源文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-5-使用类文件代替资源文件" class="headerlink" title="7.7.5 使用类文件代替资源文件"></a>7.7.5 使用类文件代替资源文件</h3>
      <p>除使用属性文件为资源文件外，Java也允许使用类文件代替资源文件，即将所有的key-value对存入class文件，而不是属性文件。</p>
<p>使用类文件来代替资源文件必须满足如下条件。</p>
<ul>
<li>该类的类名必须是baseName_language_country，这与属性文件的命名相似。</li>
<li>该类必须继承ListResourceBundle,并重写getContents()方法，该方法返回Object数组，该数组的每一项都是键值对（key-value对）。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ListResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myMess_zh_CN</span> <span class="keyword">extends</span> <span class="title class_">ListResourceBundle</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object myData[] []=</span><br><span class="line">		&#123;</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;&#123;0&#125;,你好！今天的日期是&#123;1&#125;&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"><span class="comment">//	重写getContents()方法</span></span><br><span class="line">	<span class="keyword">public</span> Object[][]getContents()</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		该方法返回资源的key-value对</span></span><br><span class="line">		<span class="keyword">return</span> myData;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面文件是一个简体中文语言环境的资源文件，该文件可以代替myMess_zh_CN.properties 文件;如果需要代替美国英语语言环境的资源文件，则还应该提供一个myMess_en_US 类。</p>
<p>如果系统同时存在资源文件、类文件，系统将以类文件为主，而不会调用资源文件。对于简体中文的 Locale，ResourceBundle 搜索资源文件的顺序是:<br>(1)baseName_zh_CN.class<br>(2)baseName_zh_CN.properties(3)baseName_zh.class<br>(4)baseName_zh.properties<br>(5)baseName.class</p>
<p>系统按上面的顺序搜索资源文件，如果面的文件不存在,才会使用下一个文件，如果一直找不到对应的文件，系统将抛出异常。</p>

        <h3 id="7-7-6-Java-9新增的日志API"   >
          <a href="#7-7-6-Java-9新增的日志API" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-6-Java-9新增的日志API" class="headerlink" title="7.7.6 Java 9新增的日志API"></a>7.7.6 Java 9新增的日志API</h3>
      
        <h3 id="7-7-7-使用NumberFormat格式化数字"   >
          <a href="#7-7-7-使用NumberFormat格式化数字" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-7-使用NumberFormat格式化数字" class="headerlink" title="7.7.7 使用NumberFormat格式化数字"></a>7.7.7 使用NumberFormat格式化数字</h3>
      <p>MessageFormat是抽象类Format的子类，Format抽象类还有两个子类：NumberFormat和DateFormat，两个子类中提供了两个方法：format()和parse()方法，format()用于将数值、日期转换为字符串，parse()用于将字符串装换为数值和日期。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.NumberFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberFormatTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="number">11230000.76</span>;</span><br><span class="line">		Locale[] locales = &#123;</span><br><span class="line">				Locale.CHINA,Locale.JAPAN,Locale.GERMAN,Locale.US</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberFormat</span>[<span class="number">12</span>];</span><br><span class="line"><span class="comment">//		为上面的Locale创建12个NumberFormat对象</span></span><br><span class="line"><span class="comment">//		每个Locale分别有数值格式器、百分数格式器、货币格式器</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nf[i*<span class="number">3</span>] = NumberFormat.getNumberInstance(locales[i]);</span><br><span class="line">			nf[i*<span class="number">3</span>+<span class="number">1</span>] = NumberFormat.getPercentInstance(locales[i]);</span><br><span class="line">			nf[i*<span class="number">3</span>+<span class="number">2</span>] = NumberFormat.getCurrencyInstance(locales[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">tip</span> <span class="operator">=</span> i == <span class="number">0</span> ? <span class="string">&quot;--------中国格式--------&quot;</span></span><br><span class="line">					:i==<span class="number">1</span>? <span class="string">&quot;--------日本格式--------&quot;</span>:</span><br><span class="line">						i==<span class="number">2</span>?<span class="string">&quot;--------德国格式--------&quot;</span>:<span class="string">&quot;--------美国格式--------&quot;</span>;</span><br><span class="line">			System.out.println(tip);</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的数值格式：&quot;</span></span><br><span class="line">					+nf[i*<span class="number">3</span>].format(bd));</span><br><span class="line">			System.out.println(<span class="string">&quot;百分比数值格式：&quot;</span></span><br><span class="line">					+nf[i*<span class="number">3</span>+<span class="number">1</span>].format(bd));</span><br><span class="line">			System.out.println(<span class="string">&quot;货币数值格式：&quot;</span></span><br><span class="line">					+nf[i*<span class="number">3</span>+<span class="number">2</span>].format(bd));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-8-使用DateFormat格式化日期、时间"   >
          <a href="#7-7-8-使用DateFormat格式化日期、时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-8-使用DateFormat格式化日期、时间" class="headerlink" title="7.7.8 使用DateFormat格式化日期、时间"></a>7.7.8 使用DateFormat格式化日期、时间</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormatTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		需要格式化的时间</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		Locale[] locales = &#123;Locale.CHINA,Locale.US&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateFormat</span>[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//		为上面两个Locale创建16个DateFormat对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			df[i*<span class="number">8</span>] = DateFormat.getDateInstance(DateFormat.SHORT,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">1</span>] = DateFormat.getDateInstance(DateFormat.MEDIUM,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">2</span>] = DateFormat.getDateInstance(DateFormat.LONG,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">3</span>] = DateFormat.getDateInstance(DateFormat.FULL,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">4</span>] = DateFormat.getTimeInstance(DateFormat.SHORT,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">5</span>] = DateFormat.getTimeInstance(DateFormat.MEDIUM,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">6</span>] = DateFormat.getTimeInstance(DateFormat.LONG,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">7</span>] = DateFormat.getTimeInstance(DateFormat.FULL,locales[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">tip</span> <span class="operator">=</span> i == <span class="number">0</span> ? <span class="string">&quot;--------中国格式日期--------&quot;</span></span><br><span class="line">					:<span class="string">&quot;--------美国日期格式--------&quot;</span>;</span><br><span class="line">			System.out.println(tip);</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的MEDIUM格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">1</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的LONG格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">2</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的FULL格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">3</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">4</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">5</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">6</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">7</span>].format(dt));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;---------------下面为测试是否采用严格语法---------------&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;2021/2/31&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;2021年2月31日&quot;</span>;</span><br><span class="line">		System.out.println(DateFormat.getDateInstance().parse(str2));</span><br><span class="line">		System.out.println(DateFormat.getDateInstance(DateFormat.SHORT).parse(str1));</span><br><span class="line">        <span class="comment">//引发异常，因为str1是一个SHORT字符串，必须使用SHORT样式的DateFormat实例解析</span></span><br><span class="line">		System.out.println(DateFormat.getDateInstance().parse(str1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-9-使用SimpleDateFormat格式化日期"   >
          <a href="#7-7-9-使用SimpleDateFormat格式化日期" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-9-使用SimpleDateFormat格式化日期" class="headerlink" title="7.7.9 使用SimpleDateFormat格式化日期"></a>7.7.9 使用SimpleDateFormat格式化日期</h3>
      <p>前面介绍的DateFormat的parse()方法可以把字符串解析成Date对象，但实际上DateFormat的parse()方法不够灵活——他被要求解析的字符串必须满足特定的格式！为了更好地格式化日期、解析日期字符串，Java提供了SimpleDateFormat类。</p>
<p>SimpleDateFormat是DateFormat的子类，正如它的名字所暗示的，他是简单的日期格式器。很多读者对“简单的”格式器不屑一顾，实际上SimpleDateFormat 比DateFormat更简单，功能更强大。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">var</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;Gyyyy年中的第D天&quot;</span>);</span><br><span class="line"><span class="comment">//		将D格式化为日期</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dateStr</span> <span class="operator">=</span> sdf1.format(d);</span><br><span class="line">		System.out.println(dateStr);</span><br><span class="line"><span class="comment">//		一个非常特殊的日期字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;14####3月##21&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;y####MMM##d&quot;</span>);</span><br><span class="line"><span class="comment">//		将日期字符串解析成日期，输出：Fri Mar 21 00:00..........</span></span><br><span class="line">		System.out.println(sdf2.parse(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这样的字符串解析成日期，功能非常强大。格式化怎么样的字符串完全取决于创建该对象是指定的pattern参数，oattern是一个使用日期字段占位符的日期模板。</p>

        <h2 id="7-8-Java-8新增的日期、时间格式器"   >
          <a href="#7-8-Java-8新增的日期、时间格式器" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-8-Java-8新增的日期、时间格式器" class="headerlink" title="7.8 Java 8新增的日期、时间格式器"></a>7.8 Java 8新增的日期、时间格式器</h2>
      <p>DateTimeFormatter类相当与前面介绍的DateFormat和SimpleDateFormatter的合体，功能十分强大。</p>
<p>使用DateTimeFormatter进行格式化或解析，必须进行格式化或解析，必须先获取DateTimeFormatter对象。</p>

        <h3 id="7-8-1-使用DateTimeFormatter完成格式化"   >
          <a href="#7-8-1-使用DateTimeFormatter完成格式化" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-8-1-使用DateTimeFormatter完成格式化" class="headerlink" title="7.8.1 使用DateTimeFormatter完成格式化"></a>7.8.1 使用DateTimeFormatter完成格式化</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.format.FormatStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewFormatterTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">formatters</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTimeFormatter</span>[] </span><br><span class="line">				&#123;</span><br><span class="line"><span class="comment">//						直接使用常量创建DateTimeFormatter格式器</span></span><br><span class="line">						DateTimeFormatter.ISO_LOCAL_DATE,</span><br><span class="line">						DateTimeFormatter.ISO_LOCAL_TIME,</span><br><span class="line">						DateTimeFormatter.ISO_LOCAL_DATE_TIME,</span><br><span class="line"><span class="comment">//						使用本地化的不同风格来创建DateTimeFormatter格式器</span></span><br><span class="line">						DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL,FormatStyle.MEDIUM),</span><br><span class="line">						DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG),</span><br><span class="line"><span class="comment">//						根据模式字符串来创建DateFormatter格式化</span></span><br><span class="line">						DateTimeFormatter.ofPattern(<span class="string">&quot;Gyyyy%%MMM%%dd HH:mm:ss&quot;</span>)</span><br><span class="line">				&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//		依次使用不同的格式器对LocalDateTime进行格式化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; formatters.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(date.format(formatters[i]));<span class="comment">//粗</span></span><br><span class="line">			System.out.println(formatters[i].format(date));<span class="comment">//粗</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>粗从不同方式来格式化日期。</p>
<p>7.8.2 使用DateTimeFoematter解析字符串</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewFormatterParse</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义一个任意格式的日期、时间字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;2012==04==12 01时07分09秒&quot;</span>;</span><br><span class="line"><span class="comment">//		根据需要解析的日期、时间字符串定义解析所有的格式器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy==MM==dd HH时jj分pp秒&quot;</span>);</span><br><span class="line"><span class="comment">//		执行解析</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dt1</span> <span class="operator">=</span> LocalDateTime.parse(str1,formatter1);</span><br><span class="line">		System.out.println(dt1);</span><br><span class="line"><span class="comment">//省略第二个</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="小结："   >
          <a href="#小结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1>
      <p>本章介绍了运行Java程序时的参数，并详细解释了main方法签名的含义。为了实现字符界面程序与晕乎交互功能，介绍了两种读取键盘输入的方法（hasNext(),next()），还介绍了System、Runtime、String、StringBuffer、StringBuilder、Math、BigDecimal、Random、Date、Calendar和TimeZone等常用类的用法。</p>
<p>重点介绍了正则表达式，以及使用Pattern、Matcher、String等类来使用正则。还介绍了程序国际化等，还介绍了新增的日期、时间包，以及新增的日期时间格式符。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/">《疯狂Java讲义——面向对象（下）》</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="第六章-面向对象（下）"   >
          <a href="#第六章-面向对象（下）" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六章-面向对象（下）" class="headerlink" title="第六章 面向对象（下）"></a>第六章 面向对象（下）</h1>
      
        <h2 id="6-1包装类"   >
          <a href="#6-1包装类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1包装类" class="headerlink" title="6.1包装类"></a>6.1包装类</h2>
      <p>以下八个基本类型都不能当做对象使用，也不能接受null值。</p>
<p>为了解决此问题java为8个基本类型提供了对应的包装类——可将他们包装成对象。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table></div>
<p>JDK1.5提供了自动装箱（Autoboxing）和自动拆箱（AutoUnboxing）功能，所谓自动装箱，<strong>就是可以把一个基本类型变量直接赋给对应的包装类变量，或者赋给Object变量（Object时所有类的父类，子类对象可以直接赋给父类变量）；自动拆箱则相反，允许把一个包装类对象直接赋值给一个对应的基本类型变量。</strong></p>
<p>自动装箱：基本类型的值可以自动当成包装类的实例使用。</p>
<p>自动拆箱：包装类的实例可以自动当成基本类型的值使用。</p>
<p>​	建议：以后做项目时，通常来说建议使用包装类来声明变量。</p>
<p>​				好处：基本类型能做的它都可以做，它还可以当做对象使用，还可以接受null。</p>
<p>能用钱解决的问题就不要用技术解决</p>
<p>进行自动装箱和自动拆箱时必须注意类型匹配，例如Integer只能自动拆箱成int类型变量，不要试图拆箱成boolean类型变量；与之类似，int类型变量也只能自动装箱成Integer对象（即使赋给Object类型变量，那也只是利用了Java的向上转型特性），不要试图装箱成为Boolean对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoBoxingUnboxing</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//直接把一个基本类型变量赋给Integer对象   自动装箱</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">inObj</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="comment">//直接把一个boolean类型变量赋给一个Object类型的变量</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">boolObj</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//直接把一个Integer对象赋给int类型的变量   自动拆箱</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> inObj;</span><br><span class="line">		<span class="keyword">if</span>(boolObj <span class="keyword">instanceof</span> Boolean)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//先把Object对象强制类型转换为Boolean类型，再赋给boolean变量</span></span><br><span class="line">			<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> (Boolean) boolObj;   <span class="comment">//自动拆箱   Boolean转换为boolean</span></span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Integer.parseInt()是把()里的内容转换成整数。</p>
<p>Integer. valueOf()可以将基本类型int转换为包装类型Integer，或者将String转换成Integer，String如果为Null或“”都会报错。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Primitive2String</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">intStr</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">		<span class="comment">//把一个特定字符串转换成int变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it1</span> <span class="operator">=</span> Integer.parseInt(intStr);</span><br><span class="line">		<span class="type">var</span> <span class="variable">it2</span> <span class="operator">=</span> Integer.valueOf(intStr);</span><br><span class="line">		System.out.println(it2);</span><br><span class="line">		<span class="type">var</span> <span class="variable">floatStr</span> <span class="operator">=</span> <span class="string">&quot;4.56&quot;</span>;</span><br><span class="line">		<span class="comment">//把一个特定字符串转换成float变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ft1</span> <span class="operator">=</span> Float.parseFloat(floatStr);</span><br><span class="line">		<span class="type">var</span> <span class="variable">ft2</span> <span class="operator">=</span> Float.valueOf(floatStr);</span><br><span class="line">		System.out.println(ft2);</span><br><span class="line">		<span class="comment">//把一个float变量转换成String变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ftStr</span> <span class="operator">=</span> String.valueOf(<span class="number">2.345f</span>);</span><br><span class="line">		System.out.println(ftStr);</span><br><span class="line">		<span class="comment">//把一个double变量转换成String变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dbStr</span> <span class="operator">=</span> String.valueOf(<span class="number">3.344</span>);</span><br><span class="line">		System.out.println(dbStr);</span><br><span class="line">		<span class="comment">//把一个boolean变量转换成String变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">fdStr</span> <span class="operator">=</span> String.valueOf(<span class="literal">false</span>);</span><br><span class="line">		System.out.println(fdStr.toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>系统把一个-128<del>127之间的整数自动装箱成Integer实例，并放入一个名为cache的数组中缓存起来。如果以后把一个-128</del>127之间的整数自动装箱成一个Integer实例时，实际上是直接指向对应的数组元素，因此-128<del>127之间的同一个整数自动装箱成Integer实例时，永远都是引用cache数组的同一个数组元素，所以它们全部相等；但每次把一个不在-128</del>127范围之内的整数自动装箱成Integer实例时，系统总会重新创建一个Integer实例，所以系统会判断不相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperClassCompare</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">6</span>);</span><br><span class="line">		<span class="comment">//输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;6的包装类实例是否大于5.0&quot;</span>+(a&gt;<span class="number">5.0</span>));</span><br><span class="line">		<span class="comment">//两个包装实例进行比较，只有两个包装类引用指向同一个对象时才会返回turn</span></span><br><span class="line">		System.out.println(<span class="string">&quot;比较2个包装类的实例是否相等：&quot;</span></span><br><span class="line">				+ (Double.valueOf(<span class="number">2.0</span>) == Double.valueOf(<span class="number">2.0</span>)));</span><br><span class="line">		<span class="comment">//通过自动装箱，允许把基本类型值赋给包装类实例</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">ina</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">inb</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;两个2自动装箱后是否相等：&quot;</span> + (ina == inb));</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">biga</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">bigb</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;两个128自动装箱后是否相等：&quot;</span></span><br><span class="line">				+ (biga == bigb));</span><br><span class="line">		System.out.println(Boolean.compare(<span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="包装类的方法"   >
          <a href="#包装类的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#包装类的方法" class="headerlink" title="包装类的方法"></a>包装类的方法</h4>
      <p>parseXxx()：可将字符串转成对应的基本类型值。</p>
<p>NumberFormatException异常：要转的字符串不符合数值格式，将会引发异常。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pares</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Integer op = new Integer();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ui</span> <span class="operator">=</span> <span class="string">&quot;456&quot;</span>;</span><br><span class="line">        System.out.println(Integer.parseInt(ui));</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">u</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">        System.out.println(Boolean.parseBoolean(u));</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="string">&quot;4a56&quot;</span>;</span><br><span class="line">        System.out.println(Integer.parseInt(u1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Java 7为所有包装类都提供了一个静态的compare(xxx val1 , xxx val2)方法，来比较两个基本类型值的大小，包括两个Boolean类型值也可以，且ture&gt;false。</p>
<p>Java 8 再次增强包装类的功能。</p>
<p>![](D:\Program Files\Typora\Images\729c9218e91e590474c60c4f122ab6c.jpg)</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsignedTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">		<span class="comment">//将byte类型的-3转换为无符号整数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;byte类型的-3对应的无符号整数：&quot;</span></span><br><span class="line">				+ Byte.toUnsignedInt(b));</span><br><span class="line">		<span class="comment">//指定使用十六进制解析无符号整数</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">va1</span> <span class="operator">=</span> Integer.parseUnsignedInt(<span class="string">&quot;ab&quot;</span>, <span class="number">16</span>);</span><br><span class="line">		System.out.println(va1);</span><br><span class="line">		<span class="comment">//将-16转换成无符号int型，然后转换为十六进制的字符串</span></span><br><span class="line">		System.out.println(Integer.toUnsignedString(-<span class="number">12</span>,<span class="number">16</span>));</span><br><span class="line">		<span class="comment">//将两个数转换成两个无符号整数后相除</span></span><br><span class="line">		System.out.println(Integer.divideUnsigned(-<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">		<span class="comment">//将两个数转换为无符号整数相除后求余</span></span><br><span class="line">		System.out.println(Integer.remainderUnsigned(-<span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>无符号整数最大的特点是最高位不在被当成符号位，以-3为例，其源码是10000011，其反码是11111100，补码为11111101，如果将此数当成无符号整数处理，那么最高位的1就不再是符号位，也是数值位。</p>

        <h4 id="缓存机制"   >
          <a href="#缓存机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4>
      <p>当程序对Integer使用自动装箱时，他有一个缓存机制，他会缓存值在-128~127之间的数值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(p == p1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">p15</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(p5 == p15);<span class="comment">//falue</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="6-2处理对象"   >
          <a href="#6-2处理对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2处理对象" class="headerlink" title="6.2处理对象"></a>6.2处理对象</h2>
      <p>两个要被重写的方法</p>

        <h3 id="6-2-1打印对象和toString方法"   >
          <a href="#6-2-1打印对象和toString方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-1打印对象和toString方法" class="headerlink" title="6.2.1打印对象和toString方法"></a>6.2.1打印对象和toString方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>	</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="comment">//System.out.println(name);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintObject</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建一个Person对象，将值赋给p变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">		<span class="comment">//打印p所引用的Person对象</span></span><br><span class="line">		System.out.println(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>System.out的println()方法只能在控制台输出字符串，而Person实例时一个内存中的对象，怎么能直接转换为字符串输出呢？当使用该方法输出Person对象时，实际上输出的是Person对象的toString()方法的返回值，也就是说下面两行代码效果完全相同。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(p);</span><br><span class="line">	System.out.println(p.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>toString()方法是一个“自我描述”方法，该方法通常用于实现这样一个功能：当程序员直接打印该对象时，<strong>系统将会输出该对象的“自我描述”信息，默认输出为“类名+@+hashCode”值，如果用户需要自定义类能实现“自我描述”的功能，就必需重写Object类的toString()方法。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;  &#125;</span><br><span class="line">	<span class="comment">//提供有参数的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(String color,<span class="type">double</span> weight)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="comment">//重写toString()方法，用于实现Apple对象的“自我描述”</span></span><br><span class="line">​	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">​	&#123;</span><br><span class="line">​		<span class="keyword">return</span><span class="string">&quot;一个苹果，颜色是：&quot;</span>+color+<span class="string">&quot;,重量是：&quot;</span>+weight;</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红色&quot;</span>,<span class="number">5.68</span>);</span><br><span class="line">		<span class="comment">//打印Apple对象</span></span><br><span class="line">        System.out.println(a);  <span class="comment">//实际输出的为a.toString()方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//任何东西加&quot;&quot;都会变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a + <span class="string">&quot;&quot;</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

<p>重写toString()的固定的格式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">​	&#123;</span><br><span class="line">​		<span class="keyword">return</span><span class="string">&quot;一个苹果，颜色是：&quot;</span>+color+<span class="string">&quot;,重量是：&quot;</span>+weight;</span><br><span class="line">​	&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="6-2-2-x3D-x3D-和equals方法"   >
          <a href="#6-2-2-x3D-x3D-和equals方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-2-x3D-x3D-和equals方法" class="headerlink" title="6.2.2  &#x3D;&#x3D;和equals方法"></a>6.2.2  &#x3D;&#x3D;和equals方法</h3>
      
        <h3 id="测试两个变量是否相等的两种方式："   >
          <a href="#测试两个变量是否相等的两种方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#测试两个变量是否相等的两种方式：" class="headerlink" title="测试两个变量是否相等的两种方式："></a>测试两个变量是否相等的两种方式：</h3>
      <p>  &#x3D;&#x3D; ：如果两个变量是基本类型变量，且都是数值类型(不一定要求数据类型严格相同)，则是要两个变量的值相等，就将返回ture。但对于两个引用类型变量。只有它们指向同一对象时，才会返回ture，它不可用于比较类型上没有父子关系的两个对象。&#x3D;&#x3D;比较符也是比较指向的对象是否相同的也就是对象在对内存中的的首地址</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">fl</span> <span class="operator">=</span> <span class="number">65.0f</span>;</span><br><span class="line">		<span class="comment">//将输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;65和65.0f是否相等？&quot;</span>+(it == fl));</span><br><span class="line">		<span class="type">var</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="comment">//将输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;65和&#x27;A&#x27;是否相等？&quot;</span>+(it == ch));</span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="comment">//将输出false</span></span><br><span class="line">		System.out.println(<span class="string">&quot;str1和str2是否相等？&quot;</span></span><br><span class="line">				+ (str1 == str2));</span><br><span class="line">		<span class="comment">//输出true</span></span><br><span class="line">		System.out.println(<span class="string">&quot;str1是否equals str2？&quot;</span></span><br><span class="line">				+ (str1.equals(str2)));</span><br><span class="line">		<span class="comment">//由于java.lang.String与EqualTest类没有继承关系</span></span><br><span class="line">		<span class="comment">//所以下面语句导致编译错误</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;hello&quot; == new EqualTest());</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>new String(“hello”)时，JVM会先使用常量池来管理“hello”直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。换句话说，new String(“hello”)一共产生了两个字符串对象。</p>
<p>&#x2F;<em>常量池（constant pool）专门用于管理在编译时被确定并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口中的常量，还包括字符串常量。JVM常量池表保证相同的字符串直接量只有一个，不会产生多个副本。</em>&#x2F;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringCompareTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//s1直接引用常量池中的“疯狂Java”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//s4后面的字符串值可以在编译时就确定下来</span></span><br><span class="line">		<span class="comment">//s4直接引用常量池中的“疯狂Java”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span> + <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//s5后面的字符串值可以在编译时就确定下来</span></span><br><span class="line">		<span class="comment">//s5直接引用常量池中的“疯狂Java”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;疯&quot;</span>+<span class="string">&quot;狂&quot;</span>+<span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//s6后面的字符串值不能在编译时就确定下来</span></span><br><span class="line">		<span class="comment">//不能引用常量池中的字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s6</span> <span class="operator">=</span> s2 + s3;</span><br><span class="line">		<span class="comment">//使用new调用构造器将会创建一个新的String对象</span></span><br><span class="line">		<span class="comment">//s7引用堆内存中新建的String对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java&quot;</span>);</span><br><span class="line">		System.out.println(s1 == s4);</span><br><span class="line">		System.out.println(s1 == s5);</span><br><span class="line">		System.out.println(s1 == s6);</span><br><span class="line">		System.out.println(s1 == s7);</span><br><span class="line">		System.out.println(s8 == s7);</span><br><span class="line">		System.out.println(s8.equals(s7));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>s1,s4,s5所引用的字符串可以再编译期就确定下来，因此他们都将引用的字符串可以在编译器就确定下来，因此他们都将引用引用池中的同一个字符串对象。</p>
<p>使用new String()常见的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存）内，不会放入常量池。</p>
<p>equals()方法是Object类提供的一个实例方法，因此所有引用变量都可调用该方法来判断是否与其他引用变量变量相等，使用这个方法判断两个对象相等的标准与使用&#x3D;&#x3D;没有什么区别，同样要求两个引用变量指向用一个对象才会返回ture。因此这个方法无太大意义，如果希望采用自定义的相等标准，则可采用重写equals方法实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">c</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>+<span class="string">&quot;World&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(s1 == s2)</span><br><span class="line">			System.out.println(<span class="string">&quot;= = succeed&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">		<span class="keyword">if</span>(s1.equals(s2))</span><br><span class="line">			System.out.println(<span class="string">&quot;.equals() succed&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h6 id="equals-重写应该满足一下条件"   >
          <a href="#equals-重写应该满足一下条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#equals-重写应该满足一下条件" class="headerlink" title="equals()重写应该满足一下条件"></a>equals()重写应该满足一下条件</h6>
      <ul>
<li>自反性：对任意x，x.equals(x)一定返回true。</li>
<li>对称性：对任意x和y，如果y.equals(x)返回true，则x.equals(y)也返回true。</li>
<li>传递性：对任意x,y,z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)一定返回true。</li>
<li>一致性：对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是ture，要么一直是false。</li>
<li>对任何不是null的x，x.equals(null)一定返回false。</li>
</ul>
<p>String已经重写了Object的equals()方法，String的equals()方法判断两个字符串是否相等的标准是：只要两个字符串所包含的字符串序列相同则可。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person8</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String idStr;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person8</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person8</span><span class="params">(String name,String idStr)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.idStr = idStr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此处省略name和idStr的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getIdStr</span><span class="params">(String idStr)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.idStr = idStr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getIdStr</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.idStr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写equals</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果两个对象同一个对象</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//只有当obj是Person对象</span></span><br><span class="line">		<span class="comment">//getClass() 返回此 Object 的运行时类</span></span><br><span class="line">		<span class="comment">//类名.class表示语法，表示Person这个类的类型信息</span></span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Person8.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">personObj</span> <span class="operator">=</span> (Person8) obj;</span><br><span class="line">			<span class="comment">//并且当前对象的idStr与obj对象的idStr相等时才可以判断两个对象相等</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.getIdStr().equals(personObj.getIdStr()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideEqualsRight</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person8</span>(<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;123456789987&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person8</span>(<span class="string">&quot;孙大圣&quot;</span>,<span class="string">&quot;123456789987&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person8</span>(<span class="string">&quot;齐天大圣&quot;</span>,<span class="string">&quot;123654&quot;</span>);</span><br><span class="line">		<span class="comment">//p1和p2的idStr相等，所以输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;p1和p2是否相等？&quot;</span></span><br><span class="line">				+ p1.equals(p2));</span><br><span class="line">		<span class="comment">//p2和p3的idStr不相等，所以输出flase</span></span><br><span class="line">		System.out.println(<span class="string">&quot;p2和p3是否相等？&quot;</span></span><br><span class="line">				+ p2.equals(p3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>类名.class表示语法，表示Person这个类的类型信息</p>
<p>instanceof 是Java的一个二元操作符（运算符）,也是Java的保留关键字。它的作用是判断其左边对象是否为其右边类的实例，返回的是boolean类型的数据。用它来判断某个对象是否是某个Class类的实例。（左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。）</p>
<p>重写equals()的固定的格式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果两个对象同一个对象</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//只有当obj是Person对象</span></span><br><span class="line">		<span class="comment">//getClass() 返回此 Object 的运行时类</span></span><br><span class="line">		<span class="comment">//类名.class表示语法，表示Person这个类的类型信息</span></span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Person8.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">personObj</span> <span class="operator">=</span> (Person8) obj;</span><br><span class="line">			<span class="comment">//并且当前对象的idStr与obj对象的idStr相等时才可以判断两个对象相等</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.getIdStr().equals(personObj.getIdStr()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="6-3类成员"   >
          <a href="#6-3类成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-3类成员" class="headerlink" title="6.3类成员"></a>6.3类成员</h2>
      
        <h3 id="static"   >
          <a href="#static" class="heading-link"><i class="fas fa-link"></i></a><a href="#static" class="headerlink" title="static"></a>static</h3>
      <p>static并不是静态的意思，而是类的意思！有static的成员属于类成员，没有static的成员属于实例成员。</p>
<p>static可以修饰的成员：成员变量，方法，内部类，初始化块。</p>

        <h4 id="static成员（成员变量，方法，内部类，初始化块）-属于类成员"   >
          <a href="#static成员（成员变量，方法，内部类，初始化块）-属于类成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#static成员（成员变量，方法，内部类，初始化块）-属于类成员" class="headerlink" title="static成员（成员变量，方法，内部类，初始化块）-属于类成员"></a>static成员（成员变量，方法，内部类，初始化块）-属于类成员</h4>
      <p>所有的类成员只能用类名来调用。</p>
<p>面试的时候遇到使用对象调用类成员的时候，只需要把对象换成类，题目将一目了然。</p>

        <h4 id="static考点（笔试很常见）"   >
          <a href="#static考点（笔试很常见）" class="heading-link"><i class="fas fa-link"></i></a><a href="#static考点（笔试很常见）" class="headerlink" title="static考点（笔试很常见）"></a>static考点（笔试很常见）</h4>
      <p>static成员不可以访问非static成员；</p>
<p>非static成员可以访问static成员！</p>
<p>static成员4种不能访问非static成员5种。</p>

        <h4 id="单例模式"   >
          <a href="#单例模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4>
      <p>设计模式：对于一批经常出现设计场景，前人总结出来的比较成功的设计——设计模式。</p>
<p>​	学习并模仿，从而提高我们的代码质量。</p>
<p>单例模式：在某些场景下，某些类只需（只能）要创建一个实例。比如系统的窗口管理器，数据库引擎访问点，Java程序所在的JRE环境·····都只需要创建一个实例。此时就应该采用单例模式。</p>

        <h5 id="如何创建单例模式"   >
          <a href="#如何创建单例模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何创建单例模式" class="headerlink" title="如何创建单例模式"></a>如何创建单例模式</h5>
      <ol>
<li>隐藏构造器。这样就可以避免被创建实例。</li>
<li>暴露一个static的方法，该方法用于创建实例。该方法还必须要保证，该类只会产生一个实例。</li>
</ol>
<p>在Java类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员，其中static可以修饰成员变量，方法、初始化块、内部类（接口、枚举），以static修饰的成员就是类成员。类成员属于整个类。而不属于单个对象。</p>
<p>类变量的生存范围从系统第一次使用该类时开始，直到该类被卸载。几乎等同于该类的生存范围。当类初始化完成后，类变量也被初始化完成。</p>
<p>当通过对象来访问类变量时，系统会在底层转换为通过该类访问类变量。</p>
<p><strong>类成员不能访问实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）。</strong>因此类成员时属于类的，类成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还没初始化的情况，如果允许类成员访问实例变量将会引起大量错误。  </p>

        <h3 id="6-3-2单例（Singleton）类"   >
          <a href="#6-3-2单例（Singleton）类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-3-2单例（Singleton）类" class="headerlink" title="6.3.2单例（Singleton）类"></a>6.3.2单例（Singleton）类</h3>
      <p>如果一个类始终只能创建一个实例，则这个类被称为单例类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//使用一个类变量来缓存曾经创建的实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="comment">//隐藏构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="comment">//提供一个静态方法，用于返回Singleton实例</span></span><br><span class="line">	<span class="comment">//该方法可以加入自定义控制，保证值产生一个Singleton对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>)<span class="comment">//判断是否已经创建了实例 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//创建一个对象，并将其缓存起来。</span></span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">		<span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">		<span class="comment">//输出ture</span></span><br><span class="line">		System.out.println(s1 ==s2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过getInstance方法提供的自定义控制（这也是封装的又是；不允许自由访问类成员变量和实现细节，而正式通过方法来控制合适的暴露），保证类只能产生一个实例，所以在类的main方法种，看到两次产生的对象实际是同一对象.</p>

        <h2 id="6-4-final修饰符"   >
          <a href="#6-4-final修饰符" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-final修饰符" class="headerlink" title="6.4   final修饰符"></a>6.4   final修饰符</h2>
      <p>final关键字可用于修饰类、变量和方法，用于表示他修饰的类、方法和变量不可改变。final与abstract互斥：永远不能同时出现。</p>
<p>final修饰的变量不可被改变，一旦获得了初始值，该final变量的值就不能被重新赋值。（必须赋值而且只能且只能赋值一次）</p>

        <h3 id="6-4-1-final成员变量"   >
          <a href="#6-4-1-final成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-1-final成员变量" class="headerlink" title="6.4.1 final成员变量"></a>6.4.1 final成员变量</h3>
      <p>普通的成员变量：程序员可以不显式的指定初始值，系统会为之分配初始值。初始值分配规则与数组与数组元素的分配规则完全相同。</p>
<p><strong>final修饰的成员变量必须由程序员显式地指定初始值。</strong></p>
<p>final修饰地类变量、实例变量能指定初始值的地方如下：</p>
<ul>
<li>类变量：必须在静态初始化块中指定初始值或声明该类变量是指定的初始值，而且只能在两个地方的其中之一指定。</li>
<li>实例变量：必须在非静态初始化块、声明该实例变量或每个构造器中指定初始值，而且只能在三个地方的其中之一指定（三个位置的本质都是构造器）。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVariableTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义成员变量时指定默认值，合法</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//	下面变量将在构造器或初始化块中指定初始值</span></span><br><span class="line">	<span class="keyword">final</span> String str;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> d;</span><br><span class="line"><span class="comment">//	final char ch;</span></span><br><span class="line"><span class="comment">//	初始化块，可对没有指定默认值的实例变量指定初始值</span></span><br><span class="line">	&#123;</span><br><span class="line">		str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		a = 9;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	静态初始化块，可对没有指定默认值的类变量指定初始值</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		d = <span class="number">5.6</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	构造器，可对既没有指定默认值，又没有在初始化块中指定初始值的实例变量指定初始值</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FinalVariableTest</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		如果初始化块中已经对str指定了初始值</span></span><br><span class="line"><span class="comment">//		那么在构造器中不能对final变量重新赋值，下面赋值语句非法</span></span><br><span class="line"><span class="comment">//		str = &quot;World&quot;;</span></span><br><span class="line">		c = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//		ch = &#x27;A&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeFinal</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		普通方法不能为final修饰的成员变量赋值</span></span><br><span class="line"><span class="comment">//		d = 5.1;</span></span><br><span class="line"><span class="comment">//		不能在普通方法中为final成员变量指定初始值</span></span><br><span class="line"><span class="comment">//		ch = &#x27;S&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	public void shuchu()</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		System.out.println(ch);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">FinalVariableTest</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalVariableTest</span>();</span><br><span class="line"><span class="comment">//		v.shuchu();</span></span><br><span class="line">		System.out.println(v.a);</span><br><span class="line">		System.out.println(v.c);</span><br><span class="line">		System.out.println(v.d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>与普通成员变量不同的是，final成员变量（包括实例变量和类变量）必须由程序员显式初始化。 </p>
<p>如果打算在构造器或初始化块中对final成员变量进行初始化，则不要在初始化之前访问final成员变量；否则由于Java允许通过方法访问final成员变量，此时将看到系统将final成员变量默认初始化为0（或’\u0000’、false或null）的情况。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalErrorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		系统不会对final成员变量进行默认初始化</span></span><br><span class="line">        <span class="comment">//java不允许在final成员变量显式初始化之前直接调用该成员变量，所以代码错误。</span></span><br><span class="line"><span class="comment">//		System.out.println(age);</span></span><br><span class="line"><span class="comment">//		因为Java允许方法来访问final修饰的成员变量，</span></span><br><span class="line"><span class="comment">//		此时系统将默认初始化，将输出0</span></span><br><span class="line">		printAge();</span><br><span class="line">		age = <span class="number">6</span>;</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">FinalErrorTest</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="final局部变量"   >
          <a href="#final局部变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h3>
      <p>&#x3D;&#x3D;系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalLocalVariableTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		不能对final修饰的形参赋值</span></span><br><span class="line"><span class="comment">//		a = 3;</span></span><br><span class="line">		System.out.println(<span class="string">&quot;成功对a进行了初始化，且a的值为：&quot;</span></span><br><span class="line">				+ a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FinalLocalVariableTest</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">//		str = &quot;Java&quot;;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">double</span> d;</span><br><span class="line">		d = <span class="number">5.6</span>;</span><br><span class="line"><span class="comment">//		d = 3.4;</span></span><br><span class="line">		<span class="type">FinalLocalVariableTest</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalLocalVariableTest</span>();</span><br><span class="line">		s.test(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因为形参在调用方法时，由系统根据传入的参数进行初始化，所以使用final修饰的形参不能被赋值。</p>

        <h3 id="6-4-3-final修饰基本类型变量和引用类型变量的区别"   >
          <a href="#6-4-3-final修饰基本类型变量和引用类型变量的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-3-final修饰基本类型变量和引用类型变量的区别" class="headerlink" title="6.4.3 final修饰基本类型变量和引用类型变量的区别"></a>6.4.3 final修饰基本类型变量和引用类型变量的区别</h3>
      <p>当使用final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变，<strong>但对于引用类型变量而言，他保存的仅仅是一个引用，final只保证这个引用类型所引用的地址不变，即一直引用同一个对象，但这个对象完全可以发生改变。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Personq</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Personq</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="comment">//有参数的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Personq</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReferenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		final修饰数组变量，iArr时一个引用变量</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span>[] iArr = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		System.out.println(Arrays.toString(iArr));</span><br><span class="line"><span class="comment">//		对数组元素进行排序，合法</span></span><br><span class="line">		Arrays.sort(iArr);</span><br><span class="line">		System.out.println(Arrays.toString(iArr));</span><br><span class="line"><span class="comment">//		对数组元素进行赋值，合法</span></span><br><span class="line">		iArr[<span class="number">2</span>] = -<span class="number">8</span>;</span><br><span class="line">         iArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		System.out.println(Arrays.toString(iArr));</span><br><span class="line"><span class="comment">//		下面语句对iArr重新赋值，非法</span></span><br><span class="line"><span class="comment">//		iArr = &#123;2,6,4,8&#125;;</span></span><br><span class="line"><span class="comment">//		final 修饰Person变量，p时一个引用变量</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Personq</span>(<span class="number">45</span>);</span><br><span class="line"><span class="comment">//		改变Person对象的age实例变量，合法</span></span><br><span class="line">		p.setAge(<span class="number">23</span>);</span><br><span class="line">		System.out.println(p.getAge());</span><br><span class="line"><span class="comment">//		下面语句对p重新赋值，非法</span></span><br><span class="line"><span class="comment">//		p = null;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上可得，使用final修饰的引用类型变量不能被重新赋值，但可以改变引用类型变量所引用对象的内容。例如iArr变量所引用的数组对象，final修饰后的iArr变量不能被重新赋值，但是iArr所引用的数组元素可以被改变。相似的有，p变量不能被重新赋值，但是p变量所引用Person对象的成员变量的值可以被改变。</p>

        <h3 id="6-44-可执行“宏替换”的final变量"   >
          <a href="#6-44-可执行“宏替换”的final变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-44-可执行“宏替换”的final变量" class="headerlink" title="6.44 可执行“宏替换”的final变量"></a>6.44 可执行“宏替换”的final变量</h3>
      <p>对于final变量来说，不管他是类变量、实例变量，还是局部变量，只要该变量满足三个条件，这个final变量就不再是一个变量，而是相当于一个直接量。</p>
<ul>
<li>使用final修饰符修饰。</li>
<li>在定义该final变量时指定了初始值。</li>
<li>该初始值可以在编译时就被确定下来。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalLocalTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对于此程序，当程序执行System.out.println(a);，实际转换为执行System.out.println(5);这就是final修饰符的一个重要用途–<strong>宏定义</strong>，编译器会在程序中所有用到该变量的地方直接替换成该变量的值。</p>
<p>被赋值的可以是直接量，可以时算数表达式或字符串连接运算，没有访问普通变量，调用方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReplaceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span> + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.2</span> / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//字符串连接运算</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>+<span class="string">&quot;Java&quot;</span>;<span class="comment">//编译阶段就会计算结果</span></span><br><span class="line">        <span class="comment">//字符串连接运算，隐式类型（将数值转字符串）</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java讲义：&quot;</span>+<span class="number">99.0</span>;</span><br><span class="line">		<span class="comment">//调用了方法，无法在编译时被确定下来，无法当作宏变量处理</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java讲义：&quot;</span>+String.valueOf(<span class="number">99.0</span>);</span><br><span class="line">		System.out.println(d == <span class="string">&quot;疯狂Java讲义：99.0&quot;</span>);<span class="comment">//因为java常量池，所以返true。</span></span><br><span class="line">		System.out.println(d2 == <span class="string">&quot;疯狂Java讲义：99.0&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringJoinTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java&quot;</span>;</span><br><span class="line">		<span class="comment">//两个字符串直接量连接，编译时即可确定类型</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span> + <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		System.out.println(s1 == s2);<span class="comment">//ture</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//两个普通变量的运算，编译器不会执行“宏替换”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str3</span> <span class="operator">=</span> str1 + str2;<span class="comment">// str1 /str2是变量，要等到运算的时候才能结算结果，无法使用池中的字符串</span></span><br><span class="line">		System.out.println(s1 == str3);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="type">var</span> <span class="variable">str5</span> <span class="operator">=</span> str3 + str4;	<span class="comment">// str3 /str4会消失，相当于System.out.println(str3 + str4)</span></span><br><span class="line">        System.out.println(str5 == str2)</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>str1和str2只是两个普通变量，编译器不会执行“宏替换”，因此编译器无法在编译时确定s3的值，这是可以让编译器对两个变量执行“宏替换”（使用final修饰）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myself</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;张智超&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1+<span class="string">&quot;为&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2+<span class="string">&quot;卡宴&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3+<span class="string">&quot;拼搏的&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4+<span class="string">&quot;第一天&quot;</span>;</span><br><span class="line">    System.out.println(s5);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;张智超为卡宴拼搏的第一天&quot;</span>);<span class="comment">//与上面的输出结果完全相同，上面的更加简单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="6-4-5-final方法"   >
          <a href="#6-4-5-final方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-5-final方法" class="headerlink" title="6.4.5 final方法"></a>6.4.5 final方法</h3>
      <p>final修饰的方法不可被重写，如果出于某些原因不希望子类重写父类的某个方法，则可以使用final修饰该方法。——该方法可以被重载，也可以被子类调用！</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sub</span> <span class="keyword">extends</span> <span class="title class_">FinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//编译会出错，不允许重写test方法</span></span><br><span class="line">	<span class="comment">//public  void test() &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>private修饰的final方法时，因为它仅在当前类可见，其子类无法访问该方法，所以子类无法重写该方法，如果子类出现同名函数，不是重写只是定义了一个新方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateFinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//private已经被隐藏在方法内部</span></span><br><span class="line">    <span class="comment">//子类无法访问该方法，因此也无法重写</span></span><br><span class="line">    <span class="comment">//此处的final无意义</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">PrivateFinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>【备注】：private已经被隐藏在方法，内部子类无法访问该方法，因此也无法重写。<br>                            final修饰的private方法纯属多余！但Java允许。</p>
<p>final修饰的方法仅仅时不能被重写，并不是不能被重载。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalOverload</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//final修饰的方法不可以重写，但可以重载哦！</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String arg)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-4-6-final类"   >
          <a href="#6-4-6-final类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-6-final类" class="headerlink" title="6.4.6 final类"></a>6.4.6 final类</h3>
      <p>final修饰的类不可以派生子类。例如java.lang.Math类String、System。</p>
<p>当子类继承父类时，将可以访问到父类内部的内部数据，并可以通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素，可以用final修饰这个类，使该类无法继承。</p>

        <h3 id="6-4-7-不可变类"   >
          <a href="#6-4-7-不可变类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-7-不可变类" class="headerlink" title="6.4.7 不可变类"></a>6.4.7 不可变类</h3>
      <p>不可变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。Java提供的8个包装类和java.lang.String类都是不可变类，当创建他们的实例后，其实例的实例变量不可改变。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> Double.valueOf(<span class="number">6.5</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>如果需要创建自定义的不可变类，可遵守如下规则：</p>
<ul>
<li>使用private和final修饰符来修饰该类的成员变量。</li>
<li>提供带参数的构造器（或返回该实例的类方法），用于根据传入参数来初始化类里的成员变量。</li>
<li>仅为该类的成员变量提供getter方法，不要为该类的成员提供setter方法，因为普通方法无法修改final修饰的成员变量。</li>
<li>如果有必要，重写Object类的hashCode()和equal()方法。equal()方法根据关键成员变量来作为两个对象是否相等的标准，除此之外，还应该保证两个用equal()方法判断为相等对象的hashCode()也相等。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String detail;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String postCode;</span><br><span class="line"><span class="comment">//	定义带参数的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String datail,String postCode)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.detail = datail;</span><br><span class="line">		<span class="built_in">this</span>.postCode = postCode;</span><br><span class="line">	&#125;  </span><br><span class="line"><span class="comment">//	定义两个成员变量的getter方法</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getDetail</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> detail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPostCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> postCode;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写equals方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equlas</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Address.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">ad</span> <span class="operator">=</span> (Address)obj;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.getDetail().equals(ad.getDetail())</span><br><span class="line">					&amp;&amp; <span class="built_in">this</span>.getPostCode().equals(ad.getPostCode()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> detail.hashCode() + postCode.hashCode() * <span class="number">31</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的Address类，当程序创建了Address对象后，同意无法修改该Address对象的detail和postCode实例变量的值。</p>
<p>当使用final修饰引用类型变量时，仅代表这个引用类型变量不可被重新赋值，但引用类型变量所指向的对象依然是可变的。这就产生了一个问题：当创建不可变类时，如果它包含成员变量的类型是可变的，那么其对象的成员变量的值依然是可改变的——这个不可变类其实是失败的。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String firstName;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Name</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Name</span><span class="params">(String firstName,String lastName)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">		<span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> firstName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> lastName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Name name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Name name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Name <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;悟空&quot;</span>,<span class="string">&quot;孙&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Persom</span>(n);</span><br><span class="line">		System.out.println(p.getName().getFirstName());</span><br><span class="line">        <span class="comment">//改变Persom对象的name的firstName值。</span></span><br><span class="line">		n.setFirstName(<span class="string">&quot;八戒&quot;</span>);</span><br><span class="line">		System.out.println(p.getName().getFirstName());</span><br><span class="line">		System.out.println(n.getLastName()+n.getFirstName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>当不可变类的实例变量引用了可变类的对象时，会被破坏设计不可变类的初衷。</p>
<p>因此对Persom类进行部分修改：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Persom</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Name name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Persom</span><span class="params">(Name name)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		设置name实例变量为临时创建的Name对象，该对象的getFirstName和gerLastName</span></span><br><span class="line"><span class="comment">//		与传入的name参数的firstName和lastName相同</span></span><br><span class="line">		<span class="built_in">this</span>.name = <span class="keyword">new</span> <span class="title class_">Name</span>(name.getFirstName(),name.getLastName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Name <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		返回一个匿名对象，该对象的firstName和lastName</span></span><br><span class="line"><span class="comment">//		与该对象里的name的firstName和lastName相同</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Name</span>(name.getFirstName(),name.getLastName());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

<p>Persom类改写了设置name实例变量的方法，也改写了name的getter方法。当程序向Persom构造器里传入一个Name对象时，该构造器创建Persom对象时并不是直接利用已有的Name对象（利用已有的Name对象有风险，因为这个已有的Name对象是可变的，如果程序改变了这个Name对象，将会导致Persom对象也发生变化），而是重新创建了一个Name对象来赋给Persom对象的name实例变量。当Persom对象返回name变量时，他并没有直接把name实例变量返回，直接返回name实例变量的值也可能导致它所引用的Name对象被修改。</p>
<p>所以，创建不可变类要注意其引用类型的成员变量的类是否可变。</p>

        <h3 id="6-4-8-缓存实例的不可变类"   >
          <a href="#6-4-8-缓存实例的不可变类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-8-缓存实例的不可变类" class="headerlink" title="6.4.8 缓存实例的不可变类"></a>6.4.8 缓存实例的不可变类</h3>
      <p>如果程序经常使用相同的不可变类实例，则应该考虑缓存这种不可变类实例。</p>

        <h4 id="使用一个数组来作为缓存池，看不懂"   >
          <a href="#使用一个数组来作为缓存池，看不懂" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用一个数组来作为缓存池，看不懂" class="headerlink" title="使用一个数组来作为缓存池，看不懂"></a>使用一个数组来作为缓存池，看不懂</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheImmutale</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//使用数组来缓存已有的实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CacheImmutale[] cache = <span class="keyword">new</span> <span class="title class_">CacheImmutale</span>[MAX_SIZE];</span><br><span class="line"><span class="comment">//	记录缓存实例在缓存中的位置，cache[pos - 1]是最新缓存实例。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">CacheImmutale</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> CacheImmutale <span class="title function_">valueOf</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//遍历已缓存的对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; MAX_SIZE;i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			如果已有相同实例，则直接返回该缓存的实例</span></span><br><span class="line">			<span class="keyword">if</span>(cache[i] != <span class="literal">null</span></span><br><span class="line">					&amp;&amp; cache[i].getName().equals(name))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> cache[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果缓存池已满</span></span><br><span class="line">		<span class="keyword">if</span>(pos == MAX_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把缓存的第一个对象覆盖，即把刚刚生成的对象放在缓存池的最开始位置</span></span><br><span class="line">				cache[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">CacheImmutale</span>(name);</span><br><span class="line">				<span class="comment">//把pos设为1</span></span><br><span class="line">				pos = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把新创建的对象缓存起来，pos加1</span></span><br><span class="line">			cache[pos++] = <span class="keyword">new</span> <span class="title class_">CacheImmutale</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cache[pos - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == CacheImmutale.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">ci</span> <span class="operator">=</span> (CacheImmutale)obj;</span><br><span class="line">			<span class="keyword">return</span> name.equals(ci.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheImmutaleTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c1</span> <span class="operator">=</span> CacheImmutale.valueOf(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">c2</span> <span class="operator">=</span> CacheImmutale.valueOf(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		System.out.println(c1 == c2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>CacheImmutale类使用一个数组来缓存该类的对象，这个数组长度为MAX_SIZE，即该类共可以缓存MAX_SIZE个CacheImmutale对象。当缓存池已满时，采用“先进先出（FIFO）”规则来决定哪个对象将被移出缓存池。</p>
<p>CacheImmutale类能控制系统生成CacheImmutale对象的个数，需要程序使用该类的valueOf()方法来得到其对象，而且程序使用private修饰符来隐藏该类的构造器，因此程序只能通过该类提供的valueOf()方法来获得实例。</p>
<p>Integer类构造器和valueOf方法存在的差异：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerCacheTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		生成新的Integer对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">6</span>);</span><br><span class="line">		<span class="comment">//生成新的并缓存该对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//		直接从缓存池中取出 </span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in3</span> <span class="operator">=</span> Integer.valueOf(<span class="number">6</span>);</span><br><span class="line">		System.out.println(in1 == in2);</span><br><span class="line">		System.out.println(in2 == in3);</span><br><span class="line"><span class="comment">//		由于Integer只缓存-128~127之间的值因此200对应的Integer对象没有缓存</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in4</span> <span class="operator">=</span> Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">in5</span> <span class="operator">=</span> Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		System.out.println(in4 == in5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="6-5抽象类"   >
          <a href="#6-5抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-5抽象类" class="headerlink" title="6.5抽象类"></a>6.5抽象类</h2>
      <p>抽象类（有得有失）：抽象类可以有抽象方法，但不可以创建对象</p>
<p>抽象类的主要作用：派生子类！	子类构造器一定要调用构造器一次，因此抽象类必须有构造器。这就是final和abstract互斥的原因。</p>
<p>抽象方法：只有方法签名，没有方法体的方法</p>
<p>子类要么重写父类中的抽象方法，要么子类也只能是抽象的（如果子类没有重写父类的抽象方法，那么就说明子类继承得到了父类）</p>

        <h3 id="6-5-1抽象方法和抽象类"   >
          <a href="#6-5-1抽象方法和抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-5-1抽象方法和抽象类" class="headerlink" title="6.5.1抽象方法和抽象类"></a>6.5.1抽象方法和抽象类</h3>
      <p>有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。</p>
<ul>
<li><p>抽象方法和抽象类必须使用abstract修饰符修饰，抽象方法不能有方法体。</p>
</li>
<li><p>抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。</p>
</li>
<li><p>抽象类可以包含成员变量，方法，构造器，初始化块，内部类。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</p>
</li>
<li><p>含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含）只能被定义成抽象类。</p>
</li>
</ul>
<p>总而言之，抽象类有得有失，抽象类可以包含抽象方法；抽象类不能创建实例。</p>
<p>定义抽象方法的方法：在普通方法上加上abstract修饰，并把方法体去掉。</p>
<p>定义抽象类的方法：在普通类上加上abstract修饰。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行Shape的初始化块·····&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="comment">//定义一个计算周长的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calPerimeter</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//定义一个返回形状的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getType</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//定义Shape的构造器，该构造器并不是用于创建Shape对象</span></span><br><span class="line"><span class="comment">//	而是用于子类调用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行Shape的构造器·····&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span></span><br><span class="line">	&#123;</span><br><span class="line">			<span class="built_in">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Shape类里包含了两个抽象方法：calPerimeter()和getType()，所以Shape类只能被定义成抽象类，Shape类里既包含了初始化块，也包含了构造器，这些都不是在创建Shape对象时被调用的，而是在创建其子类的实例时被调用的。</p>
<p>&#x3D;&#x3D;抽象类不能用于创建实例，只能当作父类被其他子类继承。&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> a;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> b;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Triangle</span><span class="params">(String color, <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">super</span>(color);</span><br><span class="line">		<span class="built_in">this</span>.setSides(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSides</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a &gt;= b + c || b &gt;= a + c || c &gt;= a + b)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;三角形两边之和必须大于第三边&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.a = a;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">		<span class="built_in">this</span>.c = c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	重写Shape类的计算周长的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calPerimeter</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b + c;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写Shape类的返回形状的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;三角形&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>普通类继承抽象类，普通类中必须实现抽象类中的抽象方法。</strong></p>
<p>上面的Triangle类继承了Shape抽象类，并实现了Shape的两个抽象方法，是一个普通类，因此可以创建Triangle类的实例，可以让Shape类型的引用变量指向Triangle对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(String color,<span class="type">double</span> radius)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">super</span>(color);</span><br><span class="line">		<span class="built_in">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写Shape类的计算周长的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calPerimeter</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>*Math.PI*radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> getColor() + <span class="string">&quot;圆形&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Shape</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="string">&quot;黑色&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">		<span class="type">Shape</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="string">&quot;黄色&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//		输出形状和周长。</span></span><br><span class="line">		System.out.println(s1.getType());</span><br><span class="line">		System.out.println(s1.calPerimeter());</span><br><span class="line">		System.out.println(s2.getType());</span><br><span class="line">		System.out.println(s2.calPerimeter());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">执行Shape的初始化块·····         //参考5.9.3类初始化块。p163</span></span><br><span class="line"><span class="comment">执行Shape的构造器·····</span></span><br><span class="line"><span class="comment">执行Shape的初始化块·····</span></span><br><span class="line"><span class="comment">执行Shape的构造器·····</span></span><br><span class="line"><span class="comment">三角形</span></span><br><span class="line"><span class="comment">12.0</span></span><br><span class="line"><span class="comment">黄色圆形</span></span><br><span class="line"><span class="comment">18.84955592153876</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>上面main()方法中定义了两个Shape类型的引用变量，它们分别指向Triangle对象和Circle对象，由于在Shape类中定义了calPerimeter()方法和getType()方法，所以程序可以直接调用s1变量和s2变量的calPerimeter()方法和getType()方法，无需强制转换为子类类型。</p>
<p>利用抽象类和抽象方法的优势，可以更好地发挥多态的优势，使得程序更加灵活。</p>
<p>当使用abstract修饰类时，表明这个类智能被继承；当使用abstract需要事故方法时，表明这个方法须由自雷实现（即重写）。而fianl修饰的类不能被继承，final修饰的方法不能被重写，因此final和abstract永远不能同时使用。</p>
<p>abstract只能修饰类和方法，不能修饰成员变量、局部变量和构造器，抽象类里定义的构造器只能是普通构造器。</p>

        <h3 id="6-5-2抽象类的作用"   >
          <a href="#6-5-2抽象类的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-5-2抽象类的作用" class="headerlink" title="6.5.2抽象类的作用"></a>6.5.2抽象类的作用</h3>
      <p>&#x3D;&#x3D;抽象类的体现就是一种模板模式的设计&#x3D;&#x3D;，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展，改造，但子类总体上会大致保留抽象类的行为方式，例如上节提到三个类。下面在介绍一个模板模式的范例，这个范例的抽象父类中，父类的普通方法依赖于一个普通方法，而子类方法则推迟到子类中提供实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SpeedMeter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	转速</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> turnRate;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SpeedMeter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">//	把计算车轮周长的方法定义成抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calGirth</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTurnRate</span><span class="params">(<span class="type">double</span> turnRate)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.turnRate = turnRate;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义计算速度的通用方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> calGirth()*turnRate;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>定义了一个SpeedMeter类（车速表）,该表中定义了一个getSpeed()方法，该方法用于返回当前车速，getSpeed()方法依赖与calGirth()方法的返回值，对于一个抽象的SpeedMeter类而言，它无法确定车轮的周长，因此calGirth()方法必须推迟到其子类中实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarSpeedMeter</span> <span class="keyword">extends</span> <span class="title class_">SpeedMeter</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CarSpeedMeter</span><span class="params">(<span class="type">double</span> radius)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calGirth</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> radius * <span class="number">2</span> * Math.PI;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">csm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarSpeedMeter</span>(<span class="number">0.34</span>);</span><br><span class="line">		csm.setTurnRate(<span class="number">15</span>);</span><br><span class="line">		System.out.println(csm.getSpeed());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>SpeedMeter类里提供了速度表的通用算法，但一些具体的实现细节则推迟到其子类CarSpeedMeter类中实现。这也是一种典型的模板模式。</p>

        <h2 id="6-6-Java-9改进的接口"   >
          <a href="#6-6-Java-9改进的接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-Java-9改进的接口" class="headerlink" title="6.6  Java 9改进的接口"></a>6.6  Java 9改进的接口</h2>
      <p>抽象类是从多个类中抽象出来的模板，如果将这种抽象进行得更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（interface）。Java 9对接口进行了改进，允许在接口中定义默认方法和类方法，默认方法和类方法都可以提供方法实现，Java 9为接口增加了一种私有方法，私有方法也可以提供方法实现。</p>

        <h3 id="6-6-1-接口的概念"   >
          <a href="#6-6-1-接口的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-1-接口的概念" class="headerlink" title="6.6.1 接口的概念"></a>6.6.1 接口的概念</h3>
      <p>![](C:\Program Files\Typora\image\P10319-124747.jpg)</p>
<p>同一个类的内部状态数据、各种方法的实现细节完全相同，类是一种具体实现体，而接口定义了一种规范，接口定义了某一批类所需要遵守的规范，接口u不关心内部状态数据，也不关心这些类里方法的实现细节，他只规定这批类里必须提供某些方法，提供这些方法的类就课满足满足实际需求。</p>
<p>可见，接口是从多个相似类中抽象出来的规范，接口不提供任何实现，接口体现的是规范和实现分离的设计学。</p>
<p>让规范和实现风力正是接口的好处，让软件系统的各组件之间面向对象接口耦合，是一种松耦合的设计，软件系统的各模块之间之间也应该采用这种面向接口的耦合，从而尽量降低各模块之间的耦合，为系统提供更好的可拓展性和维护性。</p>

        <h3 id="6-6-2Java-9中接口的定义"   >
          <a href="#6-6-2Java-9中接口的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-2Java-9中接口的定义" class="headerlink" title="6.6.2	Java 9中接口的定义"></a>6.6.2	Java 9中接口的定义</h3>
      <p>与定义类不同，定义接口不再使用class关键字，而是使用<strong>interface关键字</strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 externds 父接口<span class="number">1</span>,父接口<span class="number">2</span>,···</span><br><span class="line">&#123;</span><br><span class="line">	零到多个常量定义；</span><br><span class="line">	零到多个抽象方法定义；</span><br><span class="line">	零到多个内部类、接口、枚举定义；</span><br><span class="line">	零到多个私有方法、默认方法或类方法定义；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>修饰符可以是public，也可以省略，省略后则默认为采用包权限访问控制符，即默认采用包权限访问控制符，即只有在相同结构下才可以访问该接口。</li>
<li>从语法角度来看，接口名为合法的标识符即可，从可读性来看，可加形容词，每个单词的首字母大写。</li>
<li>一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</li>
</ul>
<p>接口中包含<strong>成员变量</strong>（只能是静态常量），<strong>方法</strong>（只能是抽象实例方法、类方法、默认方法或私有方法），<strong>内部类</strong>（包含内部接口、枚举）。不包含构造器和初始化块。权限全部为public。</p>
<p>Java 9为接口增加了一种新的<strong>私有方法</strong>，其实私有方法的主要作用就是做为工具方法，为接口中的默认方法或类方法提供支持。私有方法可以拥有方法体，私有方法既可以是类方法（用static修饰），也可以是实例方法。</p>
<p>对于定义静态常量而言，系统会自动添加public static final修饰符，而且接口里没有构造器和初始化块，所以静态常量需要在定义时就指定默认值。</p>
<p>接口中定义的方法只能是抽象方法，类方法、默认方法（实例方法）或私有方法；因此如果不是定义默认方法、类方法或私有方法，系统将自动为普通方法增加abstract修饰符；定义接口里的普通方法时，不管是否使用public abstract修饰符，接口里的普通方法总是使用public abstract来修饰。接口里的普通方法不能有方法实现（方法体），但类方法，私有方法、默认方法都必须有方法体。（<strong>也就是说，无普通方法，系统会自动转换为抽象方法，而且抽象方法本身就不可定义方法体。</strong>）</p>
<p>总结：</p>
<p>​	接口里定义内部类、内部接口、内部枚举，默认采用public static 两个修饰符。</p>
<p>​	接口里定义普通方法默认使用public abstract修饰符，转换为抽象方法。</p>
<p>​	接口里定义静态常量默认使用public static final修饰符，并要定义时指定初始值。</p>
<p>​	接口里定义默认方法（实例方法）使用 public default修饰。</p>
<p>​	接口里定义类方法用public static，系统会自动添加public。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Output</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	接口里定义的成员变量只能是常量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">MAX_CACHE_LINE</span> <span class="operator">=</span> <span class="number">50</span>;  </span><br><span class="line">    <span class="comment">//等价于 public static final int MAX_CACHE_LINE = 50; </span></span><br><span class="line"><span class="comment">//	接口里定义的普通方法只能是public的抽象方法</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//等价与 public abstract void out();</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">getDate</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="comment">// 等价与 public abstract void getDate(String msg);</span></span><br><span class="line">    <span class="comment">//因为是抽象方法，所以不能有方法体。</span></span><br><span class="line"><span class="comment">//	在接口中定义默认方法，需要使用default修饰</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... msgs)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> msg:msgs)  <span class="comment">//看不懂</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	在接口中定义默认方法，需要使用default修饰</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;默认的test()方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	在接口中定义类方法，需要使用static修饰</span></span><br><span class="line">	<span class="keyword">static</span> String <span class="title function_">staticTest</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;接口里的类方法&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义私有方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;foo私有方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义私有静态方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bar私有静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​	接口里定义默认方法（实例方法）使用 public default修饰。由于不能使用static,所以不能直接使用接口来调用默认方法，需要使用接口的实现类的实例来调用这些默认方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> yeeku;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutoutFieldTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		访问另一个包中的Output接口的常量</span></span><br><span class="line">		System.out.println(lee.Output.MAX_CACHE_LINE);</span><br><span class="line"><span class="comment">//		下面编译将引发“为final变量赋值”编译异常</span></span><br><span class="line"><span class="comment">//		lee.Output.MAX_CACHE_LINE = 20;</span></span><br><span class="line"><span class="comment">//		使用接口调用类方法</span></span><br><span class="line">		System.out.println(lee.Output.staticTest());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从以上代码中可以看出，两个包之间访问，表名该成员变量时public访问权限的，而且可以通过接口访问成员变量，表名这个成员变量是一个类变量。</p>

        <h3 id="6-6-3接口的继承"   >
          <a href="#6-6-3接口的继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-3接口的继承" class="headerlink" title="6.6.3接口的继承"></a>6.6.3接口的继承</h3>
      <p>&#x3D;&#x3D;接口的继承与类的继承不同的是，接口完全支持多继承，即一个接口可以有多个直接父接口。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;相似的是，子接口继承某个父接口，将会得到父接口里定义的所有抽象方法、常量。&#x3D;&#x3D;</p>
<p>一个接口继承多个父接口时，多个父接口排在extends关键词之后，多个父接口之间以 . 隔开。</p>

        <h5 id="x3D-x3D-以下代码中纯在自己的很多错误-x3D-x3D"   >
          <a href="#x3D-x3D-以下代码中纯在自己的很多错误-x3D-x3D" class="heading-link"><i class="fas fa-link"></i></a><a href="#x3D-x3D-以下代码中纯在自己的很多错误-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;以下代码中纯在自己的很多错误&#x3D;&#x3D;"></a>&#x3D;&#x3D;以下代码中纯在自己的很多错误&#x3D;&#x3D;</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfanceA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义了一个静态变量和抽象方法</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">PROP_A</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//public static final</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span>;<span class="comment">//public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfanceB</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">PROP_B</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testD</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;在接口中定义除抽象方法的其他方法外都需要定义方法体。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceC</span> <span class="keyword">extends</span> <span class="title class_">InterfanceA</span>,InterfanceB</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">PROP_C</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">testC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceExtends</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(InterfaceC.PROP_A);</span><br><span class="line">		System.out.println(InterfaceC.PROP_B);</span><br><span class="line">		System.out.println(InterfaceC.PROP_C);</span><br><span class="line"><span class="comment">//		下面编译将会引起“没有为类型 InterfaceC 定义方法 testD”的错误</span></span><br><span class="line"><span class="comment">//		原因是接口在继承中只继承父类的抽象方法和常量，不继承类方法等···</span></span><br><span class="line"><span class="comment">//		System.out.println(InterfaceC.testD());</span></span><br><span class="line"><span class="comment">//		下面编译将会引起“ 类型 PrintStream 中的方法 println（boolean）对于参数（void）不适用”的错误</span></span><br><span class="line"><span class="comment">//		不能够输出方法，只能够调用方法。</span></span><br><span class="line"><span class="comment">//		System.out.println(InterfanceB.testD());</span></span><br><span class="line">		InterfanceB.testD();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-6-4使用接口"   >
          <a href="#6-6-4使用接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-4使用接口" class="headerlink" title="6.6.4使用接口"></a>6.6.4使用接口</h3>
      <p>接口不能用于创建实例，但接口可以用于声明引用类型变量。当使用接口来声明引用类型变量时，这个引用类型变量必须引用到其他现实类的对象。除此之外，接口的主要用途就是被实现类实现。归纳起来，接口主要有如下用途：</p>
<ul>
<li>定义变量，也可用于强制类型转换。</li>
<li>调用接口中定义的常量。</li>
<li>被其他类实现。</li>
</ul>
<p>一个类可以实现一个或多个接口，继承使用extends关键字，实现则用&#x3D;&#x3D;implements关键字&#x3D;&#x3D;。因为一个类可以实现多个接口，这也就是Java为单继承灵活性不足所做的补充。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类 implements 接口<span class="number">1</span>,接口<span class="number">2</span>···</span><br><span class="line">&#123;</span><br><span class="line">	类体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>实现接口与继承父类相似，一样可以获得所实现接口里定义的常量（成员变量）和方法（抽象方法，私有方法（public default修饰））。</p>
<p>一个类可以继承一个父类，并同时实现多个接口，implements部分必须放在extends部分之后。</p>
<p>一个类实现了一个或多个接口后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</p>
<p>一个类实现一个接口可以看成一个类继承了一个彻底抽象的类。下面看一个实现接口的类：</p>
<p>Printer.java</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">getProduceTime</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Output</span>,Product</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String[] printData </span><br><span class="line">		= <span class="keyword">new</span> <span class="title class_">String</span>[MAX_CACHE_LINE];</span><br><span class="line"><span class="comment">//	用以记录当前需要打印的作业数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">dataNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	实现实现 lee.Output.out()</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		只要还有作业，就继续打印</span></span><br><span class="line">		<span class="keyword">while</span>(dataNum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;打印机打印：&quot;</span> + printData[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//			把作业队列整体前移一位，并将剩下的作业数减1</span></span><br><span class="line">			System.arraycopy(printData,<span class="number">1</span>,</span><br><span class="line">					printData,<span class="number">0</span>,--dataNum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	实现 lee.Output.getDate</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDate</span><span class="params">(String msg)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dataNum &gt;= MAX_CACHE_LINE)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输出队列已满，添加失败。&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			把答应数据添加到队列里，已保存的数据加1</span></span><br><span class="line">			printData[dataNum++] = msg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	实现getProduceTime</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getProduceTime</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">45</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个Printer对象，当成Output使用</span></span><br><span class="line">		<span class="type">Output</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">		o.getDate(<span class="string">&quot;轻量级Java EE企业级应用实战&quot;</span>);</span><br><span class="line">		o.getDate(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		o.out();</span><br><span class="line"><span class="comment">//		调用Output接口中定义的默认方法</span></span><br><span class="line">		o.print(<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;猪八戒&quot;</span>,<span class="string">&quot;白骨精&quot;</span>);</span><br><span class="line">		o.test();</span><br><span class="line"><span class="comment">//		创建一个Printer对象，当成Product使用</span></span><br><span class="line">		<span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">		System.out.println(p.getProduceTime());</span><br><span class="line"><span class="comment">//		所有接口类型的引用变量都可以直接赋给Object类型变量</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Printer对象实现了Output接口和Product接口，因此Printer对象即可直接赋给Output变量，也可直接赋给Product变量。仿佛Printer类既是Output类的子类，也是Product类型子类，这就是Java提供的模拟多继承。</p>
<p>实现接口方法时，必须使用public访问控制修饰符，因为接口里的方法都是public的，而子类（相当于实现类）重写父类方法时访问权限只能更大或者相等，所以实现类实现接口里的方法时只能能使用public修饰。</p>
<p>接口不能显式的继承任何类，但所有接口类型的引用变量都可以直接赋给Object类型的引用变量。所以在上面程序中可以把Product类型的变量直接赋给Object类型变量，这就是利用向上转型实现的，因为编译器知道任何Java对象都必须时Object或其他子类的实例，Product类型的对象也不例外（它必须时Product接口实现类的对象，该实现类肯定时Object的显式或隐式子类）。</p>

        <h3 id="6-6-5接口和抽象类"   >
          <a href="#6-6-5接口和抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-5接口和抽象类" class="headerlink" title="6.6.5接口和抽象类"></a>6.6.5接口和抽象类</h3>
      <p>相似特征：</p>
<ul>
<li>接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>接口：</p>
<p>对于实现者而言</p>
<p>​	接口规定了实现者必须向外提供服务（以方法的形式来提供）</p>
<p>对于调用者而言</p>
<p>​	接口规定了调用者可以调用那些服务，以及如何调用这些服务（就是如何来调用方法）。</p>
<p>​	当一个程序使用接口时，接口是多个模块间的耦合标准。</p>
<p>​	当多个应用程序之间使用接口时，接口是多个程序之间的通信标准。</p>
<p>接口类似于整个程序的总纲，因此不要随意修改接口，一旦接口被改变，导致系统中大部分类都需要重写。</p>
</li>
<li><p>抽象类：</p>
<p>作为系统中多个子类的父类，所体现的是一种模板式设计。·需要进行进一步的完善。</p>
</li>
</ul>
<p>除此之外，<strong>用法</strong>上纯在如下差别：</p>
<p>①接口里只能包含抽象方法、静态方法、私有方法（类方法）和默认方法，不能为普通方法提供实现；抽象类则完全可以包含普通方法。</p>
<p>②接口里之恶能定义静态常量，不能定义普通常量；抽象类里则既可以定义普通成员变量，也可定义静态常量。</p>
<p>③接口里不包含构造器；抽象类里可以包含构造器，但是不可以用来创建对象，而是让其子类去调用构造器来完成属于抽象类的初始化操作。</p>
<p>④接口里不能包含初始化块，抽象类里可以。</p>
<p>⑤一个类最多只能由一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</p>

        <h3 id="6-6-6面向接口编程"   >
          <a href="#6-6-6面向接口编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-6面向接口编程" class="headerlink" title="6.6.6面向接口编程"></a>6.6.6面向接口编程</h3>
      <p>​	接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好的降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。</p>
<p>基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。下面介绍两种设计模式来示范面向接口编程的优势。</p>

        <h4 id="1-简单工程模式"   >
          <a href="#1-简单工程模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-简单工程模式" class="headerlink" title="1.简单工程模式"></a>1.简单工程模式</h4>
      <p>有一个场景：假设程序中有个Computer类需要组合一个输出设备，现在又两个选择：直接让Computer类组合一个Printer，或则让Computer类组合一个Output，那么到底哪种好呢。</p>
<p>工厂模式建议让Computer类组合一个Output类型的对象，将Computer类与Printer类完全分离。Computer对象实组合的是Printer对象还是BetterPrinter对象，对Computer完全透明。当Printer对象切换到BetterPrinter对象时，系统完全不受影响。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Output out;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(Output out)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.out = out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义一个模拟获取字符串输入的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyIn</span><span class="params">(String msg)</span></span><br><span class="line">	&#123;</span><br><span class="line">		out.getData(msg);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义一个模拟打印的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		out.out();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​	上面的Computer类已经完全与Printer类分离，只是与Output接口耦合。Computer不再负责创建Output对象，系统提供一个Output工厂来负责生成Output对象。这个OutputFactory工厂类代码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> Output <span class="title function_">getOutput</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//创建了一个Printer对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">of</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputFactory</span>();</span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(of.getOutput());</span><br><span class="line">		c.keyIn(<span class="string">&quot;轻量级&quot;</span>);</span><br><span class="line">		c.keyIn(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		c.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在该OutputFactory类中包含了一个getOutput()方法，该方法返回一个Output实现类的实例，该方法负责创建Output实例，具体创建哪一个实现类的对象由该方法决定（具体由该方法的return new Printer()控制，当然也可以增加更复杂的控制逻辑）。如果系统需要将Printer改为BetterPrinter实现类，只需要让BetterPrinter实现Output接口，并实现OutputFacyory类中的getOutput()方法即可。</p>
<p>下面时BetterPrinter实现类的代码，BetterPrinter只是对原有的Printer进行简单修改，以模拟系统重构后的改进。  </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BetterPrinter</span> <span class="keyword">implements</span> <span class="title class_">Output</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String[] printData</span><br><span class="line">		= <span class="keyword">new</span> <span class="title class_">String</span>[MAX_CACHE_LINE * <span class="number">2</span>];</span><br><span class="line"><span class="comment">//	用以记录当前需打印的作业数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">dataNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		只要还有作业，就继续打印</span></span><br><span class="line">		<span class="keyword">while</span> (dataNum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;高速打印机正在打印：&quot;</span> + printData[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//			把作业队列整体前移一位，并将剩下的作业数减1</span></span><br><span class="line">			System.arraycopy(printData, <span class="number">1</span>, printData, <span class="number">0</span>, --dataNum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String msg)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dataNum &gt;= MAX_CACHE_LINE * <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输出队列已满，添加失败&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			把打印数据添加到队列里，已保存数据的数量加1</span></span><br><span class="line">			printData[dataNum++] = msg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的BetterPrinter类也实现了Output接口，因此也可当成Output接口来使用，于是只要把OutputFactory工厂类的getOutput()方法中粗体部分改为如下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BetterPrinter</span>();</span><br></pre></td></tr></table></div></figure>

<p>再次运行OutputFactory.java，**发现系统运行时已经改为BetterPrinter对象,**而不再是原来的Printer对象。</p>
<p>通过这种方法，即可把所有生成的Output对象的逻辑集中在OutputFactory工厂类模式中管理，而所有需要使用Output对象的类只需要与Output接口耦合，而不是具体的实现类耦合。即使系统中有很多类使用了Printer对象，只要OutputFactory类的getOutput()方法生成的Output对象是BetterPrinter对象，则它们全部可以改为这个对象，而所有程序无需修改，只需要修改工厂类的getOutput方法实现即可。</p>

        <h4 id="2-命令模式"   >
          <a href="#2-命令模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-命令模式" class="headerlink" title="2.命令模式"></a>2.命令模式</h4>
      <p> 一个场景：某个方法需要完成某一个行为，但这个行为的具体实现无法确定，必须等到执行改方法时才可以确定。具体点：假设有个方法需要遍历某个数组的数组元素，但无法确定在遍历数组元素时如何处理这些元素，需要在调用该方法时指定具体的某个行为。</p>
<p>对于这样一个需求，必须把“处理行为”作为参数传入该方法，这个“处理行为”用编程来实现就是一段代码可以考虑使用一个Command接口来定义一个方法，用这个方法来封装“处理行为”。下面是该接口的代码。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	接口里定义的process方法用于封装“处理行为”</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>定义了一个process()方法，这个方法用于封装“处理行为”，但这个方法没有方法体——因为现在还无法确定这个处理行为。</p>
<p>下面是需要处理数组的处理类，在这个处理类中包含一个process()方法，这个方法无法确定处理数组的处理行为，所以定义该方法时使用了一个Command参数，这个Command参数负责对数组的处理行为。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target,Command cmd)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> t:target)  <span class="comment">//多态</span></span><br><span class="line">		&#123;</span><br><span class="line">			cmd.process(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过一个Command接口，就实现了让ProcessArray类和具体“处理行为”分离，程序使用Command接口代表了对数组元素的处理行为。Command接口也没有提供真正的处理，只有等到需要调用ProcessArray对象的process()方法时，才真正传入一个Command对象，才正在确定对数组的处理行为。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">		<span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//		第一次处理数组，具体处理行为取决于PrintCommand</span></span><br><span class="line">		pa.process(target, <span class="keyword">new</span> <span class="title class_">PrintCommand</span>());</span><br><span class="line">		System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">		pa.process(target, <span class="keyword">new</span> <span class="title class_">SquareCommand</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;迭代输出目标数组的元素&quot;</span>+element);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span>+element * element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="6-7-内部类"   >
          <a href="#6-7-内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-内部类" class="headerlink" title="6.7 内部类"></a>6.7 内部类</h2>
      <p>大部分的时候，类被定义成一个独立的程序单元，在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就称作内部类（有的地方叫嵌套类），包含内部类的类也被称为外部类（有的地方也叫宿主类）。有以下作用：</p>
<ul>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li>
<li>内部类成员可以直接访问外部类的私有数据，因为内部类被当成外部类成员，同一个类的成员之间可以互相访问，但外部类不能访问内部类的实现细节，例如内部类的成员变量。</li>
<li>匿名内部类适合创建仅需要创建一次使用的类。</li>
</ul>
<p>内部类除需要定义在其他类里面还存在两点不同：</p>
<ul>
<li>内部类可以比外部类多三个修饰符private,protected,static——外部类不可以使用这三个修饰符。</li>
<li>非静态内部类不能拥有静态对象。</li>
</ul>

        <h3 id="6-7-1非静态内部类"   >
          <a href="#6-7-1非静态内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-1非静态内部类" class="headerlink" title="6.7.1非静态内部类"></a>6.7.1非静态内部类</h3>
      <p>大部分的时候，内部类都可以被当作成员内部类定义，而不是作为局部内部类。成员内部类是一种与成员变量、方法、构造器和初始化块相似的类成员；既不内部类和匿名内部类则不是类成员。</p>
<p>成员内部类分为：静态内部类和非静态内部类，内部类一定是放在另一个类的类体部分定义。  </p>
<p>下面程序在Cow类中创建了CowLeg非静态内部类，并在CowLeg类的实例方法中直接访问Cow的private访问权限下的实例方法，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cow</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"><span class="comment">//	外部类的两个重载的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cow</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cow</span><span class="params">(<span class="type">double</span> weight)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义一个非静态内部类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CowLeg</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		非静态内部类的两个实例变量</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">double</span> lenght;</span><br><span class="line">		<span class="keyword">private</span> String color;</span><br><span class="line"><span class="comment">//		非静态内部类的两个重载构造器</span></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">CowLeg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">CowLeg</span><span class="params">(<span class="type">double</span> lenght,String color)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.lenght = lenght;</span><br><span class="line">			<span class="built_in">this</span>.color = color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLenght</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> lenght;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLenght</span><span class="params">(<span class="type">double</span> lenght)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.lenght = lenght;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.color = color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;当前牛腿的颜色是：&quot;</span></span><br><span class="line">					+color + <span class="string">&quot;高：&quot;</span>+lenght);</span><br><span class="line">			System.out.println(<span class="string">&quot;本牛腿所在奶牛重：&quot;</span>+weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CowLeg</span>(<span class="number">1.12</span>,<span class="string">&quot;黑白相间&quot;</span>);</span><br><span class="line">		c1.info();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cow</span>(<span class="number">378.9</span>);</span><br><span class="line">		c2.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>生成两个class文件，内部类的class文件总是以OutClass$InnerClass.class。</p>
<p>在非静态内部类里可以直接访问外部类的private成员，System.out.println(“本牛腿所在奶牛重：”+weight);这行代码就是内部类直接访问外部类的private成员，这是因为在非静态内部类对象里，保存了一个他所寄生的外部类对象的引用（当调用非静态内部类的实例方法时（info()）,必须有一个非静态内部类实例（c1）非静态内部类实例必须寄生在外部类实例里）。</p>
<p>当非静态内部类的方法访问某个变量时，系统优先在该方法内寻找是否存在该名字的局部变量，如果存在就使用该变量，如果不存在就在该方法存在的内部类里查找是否存在该名字的成员变量，如果存在就使用不存在就在该内部类所在的外部类里查找是否存在该名字的成员变量，如果存在就使用，不存在系统将出现编译错误，提示找不到该变量。</p>
<p>因此，如果外部类成员变量、内部类成员变量与内部类里方法的局部变量同名，则可以通过外部类类名.this、this来限定区分。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscernVariable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="string">&quot;外部类的实例变量&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inclass</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">String</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="string">&quot;内部类的实例变量&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">porp</span> <span class="operator">=</span> <span class="string">&quot;局部变量&quot;</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;外部类的实例变量值：&quot;</span></span><br><span class="line">					+DiscernVariable.<span class="built_in">this</span>.prop);</span><br><span class="line">			System.out.println(<span class="string">&quot;内部类的实例变量值：&quot;</span></span><br><span class="line">					+<span class="built_in">this</span>.prop);</span><br><span class="line">			System.out.println(<span class="string">&quot;局部变量的值：&quot;</span></span><br><span class="line">					+porp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inclass</span>();</span><br><span class="line">		in.info();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">DiscernVariable</span>().test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>非静态的内部类成员可以访问外部类的实例成员，但反过来就不成立了。如果外部类需要访问非静态内部类的实例成员，则必须显式创建非静态内部类对象来调用访问其他实例成员。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">OutProp</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">inPror</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessOuterPerp</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			非静态内部类可以直接访问外部类的private实例变量</span></span><br><span class="line">			System.out.println(<span class="string">&quot;外部类的OutPror值&quot;</span></span><br><span class="line">					+OutProp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessInnerPerp</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		外部类不可以直接访问内部类的实例变量</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;内部类的inProp值：&quot;</span></span><br><span class="line"><span class="comment">//				+inProp);</span></span><br><span class="line"><span class="comment">//		必须创建显式内部类的对象来访问内部类的成员变量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;内部类的inProp值：&quot;</span></span><br><span class="line">				+ <span class="keyword">new</span> <span class="title class_">Inner</span>().inPror);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		执行下面代码只会创建外部类对象，还未创建内部类对象</span></span><br><span class="line">		<span class="type">Outer</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(); <span class="comment">//①</span></span><br><span class="line">		o1.accessInnerPerp();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>外部类不允许访问非静态内部类的实例成员的原因是，上面①号段代码创建了一个外部类对象，并调用外部类对象的accessInnerProp()方法，此时非静态内部类对象更不不存在，如果允许accessInnerProp()方法访问非静态内部类的实例成员，将肯定引起错误。</p>
<p>非静态内部类和外部类的关系：</p>
<p><strong>非静态内部类必须寄生在外部类对象里，而外部类对象则不必一定有非静态内部类对象寄生其中。简单的来说，如果存在一个非静态内部类对象，则一定存在一个被它寄生得外部类对象。但外部类对象存在时，外部类对象里不一定寄生了非静态内部类对象。因此外部类对象访问非静态内部类成员时，可能非静态普通内部类对象根本不存在！而非静态内部类对象访问外部类成员时，外部类对象一定存在。</strong></p>
<p>根据静态成员不能访问非静态成员的规则，外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量，创建实例等。总之，不允许在外部类的静态成员变量中直接用非静态内部类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个非静态的内部类，是一个空类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">In</span>&#123;&#125;</span><br><span class="line"><span class="comment">//	外部类的静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		下面代码引发编译异常，因为静态成员（main（）方法）</span></span><br><span class="line"><span class="comment">//		无法访问非静态成员（in类）</span></span><br><span class="line"><span class="comment">//		new In();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Java不允许在非静态内部类里定义静态成员，非静态内部类里不能有静态方法、静态成员变量、静态初始化块，所以上面三个静态声明都会引发错误。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerNoStatic</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 下面三个静态声明都将引发如下编译错误</span></span><br><span class="line"><span class="comment">		 * 非静态内部类不能有静态声明</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">//		static</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;========&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		private static int inProp;</span></span><br><span class="line"><span class="comment">//		private static void test() &#123;&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>非静态内部类里不可以有静态初始化块，但可以包含普通初始化块。非静态内部类普通初始化块的作用与外部初始化块的作用完全相同。</p>

        <h3 id="6-7-2静态内部类"   >
          <a href="#6-7-2静态内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-2静态内部类" class="headerlink" title="6.7.2静态内部类"></a>6.7.2静态内部类</h3>
      <p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类（静态内部类）。</p>
<p> static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员变量属于整个类而不属于单个对象。外部类的上一级程序单元是包，所以不能使用static修饰，内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部实例相关，因此static关键字不能修饰外部类，但可以修饰内部类。</p>
<p>静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">prop1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">prop2</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		静态内部类里可以包含静态成员</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;<span class="comment">//①</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">accessOutProp</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			静态内部类无法访问外部类的实例变量</span></span><br><span class="line"><span class="comment">//			System.out.println(prop1);</span></span><br><span class="line">			System.out.println(prop2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>①中定义了一个静态成员变量 ，因为这个静态成员变量处于静态内部类中，所以完全没有问题。StaticInnerClass类中定义了一个accessOutProp()方法，这是一个实例方法，但依然不能访问外部类的prop1成员变量，但可以访问prop2成员变量，因为它是静态成员变量。</p>
<p>静态内部类的实例方法不能访问外部类的实例属性，因为静态内部类是与外部类相关的，而不是外部类对象相关的，也就是说，静态内部类对象不是寄生在外部类的实例中，而是寄生在外部类的类本身中。当静态内部类对象存在时，并不存在一个被它寄生的外部类对象，静态内部类对象只持有外部类引用，没有持有外部类对象的引用。如果允许静态内部类的实例方法访问外部类的实例成员，但找不到被寄生的外部类对象，这将引起错误。以下代码帮助理解。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Help</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>  <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> wight;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yea</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		不能对非静态字段 age 进行静态引用</span></span><br><span class="line"><span class="comment">//		age = 10;</span></span><br><span class="line">		wight = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-7-3使用内部类"   >
          <a href="#6-7-3使用内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-3使用内部类" class="headerlink" title="6.7.3使用内部类"></a>6.7.3使用内部类</h3>
      <p>1.在外部类内部使用内部类</p>
<p>2.在外部类以外使用非静态内部类</p>
<p>示范了如何在外部类以外的地方创建非静态内部类的对象，并把它赋给非静态内部类类型</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何在外部类以外的地方创建非静态内部类的对象，并把它赋给非静态内部类类型变量。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Out</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个内部类，不使用访问控制符</span></span><br><span class="line"><span class="comment">//	即只有同一个包中的其他类可访问该内部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">In</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">In</span><span class="params">(String msg)</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateInnerInstance</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//非静态内部类的构造器必须使用外部类对象来调用</span></span><br><span class="line">		Out.<span class="type">In</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Out</span>().<span class="keyword">new</span> <span class="title class_">In</span>(<span class="string">&quot;测试信息&quot;</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 上面的代码可改为如下三行代码</span></span><br><span class="line"><span class="comment">		 * 使用OuterClass.InnerClass的形式定义内部类变量</span></span><br><span class="line"><span class="comment">		 * Out.In in;  //调用内部类构造器</span></span><br><span class="line"><span class="comment">		 * 创建外部类实例,非静态内部类实例将寄生在该实例中</span></span><br><span class="line"><span class="comment">		 * Out out = new Out();</span></span><br><span class="line"><span class="comment">		 * 通过外部类实例和new来调用内部类构造器创建非静态实例</span></span><br><span class="line"><span class="comment">		 * in = out.new In(&quot;测试信息&quot;)；</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果需要在外部类以外的地方创建非静态内部类的子类，尤其要注意上面的规则：非静态内部类的构造器必须通过其外部类对象来调用。</p>
<p>当创建一个子类时，子类构造器总会调用父类构造器，因此在创建非静态内部类的子类时，必须保证让子类构造器可以调用非静态内部类的构造器，调用非静态内部类的构造器时，必须存在一个外部类对象。下面定义了一个子类继承了Out类的非静态内部类In类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">Out</span>.In</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(Out out)</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//		调用父类构造器</span></span><br><span class="line">		out.<span class="built_in">super</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>非静态内部类In类的构造器必须使用外部类对象来调用,代码中super代表调用In类的构造器,而out代表外部类对象.</p>
<p>如果需要创建一个SubClass对象,就必须创建一个Out对象.因为SubClass是非静态内部类In的子类,非静态内部类In对象里必须有一个对Out对象的引用,其子类SubClass对象里也应该持有对Out对象的引用.当创建SubClass对象是传给该构造器的Out对象,就是SubClass里Out对象引用所指向的对象.</p>
<p>3.在外部类以外使用静态内部类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>.InnerConstructor()</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticOut</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个静态内部类，不使用访问控制符</span></span><br><span class="line"><span class="comment">//	即同一个包中的其他类可访问该内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticIn</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">StaticIn</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;静态内部类的构造器。&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateStaticlnnerlnstance</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		StaticOut.<span class="type">StaticIn</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticOut</span>.StaticIn();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * StaticOut.StaticIn in</span></span><br><span class="line"><span class="comment">		 * in = new StaticOut.StaticIn();</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>创建内部类对象时,静态内部类只需要外部类即可调用构造器,而非静态类必须使用外部类对象来调用构造器。</strong></p>
<p>因为调用静态内部类的构造器时,无需使用外部类对象,所以创建静态内部类的子类也比较简单,下面代码就为静态内部类StaticIn类定义了一个空的子类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticSubClass</span> <span class="keyword">extends</span> <span class="title class_">StaticOut</span>.StaticIn&#123;&#125; </span><br></pre></td></tr></table></div></figure>

<p>当定义一个静态内部类时,其外部类非常像一个包空间。</p>
<p>使用静态内部类比使用非静态内部类要简单，只要把外部类当成静态内部类的包空间即可，所以，当程序需要使用内部类时，应该&#x3D;&#x3D;优先考虑静态内部类&#x3D;&#x3D;。</p>
<p>内部类的类名不再是简单的内部类的类名构成，它实际上还把外部类的类名作为一个命名空间，作为内部类类名的限制。因此子类中的内部类和父类中的内部类不可能完全同名，即使二者所包含的内部类类名相同，但因为它们所处的外部类空间不同，所以它们不可能完全同名，也就不可能重写。</p>

        <h3 id="6-7-4-局部内部类"   >
          <a href="#6-7-4-局部内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-4-局部内部类" class="headerlink" title="6.7.4 局部内部类"></a>6.7.4 局部内部类</h3>
      <p>把一个内部类放在一个方法里定义，那么这个内部类就是一个局部内部类，局部内部类仅在该方法里有效。</p>
<p><strong>所有的局部变量都不能使用局部控制符。</strong></p>
<p>如果使用局部内部类定义变量、创建实例或派生子类，那么只能在局部内部类所在的方法内进行。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocallnnerClass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义局部内部类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">InnerBase</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> a;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		定义局部内部类子类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">InnerSub</span> <span class="keyword">extends</span> <span class="title class_">InnerBase</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> b;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		创建局部内部类的对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerSub</span>();</span><br><span class="line">		is.a = <span class="number">5</span>;</span><br><span class="line">		is.b = <span class="number">7</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;InnerSub对象的a和b实例变量是&quot;</span></span><br><span class="line">				+is.a+<span class="string">&quot;,&quot;</span>+is.b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译上面程序，会生成三个class文件LocallnnerClass$1InnerBase.class,	LocallnnerClass$1InnerSub.class,	LocallnnerClass.class。这表明内部类class文件总是遵循如下命名规则OutClass$NInnerClass.class。注意文件名比成员内部类的class文件多了有一个数字，这是因为同一个类里不可能有两个同名的成员内部类，而同一个类里则可能有两个以上同名的局部内部类（处于不同的方法中），所有增加了一个数字进行区分。</p>
<p>开发中很少用局部内部类</p>

        <h3 id="6-7-5-匿名内部类"   >
          <a href="#6-7-5-匿名内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-5-匿名内部类" class="headerlink" title="6.7.5 匿名内部类"></a>6.7.5 匿名内部类</h3>
      <p>匿名内部类适合创建那种只需要一次使用的类，例如前面介绍的命令模式所需要的Command对象，匿名内部类的语法有点奇怪，创建匿名内部类时会创建一个该类的实例，这个类定义立即消失，匿名内部类不能重复使用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 实现接口() | 父类构造器(实参列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//匿名内部类的类题部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上面定义可以看出，匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口，还有两个规则如下：</p>
<ul>
<li>匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。因此不允许匿名内部类定义成抽象类。</li>
<li>匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。</li>
</ul>
<blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">	String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Product p)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span> + p.getName()</span><br><span class="line">				+ <span class="string">&quot;,&quot;</span> + p.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousTest</span>();</span><br><span class="line"><span class="comment">//		调用test()方法时，需要传入一个Product参数</span></span><br><span class="line"><span class="comment">//		此处传入其匿名实现类的实例</span></span><br><span class="line">		ta.test(<span class="keyword">new</span> <span class="title class_">Product</span>()</span><br><span class="line">				&#123;<span class="comment">//匿名内部类类体部分</span></span><br><span class="line">					<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> </span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">567.8</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="string">&quot;AGP显卡&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;<span class="comment">//匿名内部类类体部分);</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                匿名内部类类体部分可分解为</span></span><br><span class="line"><span class="comment">                class AnounymousProduct implements Product</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                	public double getPrice() </span></span><br><span class="line"><span class="comment">					&#123;</span></span><br><span class="line"><span class="comment">						return 567.8;</span></span><br><span class="line"><span class="comment">					&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					public String getName()</span></span><br><span class="line"><span class="comment">					&#123;</span></span><br><span class="line"><span class="comment">						return &quot;AGP显卡&quot;;</span></span><br><span class="line"><span class="comment">					&#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ta.test(new AnounymousProduct());</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</blockquote>
<p>上面程序中AnonymousTest类定义了一个test()方法，该方法需要一个Product对象作为参数，但Product只是一个接口，无法直接创建对象，因此此处考虑创建一个Product接口实现类的对象传入该方法——如果这个Pruduct接口实现类需要重复使用，则应该将该实现类定义成一个独立类；如果这个Product接口实现类只需一次使用，则可采用上面程序中的方式，定义一个匿名内部类。</p>
<p>正如上面程序所看到的，定义匿名内部类无需class关键字，而是在定义匿名内部类时直接生成该匿名内部类的对象。上面标注中为匿名内部类类体部分。</p>
<p>由于匿名内部类不能是抽象类，所以匿名内部类必须实现它的抽象父类或者接口里包含的所有抽象方法。</p>
<p>当通过实现接口来创建匿名内部类时，匿名内部类不能显式地定义构造器，因此匿名内部类只有一个隐式的无参数构造器，故new接口名后的括号里不能传入参数值。</p>
<p>但如果通过继承父类来创建匿名内部类时，匿名内部类将拥有和父类相似的构造器，此处的相似指的是拥有相同的形参列表。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Device</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Device</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInner</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Device d)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span> + d.getName()</span><br><span class="line">		+ <span class="string">&quot;,&quot;</span> + d.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousInner</span>();</span><br><span class="line"><span class="comment">//		调用有参数的构造器创建Device匿名实现类的对象</span></span><br><span class="line">		ai.test(<span class="keyword">new</span> <span class="title class_">Device</span>(<span class="string">&quot;电子示波器&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">67.8</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line"><span class="comment">//		调用无参数的构造器创建Device匿名实现类的对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Device</span>()</span><br><span class="line">				&#123;</span><br><span class="line"><span class="comment">//					初始化块</span></span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;匿名内部类的初始化块。。。&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line"><span class="comment">//					实现抽象方法</span></span><br><span class="line">					<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">56.2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="string">&quot;键盘&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				ai.test(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>创建了一个抽象父类Decice类，包含两个构造器，一个无参，一个有参，当以Device为父类的匿名内部类时，既可以传入参数（代表调用父类带参数的构造器），也可以不传入参数。（代表调用父类不带参数的构造器）。</p>
<p>当创建匿名内部类时，必须实现接口或抽象父类里的所有抽象方法。如果有需要，也可以重写父类中的普通方法，其中getName()方法并不是抽象方法。</p>
<p><strong>如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 由于局部变量age被匿名内部类访问了，所以age将自动加上final修饰，所以不可修改age的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">//		age = 2;</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//						从Java 8以前下面语句将提示错误：age必须使用final修饰</span></span><br><span class="line"><span class="comment">//						从Java 8开始，匿名内部类、局部内部类允许访问非final的局部变量</span></span><br><span class="line">						System.out.println(age);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				a.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="6-8-Java-11增强的Lambda表达式"   >
          <a href="#6-8-Java-11增强的Lambda表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-8-Java-11增强的Lambda表达式" class="headerlink" title="6.8 Java 11增强的Lambda表达式"></a>6.8 Java 11增强的Lambda表达式</h2>
      <p>Lambda支持将代码块作为方法参数，Lambda表达式允许更简洁的代码来创建只有一个抽象方法的接口（这种接口被称为函数式接口）的实例。</p>

        <h3 id="6-8-1-Lambda表达式入门"   >
          <a href="#6-8-1-Lambda表达式入门" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-8-1-Lambda表达式入门" class="headerlink" title="6.8.1 Lambda表达式入门"></a>6.8.1 Lambda表达式入门</h3>
      <p>下面使用匿名内部类来改写command表达式的例子。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest1</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">		<span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//		处理数组，具体处理行为取决于匿名内部类</span></span><br><span class="line">		pa.process(target,<span class="keyword">new</span> <span class="title class_">Command</span>()</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span>  <span class="comment">//粗体字开始</span></span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span> + element * element);</span><br><span class="line">					&#125;	<span class="comment">//粗体字结束</span></span><br><span class="line">				&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>前面已经提到，processArray类的process()方法处理数组时，希望可以动态传入一段代码作为具体的处理行为，因此程序创建一个匿名内部类实例来封装处理行为。从上面代码可以看出，用于封装处理行为的关键就是实现程序中的粗体字方法。但是为了向process()方法传入这段粗体字代码，程序不得不使用匿名内部类的语法来创建对象。</p>
<p>Lambda表达式完全可以用于简化创建匿名内部类对象，如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">		<span class="type">int</span>[] array = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//		处理数组，具体处理行为取决于匿名内部类</span></span><br><span class="line">		pa.process(array,(<span class="type">int</span> element)-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span> + element * element);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> element)-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span> + element * element);</span><br></pre></td></tr></table></div></figure>

<p>这段代码中与创建匿名内部类时需要实现的process(int element)方法完全相同，只是不需要new Xxx(){}这种繁琐的代码，不需要指出重写的方法名字，也不需要给出重写的方法的返回值类型——只要给出重写的方法括号以及括号里的形参列表即可。</p>
<p>Lambda表达式的主要作用就是代替匿名内部类的繁琐语句。由</p>
<ul>
<li>形参列表：允许省略形参类型</li>
<li>箭头(-&gt;)</li>
<li>代码块：Lambda表达式需要返回值，而他的代码块中仅有一条省略了return的语句，Lambda表达式会自动返回这条语句的值。</li>
</ul>
<p>下面程序师范了Lambda表达式的几种简化写法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">taste</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span></span><br><span class="line">&#123;</span><br><span class="line">	String <span class="title function_">fly</span><span class="params">(String weather,String tool)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Addable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaQs</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	调用该方法需要Eatable对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Eatable a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		a.taste();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Flyable b)</span></span><br><span class="line">	&#123;</span><br><span class="line">		b.fly(<span class="string">&quot;【碧空如洗的晴天】&quot;</span>,<span class="string">&quot;【直升机】&quot;</span>);</span><br><span class="line"><span class="comment">//		System.out.println(&quot;我正在驾驶&quot; + b);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Addable add)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;5和3的和为：&quot;</span> + add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">lp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaQs</span>();</span><br><span class="line"><span class="comment">//		lp.eat(()-&gt;System.out.println(&quot;苹果的味道很不错&quot;));</span></span><br><span class="line"><span class="comment">////		lp.drive((String weather,String tool)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;今天的天气是：&quot; + weather);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;直升机稳定飞行&quot;+tool);</span></span><br><span class="line"><span class="comment">//		&#125;);</span></span><br><span class="line"><span class="comment">//		lp.test((a,b)-&gt;a+b);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>此段代码书中会因为两个变量未赋值而出现乱码，上面代码是自己修改后的，但是还是不会改，后期改进。</strong></p>
<p>上面程序中的第一段粗体字代码使用Lambda表达式相当于不带形参的匿名方法由于该Lambda表达式的代码块只有一行代码，因此可以省略代码块的花括号；后两段同理。</p>
<p>第一段粗体字代码中调用了eat()方法，调用该方法需要一个Eatable类型的参数，但实际上传入的是Lambda表达式，后两段同理，但上面的程序可以正常变异，运行，这说明Lambda表达式实际上将会被当做“任意类型”的对象，到底需要当成何种类型的对象，这取决于运行环境的需要，下面详细介绍。</p>

        <h3 id="6-8-2-Lambda表达式与函数式接口"   >
          <a href="#6-8-2-Lambda表达式与函数式接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-8-2-Lambda表达式与函数式接口" class="headerlink" title="6.8.2 Lambda表达式与函数式接口"></a>6.8.2 Lambda表达式与函数式接口</h3>
      <p>Lambda表达式的类型，也被称为“目标类型（targert type）”，Lambda表达式的目标类型必须是“函数式接口(functional interface)”。函数式接口代表只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但只能声明一个抽象方法。</p>
<p>如果采用匿名内部类语法来创建函数式接口实例，则只需要实现一个抽象方法，在这种情况下，可采用Lambda表达式来创建对象，该表达式创建出来的对象的目标类型就是这个函数式接口。</p>
<p>由于Lambda表达式的接口就是被当成对象，因此程序中完全客户以使用Lambda表达式进行赋值</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//		Runnable 接口中只包含一个无参数的方法，</span></span><br><span class="line"><span class="comment">//		Lambda 表达式代表的匿名方法实现了Runnable 接口中唯一的、无参数的方法</span></span><br><span class="line"><span class="comment">//		因此下面的Lambda表达式创建了一个Runnable 对象</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Runnable是Java本身提供的一个函数式接口。</p>
<p>从上面代码可以看出，Lambda实现的是匿名方法——因此他只能实现特定函数式接口中的唯一方法。这意味着Lambda表达式有如下两个特性：</p>
<ul>
<li>Lambda表达式的目标类型必须是明确的函数式接口。</li>
<li>Lambda表达式只能为函数式接口创建对象。Lambda表达式只能实现一个方法，因此它只能为只有一个抽象方法的接口（函数式接口）创建对象。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></div></figure>

<p>上面的代码与前一段代码几乎完全相同，只是此时程序将Lambda表达式不在赋值给Runnable变量，而是直接复制给Object变量。编译上面代码，会报错（不兼容的类型：Object不是函数接口）。</p>
<p>从该错误可以看出，Lambda表达式的目标类型必须是明确的函数式接口。尚敏代码将Lambda表达式赋给Object变量，编译器只能确定该Lambda表达式的类型为Object，而Object并不是函数式接口，因此会报错。</p>
<p><strong>P220以后的Lambd内容暂时省略。（学不下去了）</strong></p>

        <h2 id="6-9-枚举类"   >
          <a href="#6-9-枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-枚举类" class="headerlink" title="6.9 枚举类"></a>6.9 枚举类</h2>
      <p>在某些情况下，一个类的对象是有限而且固定的，比如季节类，他只有4个对象；再比如行星类，目前只有8个对象。这种&#x3D;&#x3D;实例有限而且固定的类，在Java里被称为枚举类。&#x3D;&#x3D;</p>

        <h3 id="6-9-1-手动实现枚举类"   >
          <a href="#6-9-1-手动实现枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-1-手动实现枚举类" class="headerlink" title="6.9.1 手动实现枚举类"></a>6.9.1 手动实现枚举类</h3>
      <p>在早期代码中，可能会直接使用简单的静态常量来表示枚举，例如以下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_SPRING</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_SUMMER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_FALL</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_WINTER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-9-2-枚举类入门"   >
          <a href="#6-9-2-枚举类入门" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-2-枚举类入门" class="headerlink" title="6.9.2 枚举类入门"></a>6.9.2 枚举类入门</h3>
      <p>Java 5新增了一个 enum 关键字（他与class interface关键字的地位相同），用以定义枚举类，枚举类是一种特殊的类，他一样可以有自己的成员变量，方法，可以实现一个或多个接口，也可以定义自己的构造器。一个Java源文件中最多只能定义一个public访问权限的枚举类，而且该Java源文件也必须与该枚举类的类名。</p>
<p>但枚举类终究不是普通类，他与普通类有如下区别</p>
<ul>
<li>枚举类可以实现一个或多个接口，使用enum定义的枚举默认继承了java.lang.Enum类，而不是默认继承了Object类，因此枚举类不能显式继承其他父类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li>
<li>使用enum定义、非抽象的枚举类默认会使用final修饰。</li>
<li>枚举类的构造器只能使用private访问控制符，如果省略了构造器的访问控制符，则默认使用private修饰；如果强制指定访问控制符，则只能指定private修饰符。由于枚举类的所有构造器都是private的，而子类构造器总要调用父类一次，因此枚举类不能派生子类。</li>
<li>枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远不能派生实例。列出这些实例时，系统会自动添加public static final修饰，无须程序员显式添加。</li>
</ul>
<p>枚举类默认提供了一个values()方法，该方法可以很方便的遍历所有的枚举值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line"><span class="comment">//在第一行列出4个枚举实例</span></span><br><span class="line">	SPRING,SUMMER,FALL,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这些枚举值代表了该枚举类的所有可能的实例。</p>
<p>如果需要使用该枚举类的某个实例，则可以使用EnumClass.variable的形式。如SeasonEnum.SPRING。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">judge</span><span class="params">(SeasonEnum s)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		switch语句里的表达式可以是枚举值</span></span><br><span class="line">		<span class="keyword">switch</span>(s)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> SPRING:</span><br><span class="line">			System.out.println(<span class="string">&quot;春暖花开。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SUMMER:</span><br><span class="line">			System.out.println(<span class="string">&quot;夏日炎炎。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FALL:</span><br><span class="line">			System.out.println(<span class="string">&quot;秋风瑟瑟。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WINTER:</span><br><span class="line">			System.out.println(<span class="string">&quot;冬日雪飘。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		枚举类默认有一个values()方法，返回该枚举值的所有实例</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> s : SeasonEnum.values())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		使用枚举实例时，可以通过EnumClass.variable形式来访问。</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">EnumTest</span>().judge(SeasonEnum.SPRING);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>switch的控制表达式可以是任何枚举类型。而且case表达式中的值直接使用枚举值的名字，无须添加枚举类进行限定。</p>
<p>下面是java.lang.Enum类中所包含的方法：</p>
<p>![](C:\Program Files\Typora\image\0ee5804edadb22c1bba5195a057dc5a.jpg)</p>
<p>![](C:\Program Files\Typora\image\825b1552f2d3b10d4e1cbe892dbd550.jpg)</p>

        <h3 id="6-9-3-枚举类的成员变量、方法和构造器"   >
          <a href="#6-9-3-枚举类的成员变量、方法和构造器" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-3-枚举类的成员变量、方法和构造器" class="headerlink" title="6.9.3 枚举类的成员变量、方法和构造器"></a>6.9.3 枚举类的成员变量、方法和构造器</h3>
      <p>枚举类也是一种类，只是它是一种比较特殊的类，因此他一样可以定义成员变量、方法和构造器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> </span><br><span class="line">&#123;</span><br><span class="line">	MALE,FEMALE;  <span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//	定义一个public修饰的实例变量</span></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		通过Enum的valueof()方法来获取指定枚举类的枚举值</span></span><br><span class="line">		<span class="type">Gender</span> <span class="variable">g</span> <span class="operator">=</span> Enum.valueOf(Gender.class, <span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line"><span class="comment">//		直接为枚举值的name实例变量赋值</span></span><br><span class="line">		g.name = <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="comment">//		直接访问枚举值的name实例变量</span></span><br><span class="line">		System.out.println(g + <span class="string">&quot;代表：&quot;</span> + g.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序使用Gender枚举类时与使用一个普通类没有太大的差别，差别只是产生Gender对象的方式不同，枚举类的实例只能是枚举类，而不是随意地通过new来创建枚举类对象。</p>
<p>正如前面所提到的，Java应该把所有类设计成良好的封装的类，所以不应该允许直接访问Gender类的name成员变量，而是应该通过方法来控制对name的访问。否则可能出现很混乱的情形，例如上面程序恰好设置了g.name&#x3D;”女”,要是采用g.name&#x3D;”男”，那程序就会非常混乱了，可能出现FEMALE代表男的局面了，下面做出了改进：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GenderBetter</span> </span><br><span class="line">&#123;</span><br><span class="line">	MALE,FEMALE;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(<span class="built_in">this</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> MALE:</span><br><span class="line">			<span class="keyword">if</span>(name.equals(<span class="string">&quot;男&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">this</span>.name = name;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FEMALE:</span><br><span class="line">			<span class="keyword">if</span>(name.equals(<span class="string">&quot;女&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">this</span>.name = name;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序吧name设置成private，从而避免了其他程序直接访问该name成员变量，必须通过setName()方法来修改Getder实例的name变量，而setName()方法就可以保证不会产生混乱。上面程序中粗体字部分保证FEMALE枚举值的name变量只能设置成“女”，而MALE枚举值只能设置为男。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderBetterTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">GenderBetter</span> <span class="variable">g</span> <span class="operator">=</span> GenderBetter.valueOf(<span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">		g.setName(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">		System.out.println(g + <span class="string">&quot;代表&quot;</span> + g.getName());</span><br><span class="line"><span class="comment">//		此时设置name值是将会提醒参数错误</span></span><br><span class="line">		g.setName(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">		System.out.println(g + <span class="string">&quot;代表&quot;</span> + g.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的代码还不够好，枚举类通常应该设置成不可变类，也就是说，他的成员变量值不应该允许改变这样会更加安全，而且代码更加简洁。因此建议枚举类的成员变量使用public final修饰。</p>
<p>如果将所有的成员变量都使用fianl修饰符来修饰，所以必须在构造器里为这些成员变量指定初始值（或者在定义成员变量是指定默认值，或者在初始化块中指定初始值，但这两种情况不常见），因此应该为枚举类显式定义带参数的构造器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GenderBest</span> &#123;</span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>), FEMALE(<span class="string">&quot;女&quot;</span>);  <span class="comment">//粗体字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">GenderBest</span><span class="params">(String name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序，为GenderBest枚举类构造一个GenderBest（String name）构造器之后，列出枚举值就应该采用粗体字来完成。也就是说。在枚举类中列出枚举值是，实际上就是调用构造器创建枚举类对象，只是这里无须使用new关键字，也无须显示调用构造器。前面列出枚举值时无须传入参数，升值无须使用括号，仅仅是因为前面的枚举值包含无参数的构造器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出枚举值相当于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GenderBest</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenderBest</span>(<span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GenderBest</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenderBest</span>(<span class="string">&quot;女&quot;</span>);</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-9-4-实现接口的枚举类"   >
          <a href="#6-9-4-实现接口的枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-4-实现接口的枚举类" class="headerlink" title="6.9.4 实现接口的枚举类"></a>6.9.4 实现接口的枚举类</h3>
      <p>枚举类也能实现一个或多个接口。与普通方法实现一个或多个接口完全一样，枚举类实现一个或多个接口是，也需要实现该接口所包含的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenderDesc</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在上面GenderDesc接口中定义了一个Info()方法，下面的Gerder枚举类实现了接口，并实现了该接口里包含的info()方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender1</span> <span class="keyword">implements</span> <span class="title class_">GenderDesc</span></span><br><span class="line">&#123;</span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>), FEMALE(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Gender1</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;这是一个用于定义性别的枚举类&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果由枚举类来实现接口里的方法，则每个枚举类在调用该方法时都有相同的行为方式（因为方法体完全一样）。如果需要每个枚举值在调用该方法时呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法，每个枚举值提供不同的实现方法，从而让不同的枚举值调用该方法时具有不用的行为方式。在下面的Gender枚举类中，不同的枚举值对info()方法的实现各不相同。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender1</span> <span class="keyword">implements</span> <span class="title class_">GenderDesc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	此处的枚举值必须调用对应的构造器来完成</span></span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>)  </span><br><span class="line"><span class="comment">//	花括号部分实际上是一个类体部分</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;这个枚举类代表男性&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	FEMALE(<span class="string">&quot;女&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;这个枚举值代表女性&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;<span class="comment">//自己加的，感觉加上这一句话更符合下面的解释</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Gender1</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//下面为自己加的测试</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(Gender1.FEMALE+<span class="string">&quot;代表着&quot;</span>+Gender1.FEMALE.name);</span><br><span class="line">		System.out.println(Gender1.MALE+<span class="string">&quot;代表着&quot;</span>+Gender1.MALE.name);</span><br><span class="line">		<span class="comment">//System.out.println(Gender1.FEMALE.info());此行代码错误，学会后修改</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>上面的代码的粗体字部分看起啦有些奇怪，当创建MALE和FEMALE两个枚举值时，后面又紧跟了一对花括号，这对花括号里包括了一个info()方法来定义。如果还记得匿名内部类的语法的话，则可能对这样的语法有点印象了，花括号部分实际上就是一个类体部分，这种情况下，当创建MALE、FEMALE枚举值时，并不是直接创建Gender枚举类的实例，而是相当于创建Gender的匿名子类的实例。因为粗体字括号部分实际上是匿名内部类的类体部分，所以这个部分的代码部分与前面介绍的匿名内部类语法大致相同，只是它依然是枚举类的匿名内部类的子类。</p>
<p>对于一个抽象的枚举类而言——只要它包含了抽象方法，他就是抽象枚举类，系统会默认用abstract修饰，而不是使用final修饰。</p>
<p> 编译Gender1类即可发现出现三个class文件，即可证明MALE和FEMALE实际上是Gender1匿名子类的实例。</p>

        <h3 id="6-9-5-包含抽象方法的枚举类"   >
          <a href="#6-9-5-包含抽象方法的枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-5-包含抽象方法的枚举类" class="headerlink" title="6.9.5 包含抽象方法的枚举类"></a>6.9.5 包含抽象方法的枚举类</h3>
      <p>定义一个抽象类的枚举类Opration ，让4个枚举值分别为eval()方法实现不同的加减乘除。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Opration</span> </span><br><span class="line">&#123;</span><br><span class="line">	PIUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	MINUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x-y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	TIMES</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x*y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	DIVIDE</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x/y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(Opration.PIUS.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(Opration.MINUS.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(Opration.TIMES.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(Opration.DIVIDE.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译此程序会出现5个class方法，Opration 对应一个，其他四个为四个匿名内部子类。</p>
<p>枚举类里定义抽象方法时不能使用abstract关键字来讲枚举类定义成抽象类（因为体统会自动为他添加abstract关键字），但因为枚举类需要显示创建枚举类，而不是父类，所以定义每个枚举值时必须为抽象方法提供实现，否则会编译错误。</p>

        <h2 id="6-10-对象与垃圾回收"   >
          <a href="#6-10-对象与垃圾回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-对象与垃圾回收" class="headerlink" title="6.10 对象与垃圾回收"></a>6.10 对象与垃圾回收</h2>
      <p>Java的垃圾回收是Java语言的重要功能之一。当程序创建对象、数组等引用类型实体时，系统东辉在堆内存中为之分配一块内存，对象就保存在这块内存区中，当这块内存不再被任何引用类型引用时，这块内存就成了垃圾，等待垃圾回收机制进行回收。垃圾回收机制有如下机制：</p>
<ul>
<li>垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源（例如数据库练级，网络IO等资源）。</li>
<li>程序无法精确的控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性地失去引用后，系统就会在合适的时候回收他所占的内存。</li>
<li>在垃圾回收任何对象之前，总会先调用它的finalize()方法，该方法可能使该对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收。</li>
</ul>

        <h3 id="6-10-1-对象在内存中的状态"   >
          <a href="#6-10-1-对象在内存中的状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-1-对象在内存中的状态" class="headerlink" title="6.10.1 对象在内存中的状态"></a>6.10.1 对象在内存中的状态</h3>
      <p>当一个对象在堆内存中运行时，根据他被引用变量所引用的状态，可以把它所处的状态分成三种：</p>
<ul>
<li><p>可达状态：当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态，程序可通过引用变量来调用该对象的实例变量和方法。</p>
</li>
<li><p>可恢复状态：如果程序中某个对象不再有任何引用变量引用它，他就进入了可恢复状态。在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，系统会调用所有可恢复状态的finalize()方法进行资源清理。如果系统在调用finalize()方法时重新让一个引用变量引用该对象，则这个对象会再次变为可达状态；否则该对象将进入不可达状态。</p>
</li>
<li><p>不可达状态：当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize()方法后依然没有事该对象变成可达状态，那么这个对象将永久性地失去引用，最后变成不可达状态，系统才会真正回收该对象所占的资源。</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatusTranfer</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);<span class="comment">//此段代码执行结束后“轻量级Java EE企业应用实战”字符串对象处于可达状态</span></span><br><span class="line">		a = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>);<span class="comment">//“轻量级Java EE企业应用实战”此时处于可恢复状态，而&quot;疯狂Java讲义&quot;处于可达状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或被其他对象的实例变量引用。当某个对象呗其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；当某个对象被其他对象的还是实例变量引用时，只有当该对象被销毁后，该对象才会进入可恢复状态。</p>

        <h3 id="6-10-2-强制垃圾回收"   >
          <a href="#6-10-2-强制垃圾回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-2-强制垃圾回收" class="headerlink" title="6.10.2 强制垃圾回收"></a>6.10.2 强制垃圾回收</h3>
      <p>  当一个对象失去引用后，系统何时调用它的finalize()方法对他进行资源清理，何时他会变成不可达状态，系统核实回收他所占有的内存，对于程序完全透明。程序只能控制一个对象何时不再被任何引用变量引用，决不能控制它何时被回收。</p>
<p>但任然可以强制系统进行垃圾回收——这种强制只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不确定。大部分时候，程序强制系统垃圾回收后总会有一些效果。强制系统垃圾回收方式有两种：</p>
<ol>
<li>调用System类的gc()静态方法：System.gc()。</li>
<li>调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc()。</li>
</ol>
<p>下面创建了4个匿名对象，每个对象创建之后立即进入可恢复状态，等待系统回收，但直到系统退出，系统依然不会回收该资源。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">GcTest</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;系统正在清理GcTest对象的资源...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>系统不曾调用GcTest对象的finalize()方法，修改如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">GcTest</span>();</span><br><span class="line"><span class="comment">//			下面两行代码起的作用完全相同，强制系统进行垃圾回收</span></span><br><span class="line"><span class="comment">//			System.gc();</span></span><br><span class="line">			Runtime.getRuntime().gc();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;系统正在清理GcTest对象的资源...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![](C:\Program Files\Typora\image\04edad008bb713dd080adae680fdca9.png)</p>
<p>运行java命令时指定-varbose:gc选项可以看待回收后的提示信息。</p>
<p>上面显示了程序强制垃圾回收的效果，但这种强制只是建议系统立即进行垃圾回收，系统完全有可能并不立即垃圾回收，垃圾回收机制也不会对程序的建议完全置之不理：垃圾回收机制会在收到通知后，尽快进行垃圾回收。</p>

        <h3 id="6-10-3-finalize方法"   >
          <a href="#6-10-3-finalize方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-3-finalize方法" class="headerlink" title="6.10.3 finalize方法"></a>6.10.3 finalize方法</h3>
      <p>在垃圾回收机制回收某个对象所占用的内存之前，通常要求程序调用适当的方法来清理资源，在没有明确指定清理资源的情况下，Java提供了默认机制来清理该对象的资源，这个机制就是finalize()方法。该方法是定义在Object类里的实例方法，方法原型为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> thows Throwable</span><br></pre></td></tr></table></div></figure>

<p>当finalize()方法返回后，对象小时，垃圾回收机制开始执行。方法原型中的thows Throwable表示他可以抛出任何类型的异常。</p>
<p>记住以下几个特点：</p>
<ol>
<li>永远不要主动调用某个对象的finalize()方法，该方法应该交给垃圾回收机制调用。</li>
<li>finalize()方法何时被调用，是否被发调用具有不确定性，不要把finalize()方法当成一定会执行的方法。</li>
<li>当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。</li>
<li>当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。</li>
</ol>
<p>下面程序演示了如何在finalize()方法中复活自身，并可通过该程序看出垃圾回收的不确定性</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeTest</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//定义了ft类变量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;测试资源清理的finalize方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建FinalizeTest对象立即进入可恢复状态</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">FinalizeTest</span>();  <span class="comment">//创建了一个 FinalizeTest类的匿名对象</span></span><br><span class="line"><span class="comment">//		通知系统进行资源回收</span></span><br><span class="line">		System.gc();   <span class="comment">//①</span></span><br><span class="line"><span class="comment">//		强制垃圾回收机制调用可恢复对象的finalize()方法</span></span><br><span class="line"><span class="comment">//		Runtime.getRuntime().runFinalization();   //②</span></span><br><span class="line">		System.runFinalization();   <span class="comment">//③</span></span><br><span class="line">		ft.info();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		让ft引用到试图回收的可恢复对象，即可恢复对象重新变成可达</span></span><br><span class="line">		ft = <span class="built_in">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中定义了一个FinalizeTest类，<strong>重写了该类的finalize()方法</strong>，在该方法中把需要清理的可慧夫妇向重新赋值给ft引用变量，从而让该可恢复对象重新变成可达状态。</p>
<p>创建了一个 FinalizeTest类的匿名对象，但是没有给该对象赋值，所以立即进入可恢复状态。随后系统调用①通知系统进行垃圾回收，②强制系统立即调用可恢复对象的finalize()方法，再次调用ft对象的info()方法。info()任然可以正常运行。</p>
<p>删除①，取消强制垃圾回收后<img src="C:\Users\MingyangLiu\Desktop\张智超\image\Snipaste_2021-03-15_18-02-27.png"></p>
<p>因为删除①后，程序并没有通知系统回收垃圾（因为内存并不紧张），也就意味着没有调用finalize()，也就是说ft类变量将依然保持为null，这样就导致了空指针异常。</p>
<p>②和③都用于强制回收垃圾机制调用可恢复对象的finalize()方法，如果程序仅执行System.gc();代码，而不执行②或③代码——由于JVM垃圾回收机制的不确定性，JVM往往不立即调用可恢复对象的finalize()方法，这样FinaizeTest的ft类变量可能依然为null，可能依然会导致空指针异常。</p>

        <h3 id="6-10-4-对象的软、弱和虚引用"   >
          <a href="#6-10-4-对象的软、弱和虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-4-对象的软、弱和虚引用" class="headerlink" title="6.10.4 对象的软、弱和虚引用"></a>6.10.4 对象的软、弱和虚引用</h3>
      <p>对于大部分对象而言，程序里会有一个引用变量引用该对象，这是最常见的引用方式。除此之外，java.lang.ref包下提供三个类：软引用(SoftReference)、虚引用(PhantomReference)、弱引用(WeakReference)，他们代表了系统对象的三种引用方式。因此Java对对象的引用有如下4种方式：</p>
<p>1、强引用(StrongReference)</p>
<p>​	Java程序中最常见的引用方式。</p>
<p>2、软引用(SoftReference)</p>
<p>​	通过SoftReference类实现，当一个对象只有软引用时，它有可能被垃圾回收机制回收（看内存是否紧张），通常用于对内存敏感的程序中。</p>
<p>3、弱引用(WeakReference)</p>
<p>​	通过WeakReference类实现，弱引用和软引用很像，但弱引用的引用级别更低，对于引用的对象而言，<strong>当系统运行垃圾回收机制时</strong>，不管系统内存是否足够，总会回收该对象所占用的内存。</p>
<p>4、虚引用(PhantomReference)</p>
<p>​	虚引用通过PhantomReference类实现，虚引用完全类型与没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列（ReferenceQueue）联合使用。</p>
<p>引用队列由java.ref.ReferenceQueue类表示，它用于保存被回收后对象的引用。当联合使用软引用、弱引用和饮用队列时，系统在回收被引用的对象之后，将把被回收对象对应的引用添加到关联的引用队列中。虚引用在对象被释放之前，将把它对应的虚引用添加到关联的引用队列中，这使得可以在对象被回收前采取行动。</p>
<p>虚引用的主要作用就是用于跟踪对象被垃圾回收的状态，程序可以通过检查与虚引用关联的引用队列中是否已经包含了该虚引用，从而了解虚引用所引用的对象是否即将被回收。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个字符串对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		创建一个弱引用，让此弱引用引用到“疯狂Java讲义”字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(str);  <span class="comment">//①此处需要导包</span></span><br><span class="line"><span class="comment">//		切断str引用和“疯狂java讲义”字符串之间的引用联系</span></span><br><span class="line">		str = <span class="literal">null</span>;    <span class="comment">//②</span></span><br><span class="line"><span class="comment">//		取出弱引用所引用的对象</span></span><br><span class="line"><span class="comment">/*		.get()：返回这个引用对象的引用对象。</span></span><br><span class="line"><span class="comment">		如果这个引用对象已经被程序或垃圾收集器清除，那么这个方法将返回null。</span></span><br><span class="line"><span class="comment">		返回:该引用所引用的对象，如果该引用对象已被清除，则返回null</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		System.out.println(wr.get());   <span class="comment">//③</span></span><br><span class="line"><span class="comment">//		强制垃圾回收</span></span><br><span class="line">		System.gc();</span><br><span class="line">		System.runFinalization();</span><br><span class="line"><span class="comment">//		再次取出弱引用所引用的对象</span></span><br><span class="line">		System.out.println(wr.get());   <span class="comment">//④</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面：创建了一个疯狂Java讲义字符串对象，并让str引用变量引用。执行①，创建了一个弱引用对象，并让该对象与str引用同一对象。执行③，因为程序并不紧张，所以系统还不会回收wr所引用的对象，之后调用了System.gc()和System.runFinalize();通知系统进行垃圾回收，所以④输出null。</p>
<p>上面为弱引用，下面使用了虚引用来引用字符串对象，虚引用无法获取他引用的对象。下面还将虚引用与引用队列结合使用，可以看到虚引用所引用的对象被垃圾回收后，虚引用将被添加到引用队列中。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	<span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个字符串对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		创建一个引用队列</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">rq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">//		创建一个虚引用，</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str,rq);</span><br><span class="line"><span class="comment">//		切断str引用</span></span><br><span class="line">		str = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//		取出虚引用所引用的对象，并不能通过虚引用获取被引用的对象，所以输出null</span></span><br><span class="line">		System.out.println(pr.get());  <span class="comment">//①</span></span><br><span class="line"><span class="comment">//		强制垃圾回收</span></span><br><span class="line">		System.gc();</span><br><span class="line">		System.runFinalization();</span><br><span class="line"><span class="comment">//		垃圾回收后，虚引用将被放入引用队列中</span></span><br><span class="line"><span class="comment">//		取出引用队列中最先进入队列的引用与pr进行比较</span></span><br><span class="line">		System.out.println(rq.poll() == pr); <span class="comment">//②</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因为系统无法通过虚引用来获得被引用的对象，所以执行①号粗体字代码时，程序将输出null(即使此时并未通过强制进行垃圾回收)。当程序强制垃圾回收后，只有虚引用引用的字符串对象将会被垃圾回收，当被引用的对象被回收后，对应的虚引用将被添加到关联的引用队列中，因而将在②看到输出turn。</p>
<p>必须要指出的是，要使用这些特殊的引用类，就不能保留对对象的强引用；如果保留了对对象的强引用，就会浪费这些引用类所提供的任何好处。</p>
<p>由于垃圾回收的不确定性，当程序希望从软、弱引用中取出被引用对象时，可能这个被引用对象已经被释放了，如果程序需要使用那个被引用的对象，则必须重新创建该对象。这个过程可以采用两种方式完成，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出弱引用所引用的对象</span></span><br><span class="line">obj = wr.get();</span><br><span class="line"><span class="comment">//如果取出的对象为null</span></span><br><span class="line"><span class="keyword">if</span>(obj == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重新创建一个新的对象，再次让弱引用去引用该对象</span></span><br><span class="line">    wr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(recreateIt());   <span class="comment">//①</span></span><br><span class="line">    <span class="comment">//取出弱引用所引用的对象，将其赋给obj变量</span></span><br><span class="line">    obj = wr.get();   <span class="comment">//②</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作obj对象</span></span><br><span class="line"><span class="comment">//再次切断obj与对象之间的联系</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出弱引用所引用的对象</span></span><br><span class="line">obj = wr.get();</span><br><span class="line"><span class="comment">//如果取出的对象为null</span></span><br><span class="line"><span class="keyword">if</span>(obj == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重新创建一个新的对象，并使用强引用来引用它</span></span><br><span class="line">	obj = recreateIt();	</span><br><span class="line">    <span class="comment">//取出弱引用所引用的对象，将其赋给obj变量</span></span><br><span class="line">    wr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作obj对象</span></span><br><span class="line"><span class="comment">//再次切断obj与对象之间的联系</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></div></figure>

<p>上面两段代码采用的都是为嘛，其中recreateIt()方法用于生成一个obj对象。这两段代码都是判断obj对象是否已经被回收，如果已经被回收，则重新创建该对象。如果弱引用引用的对象已经被垃圾回收释放了，则重新创建该对象。但第一段代码中存在一定的问题，当if块执行完成后，obj还是有可能为null。因为垃圾回收的不确定性，假设系统在①和②代码之间进行了垃圾回收，则系统会再次将wr所引用的对象回收，从而导师obj依然是null。第二段代码则不会存在这个问题，当if结束后，obj一定不为null。</p>

        <h2 id="6-11-修饰符的使用范围"   >
          <a href="#6-11-修饰符的使用范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-11-修饰符的使用范围" class="headerlink" title="6.11 修饰符的使用范围"></a>6.11 修饰符的使用范围</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">外部类&#x2F;接口</th>
<th align="center">成员属性</th>
<th align="center">方法</th>
<th align="center">构造器</th>
<th align="center">初始化块</th>
<th align="center">成员内部类</th>
<th align="center">局部成员</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected(受保护的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">包访问控制符</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">private(私人的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">abstract(抽象的)</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">strictfp</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">synchronized(同步的)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">native</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">transient(短暂的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">volatile(不稳定的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table></div>
<p>包访问控制符是一个特殊的修饰符，不用任何访问控制符的就是包访问控制符。对于初始化块和局部成员而言，他们不能使用任何访问控制符，所以看起来像包访问控制符。</p>
<p>strictfp关键字的含义是FP-strict，也就是精确浮点的意思。</p>
<p>native 关键字主要用于修饰一个方法，使用native修饰的方法类似于一个抽象方法。与抽象方法不同的是，native方法通常采用C语言来实现。如果某个方法需要利用平台的相关特性，或者访问系统引荐等，则可以使用native修饰该方法，再把该方法交给C去实现。</p>
<p>Java中的四个访问控制符权限从高到低分别为private、protected、包访问权限和private。四个访问控制符是互斥的，最多只能出现一个，不仅如初，abstract和final永远不能同时使用；abstract和static不能同时修饰方法，可以同时修饰内部类；abstract和private不能同时修饰方法，可以同时修饰内部类。由于private修饰的方法不可能被子类重写，因此使用final修饰没什么意义。</p>

        <h2 id="6-12-多版本JAR包"   >
          <a href="#6-12-多版本JAR包" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-12-多版本JAR包" class="headerlink" title="6.12 多版本JAR包"></a>6.12 多版本JAR包</h2>
      <p>JAR文件的全称是Java Archive File，<small>（是一种与平台无关的文件格式，可将许多文件聚合为一个文件。可以将多个Java小程序及其必需的组件（.class文件，图像和声音）捆绑到JAR文件中，然后通过一次HTTP事务将其下载到浏览器中，从而大大提高了下载速度。JAR格式还支持压缩，从而减小了文件大小，从而进一步缩短了下载时间。此外，小程序作者可以对JAR文件中的各个条目进行数字签名，以验证其来源。它是完全可扩展的。）</small>&gt;意思就是Java档案文件。通常JAR文件是一种压缩文件，与常见的ZIP压缩文件兼容，通常也被称为JRA包，在JAR文件中默认包含了一个名为META-INF&#x2F;MANIFEST.MF的清单文件，这个清单文件是在生成JAR文件时由系统自动创建的。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E6%B3%9B%E5%9E%8B/">《疯狂Java讲义——泛型》</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="第九章-泛型"   >
          <a href="#第九章-泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#第九章-泛型" class="headerlink" title="第九章 泛型"></a>第九章 泛型</h1>
      
        <h2 id="9-1-泛型入门"   >
          <a href="#9-1-泛型入门" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-1-泛型入门" class="headerlink" title="9.1 泛型入门"></a>9.1 泛型入门</h2>
      <p>Java有个缺点——把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）。</p>

        <h3 id="9-1-1-编译时不检查类型的异常"   >
          <a href="#9-1-1-编译时不检查类型的异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-1-1-编译时不检查类型的异常" class="headerlink" title="9.1.1 编译时不检查类型的异常"></a>9.1.1 编译时不检查类型的异常</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListErr</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个只想保存字符串的List集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">strList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		strList.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		不小心把一个Integer对象丢进了集合</span></span><br><span class="line">		strList.add(<span class="number">5</span>);</span><br><span class="line">		strList.forEach(str-&gt;System.out.println(((String)str).length()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="9-1-2-使用泛型"   >
          <a href="#9-1-2-使用泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-1-2-使用泛型" class="headerlink" title="9.1.2 使用泛型"></a>9.1.2 使用泛型</h3>
      <p>Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，例如前面看到的List<String>，这表明该List只能保存字符串类型的对象。Java的参数哈类型被称为泛型。（Generic）</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericList</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个只想保存字符串的List集合</span></span><br><span class="line">		List&lt;String&gt;strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//1</span></span><br><span class="line">		strList.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		下面代码将编译错误</span></span><br><span class="line"><span class="comment">//		strList.add(5);//2</span></span><br><span class="line">		strList.forEach(str-&gt;System.out.println(str.length()));<span class="comment">//3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序成果成果了一个特殊的List集合：strList，这个List集合只能保存字符串对象，不能保存其他类型的对象。创建这种特殊集合的方法时：在集合接口、类后增加尖括号，尖括号里放一个数据类型，即表示这个集合接口、集合类只能保存特定类的对象。注意1的类型说明，他指定strList不是一个任意类型的List，而是一个String类型的List，写作：List<String>。可以称List是带一个类型参数的泛型接口，在本例中，参数类型是String。在创建这个ArrayList对象时也指定了一个类型参数。</p>
<p>上面程序将在2编译异常，因为strList集合只能添加String对象，所以不能将Integer对象“丢进该集合”。</p>
<p>而且程序在3也不需要进行强制类型转换，因为strList集合可以“记住”它的所有集合元素都是String类型。</p>

        <h3 id="9-1-3-Java-9增强的“菱形”语法"   >
          <a href="#9-1-3-Java-9增强的“菱形”语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-1-3-Java-9增强的“菱形”语法" class="headerlink" title="9.1.3 Java 9增强的“菱形”语法"></a>9.1.3 Java 9增强的“菱形”语法</h3>
      <p>List<String>strList &#x3D; new ArrayList&#x3D;&#x3D;<String>&#x3D;&#x3D;();</p>
<p>在Java 7之后Java允许在构造器之后不需要带完整的泛型信息，只需要给出一堆尖括号即可&lt;&gt;，把这种语法称为“菱形”语法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiamondTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		Java自动推断出&lt;&gt;中应该是String</span></span><br><span class="line">		List&lt;String&gt; books = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		books.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		遍历books集合，集合元素就是String类型</span></span><br><span class="line">		books.forEach(ele-&gt;System.out.println(ele.length()));</span><br><span class="line"><span class="comment">//		Java自动推断出HashMap的&lt;&gt;应该是String，List&lt;String&gt;</span></span><br><span class="line">		Map&lt;String,List&lt;String&gt;&gt;schoolsInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//		Java自动推断出ArrayList的&lt;&gt;里的应该是String</span></span><br><span class="line">		List&lt;String&gt; schools = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		schools.add(<span class="string">&quot;需要剩下的&quot;</span>);</span><br><span class="line">		schools.add(<span class="string">&quot;系统请假了&quot;</span>);</span><br><span class="line">		schoolsInfo.put(<span class="string">&quot;孙悟空&quot;</span>, schools);</span><br><span class="line"><span class="comment">//		遍历Map时，Map的key是String类型，value是List&lt;String&gt;类型</span></span><br><span class="line">		schoolsInfo.forEach((key,value)-&gt;System.out.println((key+<span class="string">&quot;--&gt;&quot;</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Java 9 再次增强了“菱形”语法，他甚至允许在创建匿名内部类时使用了菱形语法，Java可以根据上下文来推断匿名内部类中泛型的类型。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnniymousDiamond</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		指定Foo类中泛型为String</span></span><br><span class="line">		Foo&lt;String&gt; f = <span class="keyword">new</span> <span class="title class_">Foo</span>&lt;&gt;()<span class="comment">//粗</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String t)</span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test方法的t参数为：&quot;</span>+t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"><span class="comment">//		使用泛型通配符，此时相当于通配符的上限为Object</span></span><br><span class="line">		Foo&lt;?&gt; fo = <span class="keyword">new</span> <span class="title class_">Foo</span>&lt;&gt;()<span class="comment">//粗</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			指定Foo类中泛型为Object</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Object t)</span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test方法的Object参数为：&quot;</span>+t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Foo&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; fn = <span class="keyword">new</span> <span class="title class_">Foo</span>&lt;&gt;() <span class="comment">//粗</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			此时的test()方法的参数类型是Number</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Number t)</span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;test方法的Number参数为：&quot;</span>+t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上满程序先定义了一个带泛型声明的接口，接下来三行粗代码分别示范了再匿名内部类中使用菱形语法。</p>
<p>第一行粗声明变量是明确的将泛型指定为String类型，因此在该匿名内部类中T类型就是String类型；</p>
<p>第二行声明变量是使用通配符来代表泛型（相当于通配符的上限为Object），因此系统只能推断出T代表Object，所以在匿名内部类中T类型就代表了Object；</p>
<p>第三行声明变量时使用了带上限（上限是Number）的通配符，因此系统可以推断出T代表Number类。</p>
<p>无论哪种方式，Java都允许在使用匿名内部类时使用菱形语法。</p>

        <h2 id="9-2-深入泛型"   >
          <a href="#9-2-深入泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-2-深入泛型" class="headerlink" title="9.2 深入泛型"></a>9.2 深入泛型</h2>
      <p>所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参（或叫泛型）将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为类型实参）。Java 5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参，这就是在前面程序中看到的List<String>和ArrayList<String>两种类型。</p>

        <h3 id="9-2-1-定义泛型接口、类"   >
          <a href="#9-2-1-定义泛型接口、类" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-2-1-定义泛型接口、类" class="headerlink" title="9.2.1 定义泛型接口、类"></a>9.2.1 定义泛型接口、类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口时指定了一个泛型形参、该形参名为E</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt;<span class="comment">//1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在接口里，E可以作为类型使用</span></span><br><span class="line">	<span class="comment">//下面方法可以使用E作为参数类型</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E x)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义接口时指定了一个泛型形参、该形参名为E</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt;<span class="comment">//2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口里，E可以作为类型使用</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hashNext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义该接口时指定了两个泛型参数，其形参名为K、V</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;<span class="comment">//3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口里，K,V可以作为类型使用</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span></span><br><span class="line">        V <span class="title function_">put</span><span class="params">(K key,V value)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面三个接口声明是比较简单的，除了尖括号中的内容——这就是泛型的实质；允许在定义接口、类时使用声明泛型形参，泛型形参在整个接口、类体内可以当成类型适应，几乎所有普通类型的地方都可以使用这种泛型形参。</p>
<p>除此之外，1 2处方法声明返回值类型是Iterator<E>，Set<k>,这表明Set<k>形式是一种特殊的数据类型，是一种与Set不同的数据类型——可以认为是Set类型的子类。</p>
<p>例如使用List类型时，如果E形参传入String类型实参，则产生了一个新的类型：List<String>类型，可以吧List<String>想象成E被全部替换成String的特殊List子接口。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List&lt;String&gt;等同于如下接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListString</span> <span class="keyword">extends</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//原来的E形参全部变成String类型实参</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String x)</span>;</span><br><span class="line">    Iterator&lt;String&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过这种方式，就解决了9.1.2节中的问题——虽然程序只定义了一个List<E>接口，但实际使用时，可以产生无数个List接口，只要E传入不同的类型实参，系统就会多出一个新的List子接口。必须指出的是：List<String>绝不会被替换成ListString，西永没有进行源代码复制，二进制代码中没有，磁盘中么有，内存中没有。</p>
<p>注意：包含泛型声明的类型可以再定义变量、创建对象时传入一个类型实参，从而可以动态地生成无数多个逻辑上的子类，但这种子类在物理上并不存在。</p>
<p>可以为任何类、接口增加泛型声明（并不是只有集合类才可以使用泛型声明，虽然集合类是泛型的重要使用场合）。下面自定义了一个Apple类，这个Apple类就可以包含一个泛型声明。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Apple类时使用了泛型声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	使用了T类型定义实例类型</span></span><br><span class="line">	<span class="keyword">private</span> T info;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">//	下面方法使用T类型来定义构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(T info)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(T info)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getInfo</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		由于传给T形参的是String，所以构造器参数只能是String</span></span><br><span class="line">		Apple&lt;String&gt; a1 = <span class="keyword">new</span> <span class="title class_">Apple</span>&lt;&gt;(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">		System.out.println(a1.getInfo());</span><br><span class="line"><span class="comment">//		由于传给T形参的是Double，所以构造器参数只能Double或doule</span></span><br><span class="line">		Apple&lt;Double&gt; a2 = <span class="keyword">new</span> <span class="title class_">Apple</span>&lt;&gt;(<span class="number">5.67</span>);</span><br><span class="line">		System.out.println(a2.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>面程序定义了一个带泛型声明的Apple<T>类（不要理会这个泛型形参是否既有实际意义）只用Apple<T>类就可为T形参传入实际类型，这样就可以生成如Apple<String>、Apple<Double>…..形式的多个逻辑子类，物理上并不存在。这就是9.1可以使用List<String>、ArrayList<String>等类型的原因——JDK在定义List、ArrayList等接口、类时使用了泛型声明，所以在使用这些类时为之传入了实际的类型参数。</p>
<p>注意：当创建带泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型说明。例如，为Apple<T>类定义构造器，其构造器名依然是Apple，而不是Apple<T>!调用该构造器时却可以使用Apple<T>的形式，当然应该为T形参传入实际的类型参数。Java 7提供了“菱形”语法，允许省略&lt;&gt;中的类型实参。</p>

        <h3 id="9-2-2-从泛型类派生子类"   >
          <a href="#9-2-2-从泛型类派生子类" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-2-2-从泛型类派生子类" class="headerlink" title="9.2.2 从泛型类派生子类"></a>9.2.2 从泛型类派生子类</h3>
      <p>当创建了带泛型的声明的接口、父类之后，可以为该接口创建实现类，或从该父类中派生子类，需要指出的是：当使用了这些接口、父类时不能再包含泛型形参。下面是错误的</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类A继承Apple类，Apple类不能跟泛型形参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Apple</span>&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>方法中的形参代表变量、常量、表达式等数据，本书把它们直接称为形参，或称为数据形参。定义方法时可以声明数据形参，调用方法（使用方法）时必须为这些数据形参传入实际的数据；于此类似的是，定义类，接口，方法时可以声明泛型形参，使用类、接口、方法时应该为该泛型形参传入实际的类型。</p>
<p>如果想给Apple派生子类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Apple类时为T形参传入String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Apple</span>&lt;String&gt;</span><br></pre></td></tr></table></div></figure>

<p>调用方法时必须为所有的数据形参传入参数值，与调用方法不同的是，使用类、接口时，也可以不为泛型形参传入实际的类型参数。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Apple类时，没有为T类型传入实际的类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Apple</span></span><br></pre></td></tr></table></div></figure>

<p>像这种使用Apple类时省略泛型的形式被称为原始类型（raw type）。</p>
<p>如果从Apple<String>类派生子类，则Apple中所有使用T类型的地方都将被替换成String类型，即它的子类将会继承到String getInfo()和void setInfo(String info)两个方法，如果子类需要重写父类的方法，就必须注意这一点。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A1</span> <span class="keyword">extends</span> <span class="title class_">Apple</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	正确的重写父类的方法</span></span><br><span class="line"><span class="comment">//	其返回值与父类Apple&lt;String&gt;的返回值完全相同</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;子类&quot;</span> + <span class="built_in">super</span>.getInfo();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	下面方法时错误的，重写父类方法时返回值类型不一致</span></span><br><span class="line"><span class="comment">//	public Object getInfo()</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		return &quot;子类&quot;;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果使用Apple类没有传入实际的类型（即使用原始类型），Java编译器可能发出警告：使用了未经检查或不安全的操作——这就是泛型检查的警告，读者在前一章中应该多次看到这样的警告，如果希望该警告提示的更详细的信息</p>

        <h2 id="9-2-3-并不存在泛型类"   >
          <a href="#9-2-3-并不存在泛型类" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-2-3-并不存在泛型类" class="headerlink" title="9.2.3 并不存在泛型类"></a>9.2.3 并不存在泛型类</h2>
      <p>前面提到可以把ArrayList<String>类当成ArrayList的子类，事实上，ArrayList<String>类也确实像一种特殊的ArrayList类：该ArrayList<String>对象作为集合元素。但实际上，系统并没有为ArrayList<String>生成class文件，而且也不会吧ArrayList<String>当成新类处理。</p>

        <h2 id="9-3-类型通配符"   >
          <a href="#9-3-类型通配符" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-3-类型通配符" class="headerlink" title="9.3 类型通配符"></a>9.3 类型通配符</h2>
      <p>当使用一个泛型类时（包括声明变量和创建对象两种情况），都应该为这个泛型类传入一个类型实参。如果没有传入类型实际参数，编译器就会提出泛型警告。假设现在需要定义一个方法，该方法里有一个集合形参，集合形参的元素类型是不确定的，该怎么定义?</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;c.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(c.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用List接口时，没有传入实际类型参数，这将引起泛型警告。谓词，考虑为List接口传入实际的类型参数——因为List集合里的元素类型是不确定的，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;Object&gt; c)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;c.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(c.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>与数组进行对比，先看一下数组是如何工作的。在数组中，程序可以直接把一个Integer[]数组赋给一个Number[]变量。如果试图把一个Double对象</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E5%90%88/">《疯狂Java讲义——集合》</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="第8章-集合"   >
          <a href="#第8章-集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#第8章-集合" class="headerlink" title="第8章 集合"></a>第8章 集合</h1>
      <p>Java集合类是一种特别有用的工具类，可用于存储数量等的对象，并可以实现常用的数据结构  如栈、队列等。除此之外，Java集合还可用于保存具有映射关系的关联数组。<strong>Java集合大致可分为Set、List、Qucue和Map四种体系</strong>，其中Set代表无序，不可重复的集合；List代表有序、重复的集合；Map则代表具有映射关系的集合， Java 5又增加了 Queue 体系集合，代表一种队列集合实现。</p>
<p>而Java集合就像一种容器，可以把多个对象(实际上是对象的引用，但习惯上都称对象)“丢进”  容器中。在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object类型  处理：从Java5增加了泛型以后，Java集合可以记住容器中对象的数据类型，从而可以编写出更简洁、  健壮的代码。本章不会介绍泛型的知识，本章重点介绍Java的4种集合体系的功能和用法。本章将详细介绍Java的4种集合体系的常规功能，深入介绍各集合实现类所提供的独特功能，深入分析各实现类的实现机制，以及用法上的细微差别，并给出不同应用场景选择哪种集合实现类的建议。</p>

        <h2 id="8-1-Java集合概述"   >
          <a href="#8-1-Java集合概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-1-Java集合概述" class="headerlink" title="8.1 Java集合概述"></a>8.1 Java集合概述</h2>
      <p>在编程时，常常需要集中存放多个数据，例如第6章练习题中梭哈游戏里剩下的牌。可以使用数组来保存多个对象，但数组长度不可变化，一旦在初始化数组时指定了数组长度，这个数组长度就是不可变的，如果需要保存数量变化的数据，数组就有点无能为力了；而且数组无法保存具有映射关系的数据，  如成绩表：语文一79,数学一80,这种数据看上去像两个数组，但这两个数组的元素之间有一定的关联关系。</p>
<p>为了保存数量不确定的数据，以及保存具有映关系的数据(也被称为关联数组),Java提供了集合类。集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所有的集合类都位于 Java. util  包下，后来为了处理多线程环境下的并发安全问题，Java 5 还在 java.util.concurrent f包下提供了一些多线程支持的集合类。</p>
<p>集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象(实际上保存的是对象的引用变量)；而集合里只能保存对象(实际上只是保存对的引用变量，但通常习惯上认为集合里保存的是对象)。</p>
<p>Java的集合类主要由两个接口派生而出：Collection 和Map，Collection和Map是集合框架的跟接口，这两个接口又包括了一些子接口或实现类。</p>
<p>Collection接口、子接口及其实现类的继承树。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Collection&lt;--Set</span><br><span class="line">Collection&lt;--Queue</span><br><span class="line">Collection&lt;--List</span><br><span class="line">Set&lt;--EnumSet</span><br><span class="line">Set&lt;--SortedSet</span><br><span class="line">Set&lt;--HashSet</span><br><span class="line">SortedSet&lt;--TreeSet</span><br><span class="line">HashSet&lt;--LinedHashSet</span><br><span class="line">Queue&lt;--Deque</span><br><span class="line">Queue&lt;--PriortyQueue</span><br><span class="line">Deque&lt;--ArrayDeque</span><br><span class="line">List&lt;--LinkedList</span><br><span class="line">Deque&lt;--LinkedList</span><br><span class="line">List&lt;--ArrayList</span><br><span class="line">List&lt;--Vector</span><br><span class="line">Vector&lt;--Stack</span><br></pre></td></tr></table></div></figure>

<p>Set和List是Collection派生出来的两个子类，Set代表无序集合，元素不能重复；List代表有序集合，元素可以重复。Queue是Java提供的队列实现，有点类似与List。</p>
<p>Map继承树，所有的Map实现类用于保存具有映射关系的数据（关联数组）。</p>
<p>Map类保存的每项数据都是key-value对，其中key是不可重复的，key用于标识鞂里的每项数据，如果需要查阅Map中的数据时，总是根据Map的key来获取。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Map&lt;--EnumMap</span><br><span class="line">Map&lt;--IdentityHashMap</span><br><span class="line">Map&lt;--HashMap</span><br><span class="line">Map&lt;--Hashtable</span><br><span class="line">Map&lt;--SortedMap</span><br><span class="line">Map&lt;--WeakHashMap</span><br><span class="line">HashMap&lt;--LinedHashMap</span><br><span class="line">Hashtable&lt;--Properties</span><br><span class="line">SortedMap&lt;--TreeMap</span><br></pre></td></tr></table></div></figure>

<p>Set像一个罐子，把一个对象添加到Set时，无法记住添加这个元素的顺序，所以Set里的元素不能重复。访问时也只能通过元素本身访问；List像一个数组，他可以记住每次添加元素的顺序、而且List的长度是可变的。所以访问List集合中的元素时可以根据元素的索引来访问；Map集合也像一个罐子，只是它里面的每项数据都是由两个值组成的，可以根据每项元素的key来访问其value。</p>
<p>![](C:\Program Files\Typora\image\630ec9edb4bca6cd4e84e5c8efd5ec2.jpg)</p>

        <h2 id="8-2-Java-11新增的-Collection-和-Iterator接口"   >
          <a href="#8-2-Java-11新增的-Collection-和-Iterator接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-Java-11新增的-Collection-和-Iterator接口" class="headerlink" title="8.2 Java 11新增的 Collection 和 Iterator接口"></a>8.2 Java 11新增的 Collection 和 Iterator接口</h2>
      <p>集合器就像容器，现实生活中容器的功能，无非就是添加对象、删除对象、清空容器、判断容器是否为空等，集合类就为这些功能提供了对应的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">List</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//		添加元素</span></span><br><span class="line">		c.add(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line"><span class="comment">//		虽然集合不允许放基本类型的值，但Java支持自动装箱</span></span><br><span class="line">		c.add(<span class="number">6</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;C集合的元素个数为：&quot;</span>+c.size());</span><br><span class="line"><span class="comment">//		删除指定元素,1表示索引</span></span><br><span class="line">		c.remove(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;C集合的元素个数为：&quot;</span>+c.size());</span><br><span class="line"><span class="comment">//		判断是否包含指定字符串</span></span><br><span class="line">		System.out.println(<span class="string">&quot;c集合是包含\&quot;孙悟空\&quot;字符串:&quot;</span>+c.contains(<span class="string">&quot;孙悟空&quot;</span>));</span><br><span class="line">		c.add(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;c集合的元素：&quot;</span>+c);</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;EE 企业级开发&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;c中是否完全包含books&quot;</span>+c.containsAll(books));</span><br><span class="line"><span class="comment">//		用c集合减去Books集合的元素</span></span><br><span class="line">		c.removeAll(books);</span><br><span class="line">		System.out.println(c);</span><br><span class="line">		c.clear();</span><br><span class="line">		System.out.println(c);</span><br><span class="line"><span class="comment">//		retainAll(c)：从集合中删除集合c中不包含的元素</span></span><br><span class="line"><span class="comment">//		控制books集合里只剩下c集合里也包含的元素</span></span><br><span class="line">		books.retainAll(c);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Java 11为Collection新增了一个toArray(IntFunction)方法，使用该方法的主要谜底就是利用泛型。对于传统的toArray()方法而言，不管Collection本身是否使用泛型，toArray()的返回值总是Object[]；但新增的toArray()方法而言，不管Collection本身是否使用泛型，toArray()的返回值总是Object[]；但是新增的方法不同，当集合使用反形式可以返回特定类型的数组。</p>

        <h3 id="8-2-1-使用Lambda表达式遍历集合"   >
          <a href="#8-2-1-使用Lambda表达式遍历集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-1-使用Lambda表达式遍历集合" class="headerlink" title="8.2.1 使用Lambda表达式遍历集合"></a>8.2.1 使用Lambda表达式遍历集合</h3>
      <p>Java 8 为Iterable接口新增了一个forEach默认方法，该方法所需参数的类型是一个函数式接口，而Iterable接口是Collection接口的父接口，因此Collection集合特可以直接调用该方法。</p>
<p>当程序调用 Iterable 的 forEach(Consumer action) 遍历集合元素时，程序会一次将集合元素传给Consumer的	accept(T t)方法（该接口中惟一的抽象方法）。正因为Consumer是函数式接口，因此可以使用Lambda表大会来遍历集合元素。</p>
<p>如下程序示范了使用Lambda表达式来遍历集合元素：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionEach</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		调用forEach()方法遍历集合</span></span><br><span class="line">		books.forEach(obj -&gt; System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));<span class="comment">//粗</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>粗调用了Iterable的forEach()默认方法来遍历数组，传给方法的是一个Lambdm表达式，该Lambda表达式的目标类型是Consumer。forEach方法会自动将集合元素逐个传给Lambda表达式的形参，这样Lambda表达式的代码体即可遍历到集合元素了。</p>

        <h3 id="8-2-2-使用-Iterator-遍历集合元素"   >
          <a href="#8-2-2-使用-Iterator-遍历集合元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-2-使用-Iterator-遍历集合元素" class="headerlink" title="8.2.2 使用 Iterator 遍历集合元素"></a>8.2.2 使用 Iterator 遍历集合元素</h3>
      <p>Iterator主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		获取books集合对应的迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> books.iterator();</span><br><span class="line"><span class="comment">//		如果集合中还有剩下的元素，返回ture</span></span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			it.next()方法返回的数据类型是Object类型，因此需要强制类型转换</span></span><br><span class="line"><span class="comment">//			next:返回迭代中的下一个元素</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">book</span> <span class="operator">=</span> (String)it.next();</span><br><span class="line">			System.out.println(book);</span><br><span class="line"><span class="comment">//			equals():将此字符串与指定的对象进行比较。</span></span><br><span class="line"><span class="comment">//			当且仅当参数不为空且是表示与此对象相同字符序列的字符串对象时，结果为真。</span></span><br><span class="line">			<span class="keyword">if</span>(book.equals(<span class="string">&quot;疯狂Java讲义&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				从集合中删除上一次next()方法返回的元素</span></span><br><span class="line">				it.remove();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			对book变量赋值，不会影响集合元素本身</span></span><br><span class="line">			book = <span class="string">&quot;测试字符串&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上可以看出，Iterator本身并不提供承装对象的能力，如果需要创建Iterator对象，则必须有一个被迭代的集合。没有集合的Iterator仿佛无本之木，没有存在的价值。</p>
<p>使用Iterator迭代过程中不可修改集合元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorErrorrTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂 Android 讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		获取books集合对应的迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> books.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">book</span> <span class="operator">=</span> (String)it.next();</span><br><span class="line">			System.out.println(book);</span><br><span class="line">			<span class="keyword">if</span>(book.equals(<span class="string">&quot;疯狂 Android 讲义&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				使用Iterator迭代过程中不可修改集合元素，下面代码将引发异常</span></span><br><span class="line">				books.remove(book);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中修改集合元素的代码位于Iterator迭代块内，也就是在Iterator迭代Collection集合过程中修改了Collection集合，所以程序将在运行时引发异常。</p>

        <h3 id="8-2-3-使用Lambda表达式遍历Iterator"   >
          <a href="#8-2-3-使用Lambda表达式遍历Iterator" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-3-使用Lambda表达式遍历Iterator" class="headerlink" title="8.2.3 使用Lambda表达式遍历Iterator"></a>8.2.3 使用Lambda表达式遍历Iterator</h3>
      <p>forEachRemaining()方法所需的Consumer 参数同样也是函数式接口，当程序调用Iterator的forEachRemaining()遍历集合元素时，程序会依次将集合元素传给Consumer的accept(T t)方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteartorEach</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		使用forEachRemaining方法将形参（Lambda表达式）传入封装的HasNext和Nest方法</span></span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂 Android 讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		获取books集合对应的迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> books.iterator();</span><br><span class="line"><span class="comment">//		使用Lambda表达式（目标类型是Comsumer）来遍历集合数组</span></span><br><span class="line">		it.forEachRemaining(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="8-2-4-使用foreach循环遍历集合元素"   >
          <a href="#8-2-4-使用foreach循环遍历集合元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-4-使用foreach循环遍历集合元素" class="headerlink" title="8.2.4 使用foreach循环遍历集合元素"></a>8.2.4 使用foreach循环遍历集合元素</h3>
      <p>​	foreach循环迭代访问集合元素更加便捷。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeachTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂 Android 讲义&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> obj:books)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			此处的book变量也不是集合元素本身</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">book</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">			System.out.println(book);</span><br><span class="line">			<span class="keyword">if</span>(book.equals(<span class="string">&quot;疯狂 Android 讲义&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				下面代码会引发异常</span></span><br><span class="line">				books.remove(book);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>foreach循环中的迭代变量也不是集合元素本省，系统知识依次把集合元素的值赋给迭代元素，因此在foreach循环中修改迭代元素的值也没有任何实际意义。</p>
<p>同样当使用foreach循环迭代访问集合元素的时候，该集合也不可以被修改，否则会引发ConcurrentModificationException异常。</p>

        <h3 id="8-2-5-使用Predicate操作集合"   >
          <a href="#8-2-5-使用Predicate操作集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-5-使用Predicate操作集合" class="headerlink" title="8.2.5 使用Predicate操作集合"></a>8.2.5 使用Predicate操作集合</h3>
      <p>在Collection集合新增看一个removerIF(Predicate filter)方法，该方法会批量删除符合filter条件的所有元素。该方法需要一个Predicate（谓词）对象作为参数，Predicate也是函数式接口，因此可使用Lambda表达式作为参数。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Ajax讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		使用Lambda表达式（目标类型是Predicate）过滤集合</span></span><br><span class="line">		books.removeIf(ele-&gt;((String)ele).length()&lt;<span class="number">10</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Ajax讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		统计书名中包含“疯狂”子串的图书数量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;书名中包含“疯狂”子串的图书数量:&quot;</span>+calAll(books,ele-&gt;((String)ele).contains(<span class="string">&quot;疯狂&quot;</span>)));</span><br><span class="line"><span class="comment">//		统计书名中包含“Java”子串的图书数量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;名中包含“Java”子串的图书数量:&quot;</span>+calAll(books,ele-&gt;((String)ele).contains(<span class="string">&quot;Java&quot;</span>)));</span><br><span class="line"><span class="comment">//		统计书名字符串长度大于10的图书数量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;书名字符串长度大于10的图书数量:&quot;</span>+calAll(books,ele-&gt;((String)ele).length()&gt;<span class="number">10</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calAll</span><span class="params">(Collection books, Predicate p)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> obj:books)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			使用Predicate的test()方法判断该对象是否满足Predicate指定的条件</span></span><br><span class="line">			<span class="keyword">if</span>(p.test(obj))</span><br><span class="line">			&#123;</span><br><span class="line">				total++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序先定义了一个calAll()方法，该方法将会使用Predicate判断每个集合元素是否符合特定的条件——该条件将通过Predicate参数动态传入，冲上面程序中三行粗体字可以看到，程序传入三个Lambda表达式（其目标类型都是Predicate），这样calAll()方法就智慧统计满足Predicate的图书。</p>

        <h3 id="8-2-6-使用Stream操作集合"   >
          <a href="#8-2-6-使用Stream操作集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-6-使用Stream操作集合" class="headerlink" title="8.2.6 使用Stream操作集合"></a>8.2.6 使用Stream操作集合</h3>
      <p>先跳过</p>

        <h2 id="8-3-Set集合"   >
          <a href="#8-3-Set集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-Set集合" class="headerlink" title="8.3 Set集合"></a>8.3 Set集合</h2>
      <p>它类似与一个罐子，程序可以依次把多个对象“丢进”Set集合中，而Set集合通常不能记住元素的添加顺序。Set集合与Collection基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。</p>
<p>如果试图把两个相同的元素加到Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。</p>

        <h3 id="8-3-1-HashSet类"   >
          <a href="#8-3-1-HashSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-1-HashSet类" class="headerlink" title="8.3.1 HashSet类"></a>8.3.1 HashSet类</h3>
      <p>HashSet是Set接口的典型实现，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来储存集合中的元素，因此具有横好的存取和查找功能。</p>
<p>HashSet具有以下特点</p>
<ul>
<li>不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。</li>
<li>HashSet不是同步的，如果多个线程同时访问一个 HashSet，假设有两个或者两个以上线程同时修改了 HashSet集合时，则必须通过代码来保证其同步。</li>
<li>集合元素值可以是null。</li>
</ul>
<p>当向 HashSet集合中存入一个元素时， HashSet会调该对象的 hashCode()方法来得到该对象的   hashCode 值，然后根据该 hashCode值决定该对象在 HashSet 中的存储位置。如果有两个元素通过 equals  方法比较返回true,但它们的 hashCode()方法返回值不相等， HashSet将会把它们存储在不同的位置，  依然可以添加成功。也就是说， HashSet集合判断两个元素相等的标准是两个对象通过 equals方法比较相等，并且两个对象的hashCodet方法返回值也相等  下面程序分别提供了三个类A、B和C,它们分别重写了 equals()、 hashCode()两个方法的一个或全部，通过此程序可以让读者看到 HashSet判断集合元素相同的标准。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>以上程序分别添加了两个A两个B两个C，但是其中C同时重写了hashCode方法和equals方法，所以导致HashSet把两个C对象当成了一个对象。</p>
<p>![image-20210413181200991](C:\Program Files\Typora\image\image-20210413181200991.png)</p>
<p>由此可见：当一个对象放进HashSet中时，如果需要重写该对象对应类的equals方法，则也应该重写hashCode（）方法。规则是：如果两个对象通过equals()方法比较返回true，这两个对象的hashCode值也应该相等。</p>
<p>&#x3D;&#x3D;如果两个对象通过 equals方法比较返回true,但这两个对象的hashCode方法返回不同的 hashCode  值时，这将导致 HashSet会把这两个对象保存在Hash表的不同位置，从而使两个对象都可以添加成功，这就与Set集合的规则冲突了。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;如果两个对象的 hashCode方法返回的 hashCode值相同，但它们通过 equals方法比较返回 false  时将更麻烦：因为两个对象的 hashCode值相同， HashSet试图把它们保存在同一个位置，但又不行(否则将只剩下一个对象),所以实际上会在这个位置用链式结构来保存多个对象；而 HashSet访问集合元素时也是根据元素的 hashCode值来快速定位的，如果 HashSet中两个以上的元素具有相同的 hashCode 值，将会导致性能下降。&#x3D;&#x3D;</p>
<p>注意：如果需要把某个类的对象保存到 HashSet集合中，重写这个类的 equals 方法和 hashCode 方法时，应该尽量保证两个对象通过 equals 方法比较返回true时，它们的 hashCode 方法返回值也相等。</p>
<p>HashSet中每个能存储元素的“槽位”(slot)通常称为“桶”( bucket),如果有多个元素的 hashCode值相同，但它们通过equals方法比较返回 false,就需要在一个“桶”里放多个元素，这样会导致性能下降。</p>
<p>前面介绍了 hashCode方法对于 HashSet的重要性，实际上，对象的 hashCode 值对于后面的 HashMap同样重要，下面给出重写 hashCode方法的基本规则。</p>
<ul>
<li>在程序运行过程中，同一个对象多次调用 hashCode方法应该返回相同的值。</li>
<li>当两个对象通过 equals方法比较返回true时，这两个对象的 hashCode方法应返回相等的值。</li>
<li>对象中用作 equals方法比较标准的实例变量，都应该用于计算 hashCode值。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">R</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;R[count:&quot;</span>+count+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == R.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (R)obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.count == r.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">5</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">3</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">9</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">2</span>));</span><br><span class="line"><span class="comment">//		打印HashSet集合，集合元素没有重复</span></span><br><span class="line">		System.out.println(hs);</span><br><span class="line"><span class="comment">//		取出第一个元素</span></span><br><span class="line"><span class="comment">//		iterator()：返回该集合中所有元素的迭代器。元素的返回没有特定的顺序。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> hs.iterator();</span><br><span class="line">		<span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> (R) it.next();</span><br><span class="line"><span class="comment">//		为第一个元素的count实例变量赋值</span></span><br><span class="line">		first.count = -<span class="number">3</span>;<span class="comment">//①</span></span><br><span class="line"><span class="comment">//		再次输出HashSet集合，集合中有元素重复</span></span><br><span class="line">		System.out.println(hs);</span><br><span class="line"><span class="comment">//		删除count为-3的R对象</span></span><br><span class="line">		hs.remove(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">3</span>));</span><br><span class="line"><span class="comment">//		可以看到被删除了一个R元素</span></span><br><span class="line">		System.out.println(hs);</span><br><span class="line">		System.out.println(<span class="string">&quot;hs是否包含count为-3的R对象？&quot;</span></span><br><span class="line">				+hs.contains(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">3</span>)));</span><br><span class="line">		System.out.println(<span class="string">&quot;hs是否包含count为-2的R对象&quot;</span></span><br><span class="line">				+hs.contains(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">2</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面提供了R类，R类重写了equals(Object obj)方法和hashCode()方法，这两个方法的都是根据R对象的count实例变量来判断的。上面程序①改变了Set集合中第一个R对象的count实例变量值，这导致R对象以集合中的其他R对象相同。</p>
<p>![image-20210413220840853](C:\Program Files\Typora\image\image-20210413220840853.png)</p>
<p>此时的Set集合已经有些混乱，当试图删除count为-3的R对象时，HashSet会计算出该对象的hashCode值，从而找到该对象在集合中的保存位置，然后把此处的对象与count为-3的R对象通过实际上保存在count为-2的R对象进行比较，如果相等则删除该对象——HashSet只有第二个元素才满足该条件（第一个元素实际保存在count为-2的位置上）所以第二个元素被删除。至于第一个count值为-3的R对象，它保存在count为-2的R对象对应位置上，但使用equals()方法拿他和count为-2的对象比较时又返回false——这导致HashSet不能精准访问该元素。</p>
<p>所以程序把可变对象添加到HashSet中之后，不要再去修改该集合元素中参与计算的hashCode()、equals()的实例变量，否则将会导致HashSet无法正确操作这些集合元素。</p>

        <h3 id="8-3-2-LinkedHashSet-类"   >
          <a href="#8-3-2-LinkedHashSet-类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-2-LinkedHashSet-类" class="headerlink" title="8.3.2 LinkedHashSet 类"></a>8.3.2 LinkedHashSet 类</h3>
      <p>HashSet的子类，LinkedHashSet集合也是根据元素的hashCode值来决定元素的储存位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素添加的顺序来访问集合里的元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">HashSet</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;轻量级java EE 企业应用实战&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">		books.remove(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> 虽然LinkedHashSet使用了链表记录集合元素的添加顺序，但是LinkedHashSet依然是HashSet，因此他依然不允许集合元素重复。</p>

        <h3 id="8-3-3-TreeSet类"   >
          <a href="#8-3-3-TreeSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-3-TreeSet类" class="headerlink" title="8.3.3 TreeSet类"></a>8.3.3 TreeSet类</h3>
      <p>是SortedSet接口的实现类，正如SortedSet所暗示的，TreeSet可以确保集合元素处于排序状态。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">		nums.add(<span class="number">5</span>);</span><br><span class="line">		nums.add(<span class="number">2</span>);</span><br><span class="line">		nums.add(<span class="number">10</span>);</span><br><span class="line">		nums.add(-<span class="number">9</span>);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		System.out.println(nums.first());</span><br><span class="line">		System.out.println(nums.last());</span><br><span class="line"><span class="comment">//		返回小于四的子集，不包含四</span></span><br><span class="line">		System.out.println(nums.headSet(<span class="number">4</span>));</span><br><span class="line"><span class="comment">//		返回大于5的子集，包含5</span></span><br><span class="line">		System.out.println(nums.tailSet(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//		返回大于等于-3，小于4的子集</span></span><br><span class="line">		System.out.println(nums.subSet(-<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>与HashSet集合采用hash算法来决定元素的储存位置不同，TreeeSet采用红黑树的数据结构来储存集合元素，TreeSet支持两种排序方法：自然排序和定制排序。默认情况自然排序。</p>

        <h4 id="1-自然排序"   >
          <a href="#1-自然排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-自然排序" class="headerlink" title="1.自然排序"></a>1.自然排序</h4>
      <p> TreeSet调用集合元素的 compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式就是自然排序。</p>
<p><strong>Java提供了一个 Comparable接口，该接口里定义了一个 compareTo(Object ob)方法，该方法返回个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。</strong>当一个对象调用该方法与另一个对象进行比较时，例：	obj1.compareTo(obj2),如果该方法返回0,则表明这两个对象相等：如果该方法返回一个正整数，则表明obj1大于obj2如果该方法返回一个负整数，则表明obj1小于obj2。</p>
<p>Java的一些常用类已经实现了 Comparable接口，并提供了比较大小的标准。下面是实现了Comparable接口的常用类。</p>
<ul>
<li>Biglnteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较。   </li>
<li>Character:按字符的 Unicode值进行比较。</li>
<li>Boolean : true对应的包装类实例大于 false对应的包装类实例。</li>
<li>String:依次比较字符串中每个字符的 Unicode 值。</li>
<li>Date、Time：后面的时间、日期比前面的时间、日期大。</li>
</ul>
<p>将对象添加到TreeSet时，该对象的类必须实现Comparabele接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Err</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetErrorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">TreeSet</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"><span class="comment">//		向TreeSet集合中添加两个Err对象</span></span><br><span class="line">        <span class="comment">//不实现就应发异常</span></span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Err</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210414143028408](C:\Program Files\Typora\image\image-20210414143028408.png)</p>
<p>还有一点必须指出：大部分类在实现 compareTo (Object obj)方法时，都需要将被比较对象obj强类型转换成相同类型，因为只有相同类的两个实例才会比较大小。当试图把一个对象添加到TreeSet集合时， TreeSet会调用该对象的 compareTo( Object obj)方法与集合中的其他元素进行比较——这就要求集合中的其他元素与该元素是同一个类的实例。也就是说，向TeetSet中添加的应该是同一个类的对象，否则也会引发 Class CastException异常。如下程序示范了这个错误。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetErrorTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"><span class="comment">//		向TreeSet集合中添加两个对象</span></span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//①</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序先向TreeSet集合中添加了一个字符串对象，这个操作完全正常。当添加第二个Date对象时， TreeSet就会调用该对象的 compareTo(Object obj)方法与集合中的其他元素进行比较，Date对象的 compareTo(Object obj)方法无法与字符串对象比大小，所以上面程序将在①号代码处引发异常。</p>
<p>如果向 TreeSet中添加的对象是程序员自定义类的对象，则可以向TreeSet中添加多种类型的对象，  前提是用户自定义类实现了 Comparable接口，且实现 compareTo( Object obj)方法没有进行强制类型转换，但当试图取出 TreeSet里的集合元素时，不同类型的元素依然可能发生 Class CastException异常。</p>
<p>注意：总结起来一句话：如果希望TreeSet能正常运作， TreeSet只能添加同一种类型的对象。</p>
<p>当把一个对象加入 TreeSet 集合中时， TreeSet调用该对象的compareTo(Object obj  )方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过 compare To(Object ob)  方法比较相等，新对象将无法添加到 TreeSet集合中。  对于 TreeSet集合而言，它判断两个对象是否相等的唯标准是：两个对象通过	compareTo(Object obj)方法比较是否返回0——如果通过compareTo(Object obj)方法比较返回0，TreeSet则会认为他们是相等；否则就会认为他们不相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Z</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写equals()方法，总是返回true</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写了compareTo(Object obj)方法，总是返回1</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">		<span class="type">var</span> <span class="variable">z1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Z</span>(<span class="number">6</span>);</span><br><span class="line">		set.add(z1);</span><br><span class="line"><span class="comment">//		第二次添加同一个对象，输出true，表明添加成功</span></span><br><span class="line">		System.out.println(set.add(z1));<span class="comment">//①</span></span><br><span class="line"><span class="comment">//		下面输出set集合，将看到有两个对象</span></span><br><span class="line">		System.out.println(set);</span><br><span class="line"><span class="comment">//		修改set集合的第一个元素的age变量</span></span><br><span class="line">		((Z)(set.first())).age = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//		输出set集合的最后一个元素的age变量，将看到也变成了9；</span></span><br><span class="line">		System.out.println(((Z)(set.last())).age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>程序中①号代码把同一个对象再次添加到TreeSet集合中，因为z1对象的compareTo(Object obj)方法总是返回1，虽然他的equals()方法总是返回true，但是TreeSet会认为z1对象和他自己相等，因此TreeSet可以添加两个z1对象。</p>
<p>实际上TreeSet保存的两个元素他们引用的是同一个对象。所以当修改TreeSet集合里第一个元素的age变量后，该TreeSet集合里的最后一个元素的age变量也随之改变。</p>
<p>向TreeSet添加可变变量后，可变变量改变后，可能会与其他对象的大小顺序发生改变，但TreeSet不会再次调整他们的顺序，甚至可能导致TreeSet中保存的这两个对象通过compareTo(Object obj)方法比较返回0。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R1</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">R1</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;R1[count:&quot;</span>+count+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写了equals()方法，根据count来判断是否相等</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == R1.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (R1) obj;</span><br><span class="line">			<span class="keyword">return</span> r.count == <span class="built_in">this</span>.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写comparTo()方法，根据count来比较大小</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (R1)obj;</span><br><span class="line">		<span class="keyword">return</span> count &gt; r.count?<span class="number">1</span>:</span><br><span class="line">			count&lt;r.count?-<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(<span class="number">5</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(-<span class="number">3</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(<span class="number">9</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(-<span class="number">2</span>));</span><br><span class="line"><span class="comment">//		打印TreeSet集合，集合元素时有序排列的</span></span><br><span class="line">		System.out.println(ts);<span class="comment">//①</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> (R1)ts.first();</span><br><span class="line"><span class="comment">//		对第一个元素的count赋值</span></span><br><span class="line">		first.count = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//		取出最后一个元素</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">last</span> <span class="operator">=</span> (R1)ts.last();</span><br><span class="line"><span class="comment">//		对最后一个元素的count赋值，与第二个元素的count相同</span></span><br><span class="line">		last.count = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//		再次输出将看到TreeSet里的元素处于无序状态，且有重复元素</span></span><br><span class="line">		System.out.println(ts);<span class="comment">//②</span></span><br><span class="line"><span class="comment">//		删除实例变量被改的元素，删除失效</span></span><br><span class="line">		System.out.println(ts.remove(<span class="keyword">new</span> <span class="title class_">R1</span>(-<span class="number">2</span>)));<span class="comment">//③</span></span><br><span class="line">		System.out.println(ts);</span><br><span class="line"><span class="comment">//		删除实例变量没有改变的元素，删除成功</span></span><br><span class="line">		System.out.println(ts.remove(<span class="keyword">new</span> <span class="title class_">R1</span>(<span class="number">5</span>)));<span class="comment">//④</span></span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中的R对象对应的类正常重写了 equals方法和 compareTo方法，这两个方法都以R对象的 count 实例变量作为判断的依据。当程序执行①号代码时，看到程序输出的Set集合元素处于有序状态：<strong>因为R类是一个可变类，因此可以改变R对象的 count实例变量的值，程序通过粗体字代码改变了该集合里第一个元素和最后一个元素的count实例变量的值。</strong>当程序执行②号代码输出时，将看到该集合处于无序状态而且集合中包含了重复元素。</p>
<p>一旦改变了 TreeSet集合里可变元素的实例变量,当再试图删除该对象时, TreeSet也会删除失败(甚至集合中原有的、实例变量没被修改但与修改后元素相等的元素也无法删除),所以在上面程序的③号代码处,删除 count为2的R对象时,没有任何元素被删除;程序执行④号代码时,可以看到删除了 count为5的R对象,这表明<strong>TreeSet可以删除没有被修改实例变量、且不与其他被修改实例变量的对象重复的对象。</strong></p>
<p>注意：当执行了④号代码后，TreeSet会对集合中的元素重新索引(不是重新排序),接下来就可以删除 TreeSet中的所有元素了,包括那些被修改过实例变量的元素。与 HashSet类似的是,如果TreeSet中包含了可变对象,当可变对象的实例变量被修改时, TreeSet在处理这些对象时将非常复杂,而且容易出错。为了让程序更加健壮，推荐不要修改放入HashSet和 TreeSet集合中元素的关键实例变量。</p>

        <h4 id="2-定制排序"   >
          <a href="#2-定制排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-定制排序" class="headerlink" title="2.定制排序"></a>2.定制排序</h4>
      <p> TreeSet 的自然排序是根据集合元素的大小, TreeSet 它们以升序排列。如果需要实现定制排序，例如以降序排列,则可以通过 Comparator接口的帮助。该接口里包含一个 int compare(T o1,T o2)方法,该方法用于比较o1和o2的大小:如果该方法返回正整数,则表明o1大于o2;如果该方法返回0,则表明o等于o2,如果该方法返回负整数,则表明o1小于o2。</p>
<p>如果需要实现定制排序,则需要在创建 TreeSet合对象时,提供一个 Comparator对象与该 TreeSe集合关联,由该 Comparator对象负责集合元素的排序逻辑。由于 Comparator是一个函数式接口,因此可使用 Lambda表达式来代替 Comparator对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">M</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;M[age:&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		此处的Lambda表达式的目标类型是Comparator</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>((o1, o2) -&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">m1</span> <span class="operator">=</span> (M) o1;</span><br><span class="line">			<span class="type">var</span> <span class="variable">m2</span> <span class="operator">=</span> (M) o2;</span><br><span class="line">			<span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span> : m1.age &lt; m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(<span class="number">5</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(-<span class="number">3</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(<span class="number">9</span>));</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字代码使用了目标类型为 Comparator的 Lambda表达式,它负责ts集合的排序所以当把M对象添加到ts集合中时,无须M类 Comparable实现接口,因为此时 TreeSet无须通过l对象本身来比较大小,而是由与 TreeSet关联的 Lambda表达式来负责集合元素的排序。运行程序,看到如下运行结果:</p>
<p> [M [age: 9], M [age: 5], M [age: -3]</p>
<p>注意:当通过 Comparator对象(或 Lambda表达式)来实现 TreeSet的定制排序时,依然不可以向 TreeSet中添加类型不同的对象,否则会引发 ClassCastException异常。使用定制排序时, TreeSet对集合元素排序不管集合元素本身的大小,而是由 Comparator对象(或 LambdaTreeSet表达式)负责集合元素的排序规则。判断两个集合元素相等的标准是:通过Comparator(或 Lambda表达式)比较两个元素返回了0,这样TreeSet不会把第二个元素添加到集合中。</p>

        <h3 id="8-3-4-EnumSet类"   >
          <a href="#8-3-4-EnumSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-4-EnumSet类" class="headerlink" title="8.3.4 EnumSet类"></a>8.3.4 EnumSet类</h3>
      <p> EnumSet是一个专为枚举类设计的集合类, EnumSet中的所有元素都必须是指定枚举类型的枚举值，集合该枚举类型在创建 EnumSet时显式或隐式地指定。 EnumSet的集合元素也是有序的, EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。</p>
<p> EnumSet中的内部以位向量的形式存储,这种存储形式非常紧凑、高效，因此  EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作(如调用containsAll()和 retainAll()方法)时,如果其参数也是 EnumSet集合,则该批量操作的执行速度也非常快。</p>
<p> EnumSet集合不允许加入null元素,如果试图插入null元素, EnumSet将抛出 NullPointerEXce异常。如果只是想判断 EnumSet是否包含null素或试图删除null元素都不会抛出异常,只是删除操作将返回 false,因为没有任何nul元素被删除。</p>
<p> EnumSet类没有暴露任何构造器来创建该类的实例,程序应该通过它提供的类方法来创建 EnumSet对象。 EnumSet类它提供了如下常用的类方法来创建 EnumSet对象。</p>
<ul>
<li>EnumSet allOf(Class elementType):创建一个包含指定枚举类里所有枚举值的 EnumSet集合。</li>
<li>EnumSet complementOf(EnumSet):创建一个其元素类型与指定 EnumSet里元素类型相同的EnumSet集合,新 EnumSet集合包含原 EnumSet集合所不包含的、此枚举类剩下的枚举值(即新 EnumSet集合和原 EnumSet集合的集合元素加起来就是该枚举类的所有枚举值)。</li>
<li>EnumSet copyOf(Collection c):使用一个普通集合来创建 EnumSet集合。</li>
<li>EnumSet copyOf(EnumSet f):创建一个与指定 EnumSet 具有相同元素类型、相同集合元素的 EnumSet集合。</li>
<li>EnumSet noneOf(Class elementType):创建一个元素类型为指定枚举类型的空 EnumSet。</li>
<li>EnumSet of(E first,elementType):创建一个包含一个或多个枚举值的 EnumSet集合,传入的多个枚举值必须属于同一个枚举类。</li>
<li>EnumSet range(E from,E to):创建一个包含从 from 枚举值到 to 枚举值范围内所有枚举值的EnumSet集合。</li>
</ul>
<p>下面程序示范了如何使用 EnumSet来保存枚举类的多个枚举值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span></span><br><span class="line">&#123;</span><br><span class="line">	SPRING,SUMER,FALL,WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es1</span> <span class="operator">=</span> EnumSet.allOf(Season.class);</span><br><span class="line">		System.out.println(es1);</span><br><span class="line"><span class="comment">//		创建一个空EnumSet集合，集合元素就是Season的枚举类</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es2</span> <span class="operator">=</span> EnumSet.noneOf(Season.class);</span><br><span class="line">		System.out.println(es2);</span><br><span class="line"><span class="comment">//		手动添加两个元素</span></span><br><span class="line">		es2.add(Season.FALL);</span><br><span class="line">		es2.add(Season.SPRING);</span><br><span class="line">		System.out.println(es2);</span><br><span class="line"><span class="comment">//		以指定枚举值创建EnumSet集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es3</span> <span class="operator">=</span> EnumSet.of(Season.FALL,Season.SPRING);</span><br><span class="line">		System.out.println(es3);</span><br><span class="line"><span class="comment">//		EnumSet range(E from,E to):创建一个包含从 from 枚举值到 to 枚举值范围内所有枚举值的EnumSet集合。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es4</span> <span class="operator">=</span> EnumSet.range(Season.SUMER, Season.WINTER);</span><br><span class="line">		System.out.println(es4);</span><br><span class="line"><span class="comment">//		新创建的EnumSet集合元素和es4集合元素有相同的类型</span></span><br><span class="line"><span class="comment">//		es5集合元素+es4集合元素 = season枚举类的全部枚举值</span></span><br><span class="line"><span class="comment">/*		EnumSet complementOf(EnumSet):创建一个其元素类型与指定 EnumSet里元素类型相同的EnumSet集合,</span></span><br><span class="line"><span class="comment"> * 		新 EnumSet集合包含原 EnumSet集合所不包含的、此枚举类剩下的枚举值</span></span><br><span class="line"><span class="comment"> * 		(即新 EnumSet集合和原 EnumSet集合的集合元素加起来就是该枚举类的所有枚举值)。*/</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es5</span> <span class="operator">=</span> EnumSet.complementOf(es4);</span><br><span class="line">		System.out.println(es5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​	上面示范了EnumSet集合的常规用法。除此之外，还可以赋值另一个EnumSet集合中的所有元素来创建新的EnumSet集合。或者赋值另一个Collection集合中的所有元素来创建新的EnumSet集合。当复制Collection集合中的所有元素来创建新的EnumSet集合时，要求Collection集合中的所有元素必须是同一个枚举类的枚举值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSetTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		c.clear();</span><br><span class="line">		c.add(Season.FALL);</span><br><span class="line">		c.add(Season.SPRING);</span><br><span class="line"><span class="comment">//		复制Collection集合中的所有元素来创建EnumSet集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">enumSet</span> <span class="operator">=</span> EnumSet.copyOf(c);</span><br><span class="line">		System.out.println(enumSet);</span><br><span class="line">        <span class="comment">//当复制Collection集合中的所有元素来创建新的EnumSet集合时，要求Collection集合中的所有元素必须是同一个枚举类的枚举值。</span></span><br><span class="line">		c.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		c.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		enumSet = EnumSet.copyOf(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>当复制Collection集合中的所有元素来创建新的EnumSet集合时，要求Collection集合中的所有元素必须是同一个枚举类的枚举值。</p>

        <h3 id="8-3-5-各Set实现类的性能分析"   >
          <a href="#8-3-5-各Set实现类的性能分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-5-各Set实现类的性能分析" class="headerlink" title="8.3.5 各Set实现类的性能分析"></a>8.3.5 各Set实现类的性能分析</h3>
      <p> HashSet和 TreeSet是 Set 的两个典型实现,到底如何选择 HashSet和 TreeSet呢? HashSet的性能总是比 TreeSet好(特别是最常用的添加、查询元素等操作),因为 TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的 Set 时,应该使用 TreeSet,否则都应该使用 HashsSet。</p>
<p>HashSet还有一个子类: LinkedHashSet,对于普通的插入、删除操作, LinkedHashSet HashsSe要略微慢一点,这是由维护链表所带来的额外开销造成的,但由于有了链表,遍历 LinkedHashSet会更快。</p>
<p> EnumSet 是所有 Set 实现类中性能最好的,但它只能保存同一个枚举类的枚举值作为集合元素。</p>
<p>必须指出的是,Set的三个实现类 HashSet、 TreeSet和 EnumSet都是线程不安全的。如果有多个线程同时访问一个Set集合,并且有超过一个线程修改了该Set集合,则必须手动保证该Set集合的同步性。通常可以通过Collections工具类的 synchronizedSorte方法来“包装”该Set集合。此操作最好在创建时进行,以防止对Set集合的意外非同步访问。例如: SortedSet Collections. synchronizeds(new TreeSet (…))关于 Collections工具类的更进一步用法,可以参考8.8节的内容。</p>

        <h2 id="8-4List集合"   >
          <a href="#8-4List集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4List集合" class="headerlink" title="8.4List集合"></a>8.4List集合</h2>
      <p><strong>List集合代表一个元素有序、可重复的集合,集合中每个元素都有其对应的顺序索引。List集合许使用重复元素,可以通过索引来访问指定位置的集合元素。</strong>List集合默认按元素的添加顺序设置元素的索引,例如第一次添加的元素索引为0,第二次添加的元素索引为1。</p>

        <h3 id="8-4-1改进的List接口和-Listlterator接口"   >
          <a href="#8-4-1改进的List接口和-Listlterator接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4-1改进的List接口和-Listlterator接口" class="headerlink" title="8.4.1改进的List接口和 Listlterator接口"></a>8.4.1改进的List接口和 Listlterator接口</h3>
      <p>List作为 Collection接口的子接口,当然可以使用 Collection接口里的全部方法。而且由于List是有序集合,因此List集合里增加了一些根据索引来操作集合元素的方法。</p>
<ul>
<li>void add (int index, Object element):将元素 element插入到List集合的 index处</li>
<li>boolean addAll(int index, Collection)将集合c所包含的所有元素都插入到List集合的 index处。</li>
<li>Object get(int index):返回集合 index索引处的元素。 </li>
<li>int indexOf(Object):返回对象o在List集合中第一次出现的位置索引。</li>
<li>int lastIndexOf(Object):返回对象o在Lis集合中最后一次出现的位置索引。</li>
<li>Object remove(int index):删除并返回 index索引处的元素。</li>
<li>Object set(int index, Object element:将 index索引处的元素替换成 element对象,返回被替换的旧元素。</li>
<li>List subList(int fromIndex, int toIndex:返回从索引 fromIndex(包含)到索引 oIndex(不包含)处所有集合元素组成的子集合。</li>
</ul>
<p>所有的List实现类都可以调用这些方法来操作集合元素。与Set集合相比,List增加了根据索弘来插入、替换和删除集合元素的方法。除此之外,Java8还为List接口添加了如两今默认方法：</p>
<ul>
<li>void replaceAlUnaryOperator( operator):根据 operator指定的计算规则重新设置List集合的所有元素。</li>
<li>void sort(Comparator c):根据 Comparator参数对List集合的元素排序。</li>
</ul>
<p>下面程序示范了List集合的常规用法:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//		向books集合中添加三个元素</span></span><br><span class="line">		books.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;智&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;超&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		将新的字符串对象插入到第二个元素</span></span><br><span class="line">		books.add(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; books.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(books.get(i));</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		删除第三个元素</span></span><br><span class="line">		books.remove(<span class="number">2</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		判断指定元素在List集合中的位置：输出1，表明位于第二位</span></span><br><span class="line"><span class="comment">//		使用new创建的新对象，通过equals()方法比较返回true</span></span><br><span class="line">		System.out.println(books.indexOf(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>)));</span><br><span class="line"><span class="comment">//		使用字符串本身来判断</span></span><br><span class="line">		System.out.println(books.indexOf(<span class="string">&quot;超&quot;</span>));</span><br><span class="line"><span class="comment">//		将第二个元素替换成新的字符串对象</span></span><br><span class="line">		books.set(<span class="number">1</span>, <span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		将books集合的第二个元素</span></span><br><span class="line"><span class="comment">//		到第三个元素（不包括）截取成子集合</span></span><br><span class="line">		System.out.println(books.subList(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>示范了List的规范用法，List集合可以根据位置索引来访问集合中的元素，因此List增加了一种新的遍历集合元素的方法：使用普通的for循环来遍历集合元素。</p>
<p>注意①，也是通过new关键字创建的新字符串对象，两个字符串明显不是同一个对象，但是List的indexOf()方法依旧可以返回1，List判断两个对象相等的标准是什么？List判断两个对象相等只需要通过equals()方法比较返回true即可。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//		向books集合中添加三个元素</span></span><br><span class="line">		books.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;智&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;超&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		删除集合中A的对象，将导致第一个元素被删除</span></span><br><span class="line">		books.remove(<span class="keyword">new</span> <span class="title class_">A1</span>());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">		books.remove(<span class="keyword">new</span> <span class="title class_">A1</span>());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>执行删除代码时，程序试图删除A中的一个对象，List将会调用该A对象的equals()方法依次与集合元素进行比较，如果该equals()方法以某个元素作为参数时返回true，List将会删除该元素。</p>
<p>注意：当调用List的set方法通过改变List集合指定索引处的元素时，指定的索引必须是有效地索引，也就是说set方法不可以改变集合的索引。</p>
<p>Java8为List集合增加了 sort和 replaceAll()两个常用的默认方法,其中 sort方法需要一个Comparator 对象来控制元素排序,程序可使用 Lambda表达式来作为参数;而方法则需要一个 UnaryOperator来替换所有集合元素，UnaryOperator也是一个函数式接口,因此程序也可使用 Lambda表达式作为参数。如下程序示范了List集合的两个默认方法的功能。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级java EE 企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Androiod讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		使用目标类型为Comparator的Lambda表达式对List集合排序</span></span><br><span class="line">		books.sort((o1,o2)-&gt;((String)o1).length() - ((String)o2).length());<span class="comment">//①</span></span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		使用目标类型为UnaryOperator的Lambda表达式来替换集合中的所有元素</span></span><br><span class="line"><span class="comment">//		该Lambda表达式控制使用每个字符串的长度作为新的元素</span></span><br><span class="line">		books.replaceAll(ele -&gt; ((String)ele).length());<span class="comment">//2</span></span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>1代码控制对List集合进行排序，传给sort()方法的Lambda表达式指定的排序规则是：字符串程度越长，字符串越大。所以执行完后，List集合中的字符串惠安由短到长的顺序排序。</p>
<p>程序中2代码传给 replaceAll()方法的 Lambda表达式指定了替换集合元素的规则:直接用集合元素(字符串)的长度作为新的集合元素执行该方法后,集合元素被替换为[7,8,11,16]。</p>
<p>与Set只提供了一个 iterator()方法不同,List还额外提供了一个 listIterator()方法,该方法返回一个ListIterator, ListIterator接口继承了 Iterator接口，提供了专门操作List的方法 ListIterator接口在Iterator接口基础上增加了如下方法。</p>
<ul>
<li>boolean hasPrevious()：返回该迭代器关联的集合是否还有上一个元素。</li>
<li>Object previous()：返回该迭代器的上一个元素。</li>
<li>void add(Object)：在指定位置插入一个元素。</li>
</ul>
<p>拿 ListIterator与普通的 Iterator进行对比不难发现 ListIterator增加了向前迭代的功能(Iterator只能向后迭代),而且ListIterator还可通过add方法向List集合中添加元素(terator只能删除元素)下面程序示范了 ListIterator的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] books = &#123;</span><br><span class="line">				<span class="string">&quot;疯狂java讲义&quot;</span>,<span class="string">&quot;疯狂iOS讲义&quot;</span>,</span><br><span class="line">				<span class="string">&quot;轻量级java EE 企业应用实战&quot;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">bookList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;books.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			bookList.add(books[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">var</span> <span class="variable">lit</span> <span class="operator">=</span> bookList.listIterator();</span><br><span class="line"><span class="comment">//		从前向后遍历</span></span><br><span class="line">		<span class="keyword">while</span>(lit.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(lit.next());</span><br><span class="line">			System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;=========下面开始方向迭代===========&quot;</span>);</span><br><span class="line"><span class="comment">//		从后往前遍历</span></span><br><span class="line">		<span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(lit.previous());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>开始也需要采用正向迭代，即先使用next()方法进行迭代，在迭代过程中可以使用add()方法向上一次迭代元素的后面添加一个新元素。</p>

        <h3 id="8-4-2-ArrayLISt和Vector实现类"   >
          <a href="#8-4-2-ArrayLISt和Vector实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4-2-ArrayLISt和Vector实现类" class="headerlink" title="8.4.2 ArrayLISt和Vector实现类"></a>8.4.2 ArrayLISt和Vector实现类</h3>
      <p>ArrayList 和 Vector作为List类的两个典型实现,完全支持前面介绍的List接口的全部功能。</p>
<p>ArrayList和 Vector类都是基于数组实现的List类,所以ArrayList和 Vector类封装了一个动态的、允许再分配的 Object数组。 ArrayList或 Vector对象使用 initialCapacity参数来设置该数组的长度,当向 ArrayList或 Vector中添加元素超出了该数组的长度时,它们的 initialCapacity会自动增加。</p>
<p>对于通常的编程场景,程序员无须关心 ArrayList或 Vector的 initialCapacity但如果向 ArrayList或 Vector集合中添加大量元素时,可使用 ensureCapacity(int minCapacity)方法一次性地增加 initialCapacity 这可以减少重分配的次数,从而提高性能。</p>
<p>如果开始就知道 ArrayList或 Vector集合需要保存多少个元素,则可以在创建它们时就指定 initialCapacity大小。如果创建空的 ArrayList或 Vector集合时不指定 initialCapacity参数,则Object数组的长度默认为10。</p>
<p>ArrayList和 Vector还提供了如下两个方法来重新分配 Object数组</p>
<ul>
<li>void ensureCapacity(int minCapacity):将 ArrayList或 Vector集合的 Object数组长度增加大于或等于 minCapacity值。</li>
<li>void trimToSize:调整 ArrayList或 Vector集合的 Object[]数组长度为当前元素的个数。调用该方法可减少 ArrayList或 Vector集合对象占用的存储空间。</li>
</ul>
<p> ArrayList和 Vector在用法上几乎完全相同,但由于 Vector是一个古老的集合(从DK1.0就有了），那时候Java还没有提供系统的集合框架,所以 Vector里提供了一些方法名很长的方法,例如 addElement(Object obj),实际上这个方法与add(Object obj)没有任何区别。从JDK1.2以后,Java提供了系统的集合框架,就将 Vector改为实现List接口,作为List的实现之一,从而导致 Vector里有一些功能重复的方法。</p>
<p> Vector的系列方法中方法名更短的方法属于后来新增的方法,方法名更长的方法则是 Vector原有的方法。Java改写了 Vector原有的方法,将其方法名缩短是为了简化编程。而 ArrayList开始就作为List的主要实现类,因此没有那些方法名很长的方法。实际上, Vector具有很多缺点,通常尽量少用 Vector实现类。</p>
<p>除此之外, ArrayList和 Vector的著区别是: ArrayList是线程不安全的,当多个线程访问同一个 ArrayList集合时,如果有超过一个线程修改了 ArrayList集合,则程序必须手动保证该集合的同步性;但 Vector集合则是线程安全的,无须程序保证该集合的同步性。因为 Vector是线程安全的,所以Vector的性能比 ArrayList的性能要低。实际上,即使需要保证List集合线程安全,也同样不推荐使用 Vector后面会介绍一个Collections工具类,它可以将一个 ArrayList变成线程安全的。</p>
<p> Vector还供了一个 Stack子类,它用于模拟“栈”这种数据结构,“栈通常是指“后进先出”(LFO)的容器。最后“push”进桟的元素,将最先被“pop”出与Java中的其他集合一样,进栈出栈的都是 Object,因此从栈中取出元素后必须进行类型转换,除非你只是使用 Object 具有的操作。所以Stack类里提供了如下几个方法。</p>
<ul>
<li>Object peek():返回“栈”的第一个元素,但并不将该元素“pop”出栈</li>
<li>Object pop():返回“栈”的第一个元素并将该元素“pop”出栈。</li>
</ul>
<p>需要指出的是,由于 Stack继承了 Vector,因此它也是一个非常古老的Java集合类,它同样是线程安全的、性能较差的,因此应该尽量少用 Stack。如果程序需要使用“栈”这种数据结构,建议使用队列，后面将要介绍的 ArrayDeque代替它。</p>

        <h3 id="8-4-3-固定长度的List"   >
          <a href="#8-4-3-固定长度的List" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4-3-固定长度的List" class="headerlink" title="8.4.3 固定长度的List"></a>8.4.3 固定长度的List</h3>
      <p>前面讲数组时介绍了一个操作数组的工具类：Ayyars，该工具类里提供了 asList(Object..a)方法,该方法可以把一个数组或指定个数的对象转换成一个List集合,这个List集合既不是 Array List实现类的实例,也不是 Vector实现类的实例,而是 Arrays的内部类 ArrayList的实例。</p>
<p>Arrays.ArrayList是一个固定长度的List集合程序只能遍历访问该集合里的元素,不可增加、删除该集合的元素</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIxedSizeList</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">fixedList</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;疯狂Java讲义&quot;</span></span><br><span class="line">				+ <span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line"><span class="comment">//		获取fixedList的实现类，将输出ArraysArrayList</span></span><br><span class="line">		System.out.println(fixedList.getClass());</span><br><span class="line"><span class="comment">//		使用方法遍历集合元素</span></span><br><span class="line">		fixedList.forEach(System.out :: println);</span><br><span class="line"><span class="comment">//		试图修改集合元素都会引发异常</span></span><br><span class="line">		fixedList.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line">		fixedList.remove(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中两行粗体字代码对于普通的List集合完全正常,但如果试图通过这两个方法来增加、删除 Arrays$ArrayList集合里的元素,将会引发异常。所以上面程序在编译时完全正常,但会在运行第一行粗体字标识的代码行处引发 UnsupportedOperation Exception异常。</p>

        <h2 id="8-5-Queue集合"   >
          <a href="#8-5-Queue集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-Queue集合" class="headerlink" title="8.5 Queue集合"></a>8.5 Queue集合</h2>
      <p> <strong>Queue用于模拟队列这种数据结构,队列通常是指“先进先出”(FIFO)的容器。队列的头部保存在队列中存放时间最长的元素,队列的尾部保存在队列中存放时间最短的元素新元素插入(offer)到队列的尾部,访问元素(poll)操作会返回队列头部的元素。通常,队列不允许随机访问队列中的元素</strong></p>
<p> Queue接口中定义了如下几个方法。</p>
<ul>
<li>void add(Object c):将指定元素加入此队列的尾部。</li>
<li>Object element():获取队列头部的元素,但是不删除该元素。</li>
<li>boolean offer(Object c):将指定元素加入此队列的尾部。当使用有容量限制的队列时,此方法通常比add(Object c)方法更好。</li>
<li>Object peek()：获取队列头部的元素，但是不删除该元素。如果此队列为空,则返回null</li>
<li>Object poll()：获取队列头部的元素，并删除该元素。如果此队列为空,则返回nul</li>
<li>Object remove()：获取队列头部的元素，并删除该元素。</li>
</ul>
<p>Queue接口有一个 PriorityQueue实现类。除此之外, Queue还有一个 Deque接口, Deque代表一个“双端队列”,双端队列可以同时从两端来添加、删除元素,因此 Deque的实现类既可当成队列使用,也可当成桟使用。Java为 Deque提供了 ArrayDeque和 LinkedList两个实现类</p>

        <h3 id="8-5-1-PriorityQueue实现类"   >
          <a href="#8-5-1-PriorityQueue实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-1-PriorityQueue实现类" class="headerlink" title="8.5.1 PriorityQueue实现类"></a>8.5.1 PriorityQueue实现类</h3>
      <p>PriorityQueue是一个&#x3D;&#x3D;比较标准的队列实现类&#x3D;&#x3D;。之所以说它是比较标准的队列实现,而不是绝对标准的队列实现,是因为 &#x3D;&#x3D;PriorityQueue保存队列元素的顺序并不是按加入队列的顺序,而是按队列元素的大小进行重新排序&#x3D;&#x3D;。因此当调用 peek方法或者 pollo方法取出队列中的元素时,并不是取出最先进入队列的元素,而是取出队列中最小的元素。从这个意义上来看, PriorityQueue已经违反了队列的最基本规则:先进先出(FIFO)下面程序示范了 PriorityQueue队列的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line"><span class="comment">//		下面代码依次向pq加入四个元素</span></span><br><span class="line">		pq.add(<span class="number">9</span>);</span><br><span class="line">		pq.add(-<span class="number">3</span>);</span><br><span class="line">		pq.add(<span class="number">20</span>);</span><br><span class="line">		pq.add(<span class="number">18</span>);</span><br><span class="line"><span class="comment">//		输出pq队列，并不是按元素的加入顺序排列</span></span><br><span class="line">		System.out.println(pq);</span><br><span class="line">		System.out.println(pq.poll());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行上面程序直接输出 PriorityQueue 集合时，可能看到该队列里的元素并没有很好地按大小进行排序,但这只是受到PriorityQueue的 toString() 方法返回值的影响实际上,程序多次调用 PriorityQueue集合对方法可看到元素按从小到大的顺序“移出队列”。</p>
<p>PriorityQueue不允许插入null元素,它还需要对队列元素进行排序, PriorityQueue的元素有两种排序方式。</p>
<ul>
<li>自然排序：采用自然顺序的 PriorityQucue集合中的元素必须实现了 Compar是同一个类的多个实例,否则可能导致 ClassCastE xception异常</li>
<li>定制排序：创建 PriorityQueue列时,传入一个 Comparator对象,该对象负责对队序方式。元素进行排序。采用定制排序时不要求队列元素实现 Comparable接口。</li>
</ul>
<p>PriorityQucue素的要求与 Treset对元素的要求基本一致,因此关于使用自然排序和定制排序的详细介绍请参考8.33节。</p>

        <h3 id="8-5-2-Deque接口与-ArrayDeque实现类"   >
          <a href="#8-5-2-Deque接口与-ArrayDeque实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-2-Deque接口与-ArrayDeque实现类" class="headerlink" title="8.5.2 Deque接口与 ArrayDeque实现类"></a>8.5.2 Deque接口与 ArrayDeque实现类</h3>
      <p>Deque接口是Queue接口的子接口,它代表一个双端队列, Deque接口里定义了一些双端队列的方法,这些方法允许从两端来操作队列的元素。</p>
<ul>
<li><p>void addFirst(Object e)：将指定元素插入该双端队列的开头。</p>
</li>
<li><p>void addLast(Object e)：将指定元素插入该双端队列的末尾。</p>
</li>
<li><p>Iterator descendinglterator()：返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。</p>
</li>
<li><p>Object getFirst()：获取但不删除双端队列的第一个元素。</p>
</li>
<li><p>Object getLast()):获取但不删除双端队列的最后一个元素。</p>
</li>
<li><p>boolean offerfirst(Object e)：将指定元素插入该双端队列的开头。</p>
</li>
<li><p>boolean offerLast(Object e)：将指定元素插入该双端队列的末尾。</p>
</li>
<li><p>Object peekFirst()：获取但不删除该双端队列的第一个元素;如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object peekLast()：获取但不删除该双端队列的最后一个元素:如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object pollFirst()：获取并删除该双端队列的第一个元素;如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object pollLast()：获取并删除该双端队列的最后一个元素:如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object pop(栈方法)：pop出该双端队列所示的栈的栈顶元素。相当于 removeFirst()。</p>
</li>
<li><p>void push(Object c)(栈方法):将一个元素push进该双端队列所表示的栈的栈顶 。相当于addFirst(e)。</p>
</li>
<li><p>Object removeFirst()：获取并删除双端队列的第一个元素。</p>
</li>
<li><p>Object removeFirstOccurrence(Objecet o)：删除该双端队列的第一次出现的元素o。</p>
</li>
<li><p>Object removeLast()：获取并删除双端队列的最后一个元素。</p>
</li>
<li><p>Object removeListOccurrence(Objecet o)：删除该双端队列的第一次出现的元素o。</p>
</li>
</ul>
<p>Dequq不仅可以当成双端队列使用，而且可以被当成栈使用，因为该类力还包含了pop（出栈）、push（入栈）两个方法。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>Queue的方法</th>
<th>Deque的方法</th>
</tr>
</thead>
<tbody><tr>
<td>add(e)&#x2F;offer(e)</td>
<td>addLast(e)&#x2F;addFirst(e)</td>
</tr>
<tr>
<td>remove()&#x2F;poll()</td>
<td>removeFirst()&#x2F;pollFirst()</td>
</tr>
<tr>
<td>element()&#x2F;peek()</td>
<td>getFirst()&#x2F;peekFirst()</td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>Stack的方法</th>
<th>Deque的方法</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFirst(e)&#x2F;offerFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()&#x2F;pollFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>getFirst()&#x2F;peekFirst()</td>
</tr>
</tbody></table></div>
<p>Deque接口提供了一个典型的实现类ArrayDeque，从名称则可以看出，他是一个基于数组实现的双端队列，创建Deque时同样可以指定一个nujmElements参数，该参数用于指定Object[]数组的长度，</p>
<p>下面示范了把ArrayDeque当成“栈”来使用：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDequeTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">		stack.push(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		stack.add(<span class="string">&quot;轻量级&quot;</span>);</span><br><span class="line">		stack.push(<span class="string">&quot;疯狂讲义&quot;</span>);</span><br><span class="line">		System.out.println(stack);</span><br><span class="line"><span class="comment">//		访问第一个元素，但不将其pop出栈</span></span><br><span class="line"><span class="comment">//		当成栈使用</span></span><br><span class="line">		System.out.println(stack.peek());</span><br><span class="line"><span class="comment">//		依次输出</span></span><br><span class="line">		System.out.println(stack);</span><br><span class="line">		System.out.println(stack.pop());</span><br><span class="line">		System.out.println(stacka);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>当需要栈这种结构时，推荐使用“ArrayQeque”，尽量避免使用Stack——因为Stack是古老的集合，性能差。</p>
<p>ArrayDeque将按“先进先出”的方式操作集合元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDequeQueueTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">ArrayDeque</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line"><span class="comment">//		依次将三个元素插入队列</span></span><br><span class="line">		queue.offer(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		queue.offer(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		queue.offer(<span class="string">&quot;讲义&quot;</span>);</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		System.out.println(queue.peek());</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		System.out.println(queue.poll());</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210417120831241](C:\Program Files\Typora\image\image-20210417120831241.png)ArrayDeque不仅可以作为栈使用，也可以作为队列使用。</p>

        <h3 id="8-5-3-LinkedList-实现类"   >
          <a href="#8-5-3-LinkedList-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-3-LinkedList-实现类" class="headerlink" title="8.5.3 LinkedList 实现类"></a>8.5.3 LinkedList 实现类</h3>
      <p>LinkedList类是一个List实现类——这就意味着他是一个LIst集合，也可以根据索引来随机访问集合中的元素。除此之外，LinkedList还是先了Deque接口，可以被当成双端队列来使用，因此既可以被当成“栈”来使用，也可以当成队列来使用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">		books.offer(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		books.push(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		books.offerFirst(<span class="string">&quot;讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		以Link的方式（按索引的方式）来遍历集合元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;books.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;遍历中:&quot;</span>+books.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(books.peekFirst());</span><br><span class="line"><span class="comment">//		访问并不删除队列的最后一个元素</span></span><br><span class="line">		System.out.println(books.peekLast());</span><br><span class="line"><span class="comment">//		将栈顶的元素导出栈</span></span><br><span class="line">		System.out.println(books.pop());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">		System.out.println(books.pollLast());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>分别示范了LinkedList作为List集合、双端队列、栈的用法。由此可见LinkedList是一个功能强大的集合类。</p>
<p> LinkedList与 ArrayList、 ArrayDeque的实现机制完全不同, ArrayList、 ArrayDeque内部以数组的形式来保存集合中的元素,因此随机访问集合元素时有较好的性能;而 LinkedList内部以链表的形式来保存集合中的元素,因此随机访问集合元素时性能较差但在插入、删除元素时性能比较出色(只改变指针所指的地址即可)。需要指出的是,虽然Vector也是以数组的形式来存储集合元素的,但因它实现了线程同步功能(而且实现机制也不好),所以各方面性能都比较差。</p>
<p>注意：对于所有的内部基于数组的集合实现,例如ArrayList、ArrayDque等,使用随机访问的性能比使用 Iterator迭代访问的性能要好,因为随机访问会被映射成对数组元素的访问。</p>

        <h3 id="8-5-4各种线性表的性能分析"   >
          <a href="#8-5-4各种线性表的性能分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-4各种线性表的性能分析" class="headerlink" title="8.5.4各种线性表的性能分析"></a>8.5.4各种线性表的性能分析</h3>
      <p>Java提供的List就是一个线性表接口,而ArrayList、 LinkedList又是线性表的两种典型实现:基于数组的线性表和基于链的线性表。 Queue代表了队列 Deque代表了双端队列(既可作为队列使用,也可作为栈使用),接下来对各种实现类的性能进行分析。</p>
<p>初学者可以无须理会 ArrayList和 LinkedList之间的性能差异,只需要知道 LinkedList集合不仅提供了List的功能,还提供了双端队列、栈的功能就行。但对于一个成熟的Java程序员,在一些性能非常敏感的地方,可能需要慎重选择哪个List实现。</p>
<p>一般来说,由于数组以一块连续内存区来保存所有的数组元素,所以数组在随机访问时性能最好,所有的内部以数组作为底层实现的集合在随机访问时性能都比较好;而内部以链表作为底层实现的集合在执行插入、删除操作时有较好的性能。但总体来说, ArrayList的性能比 LinkedList的性能要好,因此大部分时候都应该考虑使用 ArrayList</p>
<p>关于使用List集合有如下建议。</p>
<ul>
<li>如果需要遍历List集合元素,对于 Arrayis Vector集合,应该使用随机访问方法(get)来遍历集合元素,这样性能更好;对于 LinkedList集合,则应该采用迭代器(Iterator)来遍历集合</li>
<li>如果需要经常执行插入、删除操作来改变包含大量数据的List集合的大小,可考虑使用元素。LinkedList集合。使用 ArrayList、 Vector集合可能需要经常重新分配内部数组的大小,效果可能较差。</li>
<li>如果有多个线程需要同时访问List集合中的元素,开发者可考虑使用 Collections将集合包装成线程安全的集合。</li>
</ul>

        <h2 id="8-6增强的Map集合"   >
          <a href="#8-6增强的Map集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6增强的Map集合" class="headerlink" title="8.6增强的Map集合"></a>8.6增强的Map集合</h2>
      <p>Map用于保存具有映射关系的数据，因此Map集合里保存着两组值，一组用于保存Map里的key，另一组值用于保存Map里的value，key和value都可以是任何引用类型的数据，Map的key不允许重复，即同一个Map对象的任何两个key通过equal方法比较总返回false。</p>
<p>![](C:\Program Files\Typora\image\微信图片_20210417135403.jpg)</p>
<p>果需要从List集合中取出元素,则需要提供该元素的数字索引;如果需要从Map中取出元素,则需提供该元素的key索引。因此,Map有时也被称为字典,或关联数组Map接口中定义了如下常方法</p>
<ul>
<li>&gt;void clear:删除该Map对象中的所有key -value-对。</li>
<li>&gt;boolean containsKey(Object key):查询Map中是否包含指定的key,如果包含则返回true</li>
<li>&gt;boolean contains Value(Object value):查询Map中是否包含一个或多个 value,如果包含则返回</li>
<li>&gt;Set entrySet:返回Map中包含的key-vale对所组成的Set集合,每个集合元素都是Map.Entry（Entry是Map的内部类)对象。</li>
<li>&gt;Object get(Object key):返回指定key所对应的vale;如果此Map中不包含该key,则返回null</li>
<li>&gt;boolean is Empty:查询该Map是否为空(即不包含任何key -value-对),如果为空则返回true</li>
<li>&gt;Set keySet:返回该Map中所有key组成的Set集合。</li>
<li>&gt;Object put(Object key, Object value):添加一个ky-vaue对,如果当前Map中已有一个与该key相等的key- value对,则新的key- value对会覆盖原来的key- -value对。</li>
<li>&gt;void putAll(MMapm):将指定Map中的key- -value对复制到本Map中</li>
<li>&gt;Object remove(Object key):删除指定key所对应的key- -value对,返回被删除key所关联的 value如果该key不存在,则返回null</li>
<li>&gt;boolean remove(Object key, Object value):是Java8新增的方法,删除指定key-value所对应的key- -value对。如果从该Map中成功地删除该ey- -value对,该方法返回true,否则返回 false</li>
<li>&gt;int size:返回该Map里的key -value-对的个数。</li>
<li>&gt;Collection values:返回该Map里所有 value组成的 Collection</li>
</ul>
<p>Map接口提供了大量的实现类,典型实现如 HashMap和 Hashtable等、 HashMap的子类LinkedHashMap,还有 SortedMap子接口及该接口的实现类 TreeMap,以及 WeakHashMap、IdentityHashMap等下面将详细介绍Map接口实现类。</p>
<p>Map中包括一 Entry个内部类,该类封装了一个key -value-对 Entry包含如下三个方法。</p>
<ul>
<li>&gt;Object getKey:返回该 Entry里包含的key值。</li>
<li>&gt;Object get Value:返回该 Entry里包含的 value值。</li>
<li>&gt;Object set Value( value):设置该 Entry里包含的 value值,并返回新设置的 value值。</li>
</ul>
<p>Map集合最典型的用法就是成对地添加、删除key- -value对,接下来即可判断该Map中是否包含指定key,是否包含指定 value,也可以通过Map提供的 keySet方法获取所有key组成的集合,进而遍历Map中所有的key- -value对。下面程序示范了Map的基本功能。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		成对放入多个key-value对</span></span><br><span class="line">		map.put(<span class="string">&quot;疯狂&quot;</span>, <span class="number">109</span>);</span><br><span class="line">		map.put(<span class="string">&quot;java&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		map.put(<span class="string">&quot;讲义&quot;</span>, <span class="number">108</span>);</span><br><span class="line">		map.put(<span class="string">&quot;张智超·&quot;</span>, <span class="number">107</span>);</span><br><span class="line">		System.out.println(map.put(<span class="string">&quot;java&quot;</span>, <span class="number">107</span>));</span><br><span class="line">		System.out.println(map);</span><br><span class="line">		System.out.println(map.containsKey(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">		System.out.println(map.containsValue(<span class="number">107</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> key : map.keySet())</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			map.get(key)方法获取指定key对应的value</span></span><br><span class="line">			System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		根据key来删除value</span></span><br><span class="line">		map.remove(<span class="string">&quot;讲义&quot;</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>添加key-value对是，Map允许多个value重复，但如果添加key-value对时Map已经有重复的key，那么新添加value会覆盖该key原来对应的value，该方法将会返回被覆盖的value。</p>
<p>Map实现类重写了toString()方法，调用Map对象的toString()方法总是返回键值对的形式。</p>

        <h3 id="8-6-1-Java-8为Map新增的方法"   >
          <a href="#8-6-1-Java-8为Map新增的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-1-Java-8为Map新增的方法" class="headerlink" title="8.6.1 Java 8为Map新增的方法"></a>8.6.1 Java 8为Map新增的方法</h3>
      <p>![](C:\Program Files\Typora\image\fbf7c155315178ab3a2b30f83b79c11.jpg)</p>
<p>replaceAll(BiFunction Function)：该方法使用BiFunction对原key-value对执行计算，并将计算结果作为该键值对的value值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		成对放入多个key-value对</span></span><br><span class="line">		map.put(<span class="string">&quot;疯狂java讲义&quot;</span>, <span class="number">109</span>);</span><br><span class="line">		map.put(<span class="string">&quot;疯狂iOS讲义&quot;</span>, <span class="number">99</span>);</span><br><span class="line">		map.put(<span class="string">&quot;疯狂Ajax&quot;</span>,<span class="number">79</span>);</span><br><span class="line"><span class="comment">//		尝试替换key为“疯狂XML讲义”的value，由于原Map中没有对应的key</span></span><br><span class="line"><span class="comment">//		因此Map没有改变，没有添加新的键值对</span></span><br><span class="line">		map.replace(<span class="string">&quot;疯狂XML讲义&quot;</span>, <span class="number">66</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line"><span class="comment">//		使用原value与传入参数计算出来的结果覆盖原有的value</span></span><br><span class="line">		map.merge(<span class="string">&quot;疯狂iOS讲义&quot;</span>, <span class="number">10</span>,</span><br><span class="line">				(oldVal,param)-&gt;(Integer)oldVal +(Integer)param);</span><br><span class="line">		System.out.println(map);</span><br><span class="line"><span class="comment">//		当key为“Java”对应的value为null是，使用计算的结果作为新的value</span></span><br><span class="line">		map.computeIfAbsent(<span class="string">&quot;Java&quot;</span>, key-&gt;((String)key).length());</span><br><span class="line">		System.out.println(map);</span><br><span class="line">		map.computeIfPresent(<span class="string">&quot;Java&quot;</span>, (key,value)-&gt;(Integer)value*(Integer)value);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210417162717188](C:\Program Files\Typora\image\image-20210417162717188.png)</p>

        <h3 id="8-6-2-改进的-HashMap-和-Hashtable-实现类"   >
          <a href="#8-6-2-改进的-HashMap-和-Hashtable-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-2-改进的-HashMap-和-Hashtable-实现类" class="headerlink" title="8.6.2 改进的 HashMap 和 Hashtable 实现类"></a>8.6.2 改进的 HashMap 和 Hashtable 实现类</h3>
      <p>HashMap和Hashtable都是Map接口的典型实现类，他们之间的关系完全类似于ArrayList和Vector的关系：Hashtable是一个古老的Map实现类，它从JDK1.0就开始了，但它出现时，Java还没提供Map接口</p>
<p>由于HashMap中的key不能重复，所以HashMap中只能有一个key为null，但是可以有无数个key-value对的value为null，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullInHashMap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		试图将两个key为null值的key-value对放入HashMap中</span></span><br><span class="line">		hm.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">		hm.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//		讲一个value为null的值放入HashMap</span></span><br><span class="line">		hm.put(<span class="string">&quot;a&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">		System.out.println(hm);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了成功的在HashMap、Hashtable中储存、获取对象，用作key的对象必须事先hashCode()方法和equals()方法。</p>
<p>与HashSet集合保证元素的顺序一样，HashMap、Hashtable也不能保证其中的key-value对的顺序。类似于HashSet、HashMap、Hashtable判断两个key相等的标准也是：两个key通过equals()方法比较返回true，两个key的hashCode()值也相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A9</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A9</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="built_in">this</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == A.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> (A9) obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.count == a.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	重写了equals方法，b对象与任何对象通过equals方法比较都返回ture</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashtableTset</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">6000</span>), <span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>), <span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">1232</span>), <span class="keyword">new</span> <span class="title class_">B2</span>());</span><br><span class="line">		System.out.println(ht);</span><br><span class="line"><span class="comment">//		只要两个对象通过equals()方法比较返回true</span></span><br><span class="line"><span class="comment">//		Hashtable就认为他们是相等的value</span></span><br><span class="line">		System.out.println(ht.containsValue(<span class="string">&quot;测试字符串&quot;</span>));</span><br><span class="line"><span class="comment">//		只要两个A对象的count相等，他们他们通过equals()返回true，而且hashCode值相等</span></span><br><span class="line">		System.out.println(ht.containsKey(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>)));</span><br><span class="line">		ht.remove(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">1232</span>));</span><br><span class="line">		System.out.println(ht);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面定义了A类和B类，其中A类判断两个A对象相等的标准是count实例变量：只要两个A对象的count变量相等，则通过equals()方法比较他们返回true，他们的hashCode值也相等：而B对象则可以与任何对象相等。</p>
<p>Hashtable判断value相等的标准是：value与另外一个对象通过equals()方法比较返回true即可，上满程序中的ht对象中包含了一个B对象，他与任何对象通过equals比较总会返回true，所以在①号粗体字代码处返回true。在这种情况下，不管传给ht对象的containtsValue()方法参数是上满，程序总返回true。</p>
<p>根据Hashtable判断两个key相等的标准，程序在2号也将返回true，且hashCode值相等，HashCode值相等，Hashtable即认为他们是同一个key，类似的是，程序在3也可以删除对应的键值对。</p>
<p>当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同。因为HashMap、Hashtable保存key的方式与HashSet保存集合元素的方式完全相等，所以HashMap、Hashtable对key的要求与HashSet对集合元素的要求相同。</p>
<p>与HashSet类似的是，如果使用可变对象作为HashMap、Hashtable的key，并且程序修改了作为key的可变对象，则也有可能出现于HashSet类似的情况：程序再也无法访问到Map中被修改过的key</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapErrorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		此处的A类与前一个程序的A类是同一个类</span></span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">60000</span>), <span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>), <span class="string">&quot;轻量级Java EE 企业应用实战&quot;</span>);</span><br><span class="line"><span class="comment">//		获取Hashtable的key Set集合对应的Iterator迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> ht.keySet().iterator();</span><br><span class="line"><span class="comment">//		取出Map中第一个key，并修改它的count值</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> (A9) it.next();</span><br><span class="line">		first.count = <span class="number">87563</span>;</span><br><span class="line">		System.out.println(ht);</span><br><span class="line"><span class="comment">//		只能删除没有修改过的key所对应的key-value对</span></span><br><span class="line">		ht.remove(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>));</span><br><span class="line">		System.out.println(ht);</span><br><span class="line"><span class="comment">//		无法获取剩下的value，下面两个代码都将输出null</span></span><br><span class="line">		System.out.println(ht.get(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>)));</span><br><span class="line">		System.out.println(ht.get(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">60000</span>)));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="8-6-3-LinkedHashMap-实现类"   >
          <a href="#8-6-3-LinkedHashMap-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-3-LinkedHashMap-实现类" class="headerlink" title="8.6.3 LinkedHashMap 实现类"></a>8.6.3 LinkedHashMap 实现类</h4>
      <p>HashSet有一个LinkedHashSet子类，HashMasp也有一个LinkedHashMap子类；LinkedHashMap也使用双向链表来维护key-value对的顺序（其实也要考虑key的顺序），该链表负责维护Map的迭代顺序，迭代顺序与key-value对的插入顺序保持一致。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">scores</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">		scores.put(<span class="string">&quot;语文&quot;</span>, <span class="number">90</span>);</span><br><span class="line">		scores.put(<span class="string">&quot;数学&quot;</span>, <span class="number">150</span>);</span><br><span class="line">		scores.put(<span class="string">&quot;英语&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="comment">//		调用forEach()方法遍历scores里的所有键值对</span></span><br><span class="line">		scores.forEach((key,value)-&gt;System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面最后一句使用Java 8为Map新增的forEach()方法来遍历Map集合。LinkedHashMap可以记住key-value对的添加顺序。</p>

        <h3 id="8-6-4-使用Properties读写属性文件"   >
          <a href="#8-6-4-使用Properties读写属性文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-4-使用Properties读写属性文件" class="headerlink" title="8.6.4 使用Properties读写属性文件"></a>8.6.4 使用Properties读写属性文件</h3>
      <p>Properties类是Hashtable类的子类，正如它的名字所暗示的，该对象在处理属性文件时特别方便（Windows操作平台上的ini文件就是一种属性文件）。Properties类可以把Map对象和属性文件关联起来，从而可以把Map中的键值对写入属性文件中，也可以把属性文件中的“属性名&#x3D;属性值”加载到Map对象中。由于属性文件里的属性名、属性值只能是字符串类型，所以Properties里的key、value都是字符串类型。提供了三个方法需要改键值对的值。</p>
<p>提示：**Properties相当于一个key、value都是String类型的Map。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//		向Properties中添加属性</span></span><br><span class="line">		props.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;yeeku&quot;</span>);</span><br><span class="line">		props.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//		将Properties中的key-value对保存到a.ini文件中</span></span><br><span class="line">		props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.ini&quot;</span>), <span class="string">&quot;comment line&quot;</span>);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//		创建一个Properties中添加属性</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">props2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//		向Properties中添加属性</span></span><br><span class="line">		props2.setProperty(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"><span class="comment">//		将a.ini文件中的键值对追加到props2中</span></span><br><span class="line">		props2.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.ini&quot;</span>));<span class="comment">//2</span></span><br><span class="line">		System.out.println(props2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>1将Properties对象中的键值对写入a.ini文件中，2则从a.ini文件中读取键值对，并添加到props2对象中。</p>

        <h3 id="8-6-5-SortedMap接口和TreeMap实现类"   >
          <a href="#8-6-5-SortedMap接口和TreeMap实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-5-SortedMap接口和TreeMap实现类" class="headerlink" title="8.6.5 SortedMap接口和TreeMap实现类"></a>8.6.5 SortedMap接口和TreeMap实现类</h3>
      <p>正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出SortedMap子接口，SortedMap接口也有一个TreeMap实现类。</p>
<p>TreeMap就是一个红黑树数据结构，每个键值对机作为红黑树的一个节点。TreeMap存储键值对（节点）时，需要根据key对节点进行排序。TreeMap可以保证所有的键值对处于有序状态。TreeMap也有自然排序和定序排序两种排序方式。</p>
<ul>
<li>自然排序: TreeMap的所有key必须实现 Comparable接口,而且所有的key应该是同一个类的对象,否则将会抛出 ClassCastException异常。</li>
<li>定制排序:创建TreeMap时,传入一个 Comparator对象,该对象负责对TreeMap中的所有key进行排序。采用定制排序时不要求Map的key实现 Comparable接口，</li>
</ul>
<p>类似于 TreeSet中判断两个元素相等的标准, TreeMap中判断两个key相等的标准是:两个key通过 compare方法返回0, TreeMap即认为这两个key是相等的。</p>
<p>如果使用自定义类作为 TreeMap的key,且想让TreeMap良好地工作,则重写该类的 equals方法和 compare To方法时应保持一致的返回结果:两个key通过 equals方法比较返回true时,它们通过compareTo方法比较应该返回0.如果 equals方法与 compareTo方法的返回结果不一致,TreeMap与Map接口的规则就会冲突。</p>
<p>注意：再次强调：Set和Map的关系十分密切,Java源码就是先实现了 HashMap，TreeMap等集合,然后通过包装一个所有的value都为空对象的Map集合实现了Set集合类。</p>
<p>与 TreeSet类似的是, TreeMap中也提供了一系列根据key顺序访问key-value对的方法。</p>
<ul>
<li><p>Map. Entry firstEntry:返回该Map中最小key所对应的key- -value对,如果该Map为空,则返回null</p>
</li>
<li><p>Object firstKey:返回该Map中的最小ey值,如果该Map为空,则返回null</p>
</li>
<li><p>Map. Entry lastEntry:返回该Map中最大key所对应的key- value对,如果该Map为空或不存在这样的key-value对,则都返回null</p>
</li>
<li><p>Object lastKey:返回该Map中的最大key值如果该Map为空或不存在这样的key,则都返回null</p>
</li>
<li><p>Map. Entry higherEntry(Object key):返回该Map中位于key后一位的key- value对(即大于指定key的最小key所对应的key- -value对)。如果该Map为空,则返回null</p>
</li>
<li><p>Object higherKey(Object key):返回该Map中位于key后一位的key值(即大于指定key的最小key值)。如果该Map为空或不存在这样的key- -value对,则都返回 null</p>
</li>
<li><p>Map. Entry lowerEntry(Object key):返回该Map中位于key前一位的key- -value对(即小于指定key的最大key所对应的key- -value对)。如果该Map为空或不存在这样的key- -value对,则都返回null</p>
</li>
<li><p>Object lowerKey(Object key):返回该Map中位于key前一位的key值(即小于指定key的最大key值)。如果该Map为空或不存在这样的key,则都返回 null</p>
</li>
<li><p>NavigableMap subMap(Object fromKey boolean fromInclusive, Object toKey, booleantoInclusive):返回该Map的子Map,其key的范围是从 fromKey(是包括取决于第二个参数)到 toKey(是否包括取决于第四个参数)</p>
</li>
<li><p>SortedMap subMap(Object fromKey, Object toKey):返回该Map的子Map,其key的范围是从fromKey（包括）到toKey（不包括）。</p>
</li>
<li><p>SortedMap tailMap(Object fromKey)：返回Map的子Map，其key的范围是大于fromKey（是否包括取决于第二参数）的所有key。</p>
</li>
</ul>
<p>表面复杂，实则简单，因为TreeMap中的key-value对是有序的，所以增加了访问第一个、前一个、后一个、最后一个、key-value对的方法，并提供了几个从TreeMap中截取子TreeMap的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">U</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">U</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;R[count:&quot;</span>+count+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	根据count判断两个对象是否相等</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equanls</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> != <span class="literal">null</span> &amp;&amp; obj.getClass() == U.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (U)obj;</span><br><span class="line">			<span class="keyword">return</span> r.count == <span class="built_in">this</span>.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (U)obj;</span><br><span class="line"><span class="comment">//		count前省略this,在方法中调用同一个类中的实例，可省略</span></span><br><span class="line">		<span class="keyword">return</span> count&gt;r.count?<span class="number">1</span>: count&lt;r.count?-<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">		tm.put(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">3</span>), <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">		tm.put(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">9</span>), <span class="string">&quot;789&quot;</span>);</span><br><span class="line">		tm.put(<span class="keyword">new</span> <span class="title class_">U</span>(-<span class="number">5</span>), <span class="string">&quot;4569&quot;</span>);</span><br><span class="line">		System.out.println(tm);</span><br><span class="line"><span class="comment">//		返回该TreeMap的第一个Entry对象</span></span><br><span class="line">		System.out.println(tm.firstEntry());</span><br><span class="line"><span class="comment">//		返回该TreeMap的最后一个key值</span></span><br><span class="line">		System.out.println(tm.lastKey());</span><br><span class="line"><span class="comment">//		返回该TreeMap的比new U(2)大的最小的key值</span></span><br><span class="line">		System.out.println(tm.higherKey(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">//		返回该TreeMap的比new R(2)最小的key-value对</span></span><br><span class="line">		System.out.println(tm.lowerEntry(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">//		返回该TreeMap的子TreeMap</span></span><br><span class="line">		System.out.println(tm.subMap(<span class="keyword">new</span> <span class="title class_">U</span>(-<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">4</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用该U对象作为TreeMap的key，该TreeMap采用自然排序</p>

        <h3 id="8-6-6-WeakHashMap-实现类"   >
          <a href="#8-6-6-WeakHashMap-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-6-WeakHashMap-实现类" class="headerlink" title="8.6.6 WeakHashMap 实现类"></a>8.6.6 WeakHashMap 实现类</h3>
      <p>HashMap的key保留了对实际对象的强引用，这意味着只要HashMap对象不被销毁，该HashMap的所有key所引用的对象就不会被垃圾回收，HashMap也不会自动删除这些key对应的key-value第；但WeakHashMap对象的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象将可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的键值对。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">whm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>();</span><br><span class="line"><span class="comment">//		三个key都是匿名字符串对象（没有其他引用）</span></span><br><span class="line">		whm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;语文&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;良好&quot;</span>));</span><br><span class="line">		whm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;数学&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;满分&quot;</span>));</span><br><span class="line">		whm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;英语&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;优秀&quot;</span>));</span><br><span class="line"><span class="comment">//		向WeakHashMap中添加一个键值对</span></span><br><span class="line"><span class="comment">//		该key是一个系统缓存的字符串对象</span></span><br><span class="line">		whm.put(<span class="string">&quot;java&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;中等&quot;</span>));</span><br><span class="line">		System.out.println(whm);</span><br><span class="line">		whm.forEach((key,value)-&gt;System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+value));</span><br><span class="line"><span class="comment">//		通知系统回收垃圾</span></span><br><span class="line">		System.gc();</span><br><span class="line">		System.runFinalization();</span><br><span class="line"><span class="comment">//		通常情况下，只能看到一组</span></span><br><span class="line">		System.out.println(whm);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用forEach（正则表达式）方法遍历集合，被删除的前三个键值对都是匿名的字符串对象，WeakHashMap只保留了他们的弱引用，这样垃圾回收是会自动删除这三个键值对。</p>
<p>第四个键值对的key是一个字符串直接常量，（系统会使用缓存池保留对该字符串对象的强引用），所以垃圾回收时不会回收他。</p>

        <h3 id="8-6-7-IdentityHashMap实现类"   >
          <a href="#8-6-7-IdentityHashMap实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-7-IdentityHashMap实现类" class="headerlink" title="8.6.7 IdentityHashMap实现类"></a>8.6.7 IdentityHashMap实现类</h3>
      <p>在IdentityHashMap中，当且仅当两个key严格相等(key1&#x3D;&#x3D;key2)的时候，IdentityHashMap才会认为两个key相等，对于普通的HashMap而言，只要key1和key2通过equals()方法比较返回true，且他们的hashCode()相等即可。</p>
<p>注意：IdentityHashMap是一个特殊的Map实现类！此类实现Map接口时，他又以违反了Map的通常规范：IdentityHashMap要求只有两个key相等时才会认为两个key相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.IdentityHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityHashMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ihm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>();</span><br><span class="line">		ihm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;语文&quot;</span>), <span class="number">98</span>);</span><br><span class="line">		ihm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;语文&quot;</span>), <span class="number">99</span>);</span><br><span class="line">		ihm.put(<span class="string">&quot;Java&quot;</span>, <span class="number">99</span>);</span><br><span class="line">		ihm.put(<span class="string">&quot;Java&quot;</span>,<span class="number">100</span>);</span><br><span class="line">		ihm.forEach((key,value)-&gt;System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>前两个键值对是新创建的字符串对象，通过=&#x3D;比较不相同，所以会当成两个不相等的key，后两个是字符串直接量，=&#x3D;比较相等，所以传入了一对键值对。</p>

        <h3 id="8-6-8-EnumMap实现类"   >
          <a href="#8-6-8-EnumMap实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-8-EnumMap实现类" class="headerlink" title="8.6.8 EnumMap实现类"></a>8.6.8 EnumMap实现类</h3>
      <p>是一个与枚举类一起使用的Map实现，EnumMap中所有的key都必须是单个枚举类型的枚举值。创建EnumMap时，必须显示或隐式指定他对应的枚举类。有如下特征：</p>
<ul>
<li>以数组的形式保存，实现形式十分紧凑、高效</li>
<li>根据key的自然顺序来维护key-value对的顺序，当程序通过keySet()、entrySet()、values()等方法遍历EnumMap时可以看到这种顺序。</li>
<li>EnumMap不允许使用null作为key，但允许使用null作为value。</li>
</ul>
<p>与创建普通的Map有所区别的是，创建EnumMap时必须指定一个枚举类，从而将该EnumMap和指定枚举类关联起来。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span></span><br><span class="line">&#123;</span><br><span class="line">	SPRING,SUMMER,FALL,WINTER</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">enumMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnumMap</span>(Season1.class);</span><br><span class="line">		enumMap.put(Season1.FALL, <span class="string">&quot;秋风瑟瑟&quot;</span>);</span><br><span class="line">		enumMap.put(Season1.SPRING, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">		System.out.println(enumMap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>创建该EnumMap对象时指定它的key只能是Season枚举类的枚举值，向EnumMap添加了键值对后，这两个键值对会按Season枚举值的自然顺序排序。</p>

        <h3 id="8-6-9-各Map实现类的性能分析"   >
          <a href="#8-6-9-各Map实现类的性能分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-9-各Map实现类的性能分析" class="headerlink" title="8.6.9 各Map实现类的性能分析"></a>8.6.9 各Map实现类的性能分析</h3>
      <p>对于Map的常用实现类而言，HashMap通常比Hashtable快。</p>
<p>TreeMap通常比HashMap和Hashtable要慢（尤其在插入、删除key-value对时更慢），因为TreeMap底层采用红黑树来管理键值对（红黑树的每个节点就是一个键值对）。</p>
<p>使用TreeMap有一个好处：TreeMap中的键值对总是要处于有序状态，无须专门进行排序操作。放TreeMap被谭崇之后，就可以调用keySet()，去得有key组成的Set，然后使用toArray()方法生成key的数组，接下来使用Arrays的binarySearch()方法在已排序的数组中快速查询对象。</p>
<p>对于一般的场景一般采用HashMap,因为HashMap正是为快速查询设计的（HashMap底层其实也是采用数组来存储键值对）。但如果城西需要一个总是排好序的Map时，则可以考虑TreeMap。</p>
<p>LinkedHashMap比HashMap慢一点，因为他需要维护链表来爆出Map中的键值对的添加顺序。只是他使用&#x3D;&#x3D;而不是equals()方法来判断元素相等。EnumMap的性能最好，但它只能使用同一枚举值作为key。</p>

        <h2 id="8-8-操作集合的工具类：Collections"   >
          <a href="#8-8-操作集合的工具类：Collections" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-操作集合的工具类：Collections" class="headerlink" title="8.8 操作集合的工具类：Collections"></a>8.8 操作集合的工具类：Collections</h2>
      
        <h3 id="8-8-1-排序操作"   >
          <a href="#8-8-1-排序操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-1-排序操作" class="headerlink" title="8.8.1 排序操作"></a>8.8.1 排序操作</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		nums.add(<span class="number">2</span>);</span><br><span class="line">		nums.add(-<span class="number">5</span>);</span><br><span class="line">		nums.add(<span class="number">3</span>);</span><br><span class="line">		nums.add(<span class="number">0</span>);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		Collections.reverse(nums);<span class="comment">//次序反转.</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		Collections.sort(nums);<span class="comment">//自然排序</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		Collections.shuffle(nums);<span class="comment">//将List集合元素按随机顺序排序</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShowHand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义游戏做多支持多个个玩家</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PLAY_NUM</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">//	定义扑克牌的所有花色和数值</span></span><br><span class="line">	<span class="keyword">private</span> String[] types = &#123;</span><br><span class="line">			<span class="string">&quot;方块&quot;</span>,<span class="string">&quot;草花&quot;</span>,<span class="string">&quot;红心&quot;</span>,<span class="string">&quot;黑桃&quot;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">private</span> String[] values = &#123;</span><br><span class="line">			<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;A&quot;</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//	cards是以巨额游戏中剩下的扑克牌</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt;cards = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//	定义所有玩家</span></span><br><span class="line">	<span class="keyword">private</span> String[] players = <span class="keyword">new</span> <span class="title class_">String</span>[PLAY_NUM];</span><br><span class="line"><span class="comment">//	所有玩家手上的扑克牌</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt;[] playersCards = <span class="keyword">new</span> <span class="title class_">List</span>[PLAY_NUM];</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化扑克牌，放入52张扑克牌</span></span><br><span class="line"><span class="comment">	 * 并使用shuffle方法将它们按随机顺序排列</span></span><br><span class="line"><span class="comment">	 **/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initCodes</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;types.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;values.length;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cards.add(types[i]+values[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.shuffle(cards);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化玩家，为每个玩家分派用户名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPlayer</span><span class="params">(String...names)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(names.length&gt;PLAY_NUM||names.length&lt;<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			检验玩家数量，此处使用异常机制更合理</span></span><br><span class="line">			System.out.println(<span class="string">&quot;玩家数量不对&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			初始化玩家用户名</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;names.length;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				players[i] = names[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化玩家手中的扑克牌，开始游戏时，每个玩家手上的扑克牌为空</span></span><br><span class="line"><span class="comment">	 * 程序使用一个长度为0的LinkedList表示</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPlayerCards</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;players.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span> &amp;&amp; !players[i].equals(<span class="string">&quot;&quot;</span>));</span><br><span class="line">			&#123;</span><br><span class="line">				playersCards[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 输出全部扑克牌，该功能没有具体功能，只用来测试</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAllCards</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> card:cards)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(card);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 派发扑克牌</span></span><br><span class="line"><span class="comment">	 * @param first最先派给谁</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dellvarCard</span><span class="params">(String first)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		调用ArrayUtils工具类search方法</span></span><br><span class="line"><span class="comment">//		查询出指定元素在数组中的索引</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">firstPos</span> <span class="operator">=</span> Arrays.binarySearch(players,first);</span><br><span class="line"><span class="comment">//		依次给位于该指定原价之后的每个玩家之后的每个玩家派发扑克牌</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> firstPos;i&lt;PLAY_NUM;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				playersCards[i].add(cards.get(<span class="number">0</span>));</span><br><span class="line">				cards.remove(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		依次给位于该指定玩家之前的每个玩家派扑克牌</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;firstPos;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				playersCards[i].add(cards.get(<span class="number">0</span>));</span><br><span class="line">				cards.remove(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 输出玩家手中的扑克牌</span></span><br><span class="line"><span class="comment">	 * 实现该方法时，应该控制每个玩家看不到别人的第一张牌，但此处没有增加这个功能</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPlayerCards</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;PLAY_NUM;i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			当玩家不为空时</span></span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				输出玩家</span></span><br><span class="line">				System.out.println(players[i]+<span class="string">&quot; :   &quot;</span>);</span><br><span class="line"><span class="comment">//				遍历输出玩家手上的扑克牌</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">var</span> card:cards)</span><br><span class="line">				&#123;</span><br><span class="line">					System.out.println(card+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShowHand</span>();</span><br><span class="line">		sh.initPlayer(<span class="string">&quot;Mr.Douji&quot;</span>,<span class="string">&quot;Mr.Heizhu&quot;</span>,<span class="string">&quot;Mr.Chao&quot;</span>);</span><br><span class="line">		sh.initCodes();</span><br><span class="line">		sh.initPlayerCards();</span><br><span class="line"><span class="comment">//		下面测试所有扑克牌，没有实际意义</span></span><br><span class="line">		sh.showAllCards();</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"><span class="comment">//		下面从Mr.Heizhu开始发牌</span></span><br><span class="line">		sh.dellvarCard(<span class="string">&quot;Mr.Heizhu&quot;</span>);</span><br><span class="line">		sh.showPlayerCards();</span><br><span class="line">		sh.dellvarCard(<span class="string">&quot;Mr.Douji&quot;</span>);</span><br><span class="line">		sh.showPlayerCards();</span><br><span class="line">		sh.dellvarCard(<span class="string">&quot;Mr.Chao&quot;</span>);</span><br><span class="line">		sh.showPlayerCards();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="8-8-2-查找、替换操作"   >
          <a href="#8-8-2-查找、替换操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-2-查找、替换操作" class="headerlink" title="8.8.2 查找、替换操作"></a>8.8.2 查找、替换操作</h3>
      <p>Collections还提供了常用的用于查找、替换集合元素的类方法。</p>
<ul>
<li>int binarySeach(List list , Object key)：使用二分搜索法搜索指定的List集合，以获取指定对象在List集合中的索引，如果要使该方法可以正常工作，则必须保证List集合已经处于有序状态。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeachTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		nums.add(<span class="number">2</span>);</span><br><span class="line">		nums.add(-<span class="number">5</span>);</span><br><span class="line">		nums.add(<span class="number">3</span>);</span><br><span class="line">		nums.add(<span class="number">0</span>);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		System.out.println(Collections.max(nums));</span><br><span class="line">		System.out.println(Collections.min(nums));</span><br><span class="line">		Collections.replaceAll(nums, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//0用1换</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		<span class="comment">//-5在集合中出现的次数</span></span><br><span class="line">		System.out.println(Collections.frequency(nums, -<span class="number">5</span>));</span><br><span class="line">		Collections.sort(nums);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line"><span class="comment">//		只有排序后的List集合才能用二分法查询</span></span><br><span class="line">		System.out.println(Collections.binarySearch(nums, -<span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="8-8-3-同步控制"   >
          <a href="#8-8-3-同步控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-3-同步控制" class="headerlink" title="8.8.3 同步控制"></a>8.8.3 同步控制</h3>
      <p>Collections类中提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</p>
<p>Java中常用的集合框架中的实现类HashSet、TreeSet、ArrayList、LinkedList、HashMap和TreeMap都是线程不安全的。如果有个多线程访问他们，而且有炒一个的线程试图修改他们，则存在线程安全问题。Collections提供了多个类方法可以把它们包装成线程同步的集合。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		下面程序创建了4个线程安全的集合对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> Collections.synchronizedCollection(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">		<span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">		<span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>());</span><br><span class="line">		<span class="type">var</span> <span class="variable">m</span> <span class="operator">=</span> Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>直接将新创建的集合传给Collections的synchronizedXxx()方法，这样做可以直接获取Set和Map的线程安全实现版本。</p>

        <h3 id="8-8-4-设置不可变集合"   >
          <a href="#8-8-4-设置不可变集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-4-设置不可变集合" class="headerlink" title="8.8.4 设置不可变集合"></a>8.8.4 设置不可变集合</h3>
      <p>Collection 提供了三个类方法返回一个不可变类的集合。</p>
<p>三个类方法的参数是原有的集合对象，返回值是该集合的“只读版本”通过Collections提供的三个类方法，可以生成“只读”的Collections或Map。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个空的、不可变的List对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">unmodifiableList</span> <span class="operator">=</span> Collections.emptyList();</span><br><span class="line"><span class="comment">//		创建一个只有一个元素、且不可变的Set对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">unmodifiableSet</span> <span class="operator">=</span> Collections.singleton(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		创建一个普通的Map对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">scores</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		scores.put(<span class="string">&quot;语文&quot;</span>, <span class="number">90</span>);</span><br><span class="line">		scores.put(<span class="string">&quot;数学&quot;</span>, <span class="number">70</span>);</span><br><span class="line"><span class="comment">//		返回普通的Map对象对应的不可变版本</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">unmodifiableMap</span> <span class="operator">=</span> Collections.unmodifiableMap(scores);</span><br><span class="line"><span class="comment">//		下面任意一行都会引起异常</span></span><br><span class="line">		unmodifiableList.add(<span class="string">&quot;测试元素&quot;</span>);</span><br><span class="line">		unmodifiableSet.add(<span class="string">&quot;测试元素&quot;</span>);</span><br><span class="line">		unmodifiableMap.put(<span class="string">&quot;测试元素&quot;</span>,<span class="number">90</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>不可变的集合对象只能访问集合元素，不可修改集合元素。</p>

        <h3 id="8-8-5-Java-9-新增的不可变集合"   >
          <a href="#8-8-5-Java-9-新增的不可变集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-5-Java-9-新增的不可变集合" class="headerlink" title="8.8.5 Java 9 新增的不可变集合"></a>8.8.5 Java 9 新增的不可变集合</h3>
      <p>以前假设要创建一个包含6个元素的Set集合，程序需要先创建Set集合，然后调用6次add方法向Set集合中添加元素。Java 9对此进行了简化，程序直接调用Set、List、Map的of()方法集合创建包含N个元素不可变集合，这样一行代码就可以创建包含N个元素的集合。</p>
<p>不可变意味着程序不能向集合中添加元素，也不能从集合中删除元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java9Collection</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建包含四个元素的Set集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">set</span> <span class="operator">=</span> Set.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Kitlin&quot;</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Swift&quot;</span>);</span><br><span class="line">		System.out.println(set);</span><br><span class="line"><span class="comment">//		不可变集合，下面代码导致错误</span></span><br><span class="line"><span class="comment">//		set.add(&quot;Ruby&quot;);</span></span><br><span class="line"><span class="comment">//		System.out.println(set);</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> List.of(<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">98</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line"><span class="comment">//		list.add(78);</span></span><br><span class="line"><span class="comment">//		System.out.println(list);</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> Map.of(<span class="string">&quot;语文&quot;</span>,<span class="number">89</span>,<span class="string">&quot;数学&quot;</span>,<span class="number">56</span>,<span class="string">&quot;Java&quot;</span>,<span class="number">100</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line"><span class="comment">//		map.put(&quot;c&quot;, 80);</span></span><br><span class="line"><span class="comment">//		System.out.println(map);</span></span><br><span class="line"><span class="comment">//		使用Map.entry()方法显示构造键值对</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">map2</span> <span class="operator">=</span> Map.ofEntries(Map.entry(<span class="string">&quot;语文&quot;</span>, <span class="number">100</span>),</span><br><span class="line">				Map.entry(<span class="string">&quot;数学&quot;</span>, <span class="number">78</span>)</span><br><span class="line">				,Map.entry(<span class="string">&quot;英语&quot;</span>, <span class="number">65</span>));</span><br><span class="line">		System.out.println(map2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面示范了如何使用集合元素创建不可变集合，其中Set、List比较简单，程序只需要为他们的of方法传入N个集合元素集合创建对应的集合。</p>
<p>创建不可变的Map集合有两个方法：使用of方法时只需要一次传入多个键值对即可；还可以用ofEntries()方法，该方法接受多个Entry对象，因此程序显式使用Map.entry()方法来创建Map.Entry对象。</p>

        <h2 id="8-9-繁琐的接口Enumeration"   >
          <a href="#8-9-繁琐的接口Enumeration" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-9-繁琐的接口Enumeration" class="headerlink" title="8.9 繁琐的接口Enumeration"></a>8.9 繁琐的接口Enumeration</h2>
      <p>现在不用Enumeration，使用Itreator迭代器。</p>
<p>在计算机行业有一条规则：加入任何规则都需要慎之又慎，因为使用后无法删除规则。</p>

        <h2 id="8-10-本章小结"   >
          <a href="#8-10-本章小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-10-本章小结" class="headerlink" title="8.10 本章小结"></a>8.10 本章小结</h2>
      <p>本章详细介绍了Java集合框架的相关知识。本章从Java的集合框架体系开始讲起，概述了Java集合框架的4个主要体系：Set、List、Quere和Map，并简述了集合在编程中的重要性。本章详细介绍了Java 8对集合框架的改进，包括使用Lambda表达式简化集合编程，一节集合的Stream编程等。详细介绍了四个主要体系的接口及其实现类的详细用法，并升入分析了各种实现类实现机制的差异，并给出了选择集合实现类时的原则。本章从原理上刨铣了Map结构特征，以及Map结构和Set、List之间的区别和联系。最后通过梭哈游戏示范了Collections工具类的基本用法。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/c%E8%AF%AD%E8%A8%80/">C语言</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="C语言概述"   >
          <a href="#C语言概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1>
      <p>如何看懂一个程序</p>
<p>​		1.流程<br>​				2.每个语句的功能<br>​				3.试数</p>
<p>课程计划<br><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151051163.png" alt="image-20220603153216655"></p>
<p>举例子，一元二次函数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//把三个系数保存到计算机中</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">	<span class="type">double</span> delta; <span class="comment">//delta存放的是b*b - 4*a*c</span></span><br><span class="line">	<span class="type">double</span> x1; <span class="comment">//存放一元二次方程的其中一个解 </span></span><br><span class="line">	<span class="type">double</span> x2; <span class="comment">//存放一元二次方程的其中一个解 </span></span><br><span class="line">	</span><br><span class="line">	delta = b*b - <span class="number">4</span>*a*c;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(delta &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x1 = (-b + <span class="built_in">sqrt</span>(delta)) / <span class="number">2</span>*a;</span><br><span class="line">		x2 = (-b - <span class="built_in">sqrt</span>(delta)) / <span class="number">2</span>*a;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;该一元二次方程有两个解，x1 = %f,x2 = %f&quot;</span>,x1,x2);</span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(delta =  <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x1 = (-b)/<span class="number">2</span>*a;</span><br><span class="line">		x2 = x1; <span class="comment">//把右边赋给左边</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;该一元二次方程有唯一一个解，x1 = x2 = %f&quot;</span>,x1); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;无解&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="C编程预备计算机专业知识"   >
          <a href="#C编程预备计算机专业知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#C编程预备计算机专业知识" class="headerlink" title="C编程预备计算机专业知识"></a>C编程预备计算机专业知识</h2>
      <ol>
<li><p>cpu  内存条  硬盘  显卡  主板  显示器  之间的关系<br>    如播放一个视频，操作系统在cpu的控制下将硬盘中的视频数据读到内存条中，在内存中进行处理，（因为cpu不能直接处理硬盘上的数据）之后才能被cpu执行，cpu将处理的图片数据送到显卡处理再输在显示器上，cpu控制将处理得到的声音送到声卡处理，再送到喇叭上发出声音。而主板是将各设备连接起来。</p>
</li>
<li><p>HelloWord程序是如何运行起来的<br>    编译软件通过编译和链接后生成.exe文件，然后编译软件对操作系统发出请求运行该.exe文件，操作系统调用cpu来执行。</p>
</li>
<li><p>什么是数据类型<br>    基本类型数据<br>               整数<br>                       整形				–		int				–		4<br>                       短整形			–		short int		–		2<br>                       长整形			–		long int	  	–		8<br>               浮点型<br>                       单精度			–		float	       	–		4<br>                       双精度			–		double       	–		8<br>               字符型<br>                       char		                                    	–		1<br>    一般来说习惯上用n,m,i,j,k 等表示int 类型的变量；c，ch 等表示字符类型变量；a 等表示数组；p 等表示指针。当然这仅仅是一般习惯，除了i,j,k 等可以用来表示循环变量外，别的字符变量名尽量不要使用。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10.6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c = %c\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​		复合类型数据<br>​				结构体<br>​				枚举<br>​				共用体（已淘汰）</p>
</li>
<li><p>什么是变量<br>   变量的本质就是内存中一段存储空间<br>   在定义一个变量时，就是在内存中给此变量分配一个存储空间，给变量赋值就是在分配的存储空间中存放相应的数据。当变量使用完毕后，内存空间将被释放。但内存空间中的垃圾数据并没有被清除，操作系统通过0和1标志来区分此空间是否被使用，这样内存的处理速度才更快。<br>   定义和声明的区别：定义分配内存，而声明则没有。定义只能出现一次，而声明可以出现多次</p>
</li>
<li><p>cpu  内存条  编译软件  操作系统之间的关系<br>   同上2</p>
</li>
<li><p>变量为什么必须得初始化（重点！）<br>       所谓初始化就是赋值的意思。<br>       如果不给变量初始化的话，系统会默认给变量一个很大初始值（有些编译软件会给未初始化的变量赋值为0），该初始值是上一个软件使用该内存后遗留下来的垃圾值（也叫填充字）（硬件中存储的都是0  1 组合的代码）。来提醒程序员该变量未初始化。<br>      补充内容：当运行一个软件时，操作系统将硬盘中的数据拷贝到内存条中；在使用该软件的时候，操作系统不在将此段内存空间分配给其它软件；当操作系统运行完毕后操作系统将回收该内存空间，（<strong>但是！操作系统并不会清空该内存空间遗留下来的数据</strong>&gt;）（操作系统中有一个系统分配表，如果该空间被使用了就写个1，没被使用就写个0，当系统回收该内存空间时，即把1改成0就好，一个一个改写内存空间的话太浪费时间了），以便在此分配给其他软件使用。<br>      综上所述，一个软件所分配到的空间中极可能存在着以前其它软件使用过后的残留数据，这些数据被称之为垃圾数据。所以通常情况下我们为一个变量，一个数组分配好内存空间后都要对该内存空间初始化！</p>
</li>
<li><p>如何定义变量<br>       数据类型 变量名 &#x3D; 要赋的值;<br>等价于<br>       数据类型 变量名；<br>       变量名 &#x3D; 要赋的值;<br>   e.g:<br>   int i &#x3D; 3; 等价于 int i; i &#x3D; 3; </p>
<p>   int i, j; </p>
<p>   等价于 int </p>
<p>   i; int j; </p>
<p>   int i , j &#x3D; 3; 等价于 int i; int j; j &#x3D; 3; </p>
<p>   int i &#x3D; 3, j &#x3D; 5; 等价于 int i; int j; i &#x3D;3; j &#x3D; 5; </p>
<p>   int i, j; i &#x3D; j &#x3D; 5; 等价于 int i, j; i &#x3D; 5; j &#x3D; 5;</p>
</li>
<li><p>什么是进制<br>       几进制就是逢几进一<br>       C语言规定八进制前要加0（注意是零不是o），十六进制前要加0x或者0X，十进制前什么都不加！<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053855.png" alt="image-20220604180157383"><br>   <img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053856.png" alt="image-20220604181916444"></p>
</li>
<li><p>常量在C语言中是如何表示的<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053857.png" alt="image-20220604210313733"><br> 整数<br>        十进制：     传统的写法<br>        十六进制： 初始化时前面加0x或0X<br>         八进制：    初始化时前面加0  （注意是零)<br> 浮点数<br>         传统的写法<br>                float x &#x3D; 3.2 ;  &#x2F;&#x2F;传统<br>          科学计数法<br>                float x &#x3D; 3.2e3;   &#x2F;&#x2F;表示 x &#x3D; 3200<br>                float x &#x3D; 123.45e-2    &#x2F;&#x2F;表示 x &#x3D; 1.2345<br>   字符型<br>          单个字符用单引号括起来<br>                  ‘A’表示字符A<br>   ​                   ‘AB’ 错误</p>
<p>   ​                   “AB”正确<br>   ​            字符串用双引号括起来<br>   ​                    “A”正确，因为”A”表示’A’和’\0’的组合<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053858.png" alt="image-20220604210445717"></p>
</li>
<li><p>常量以什么样的二进制代码存储在计算机中<br>   整数是以<strong>补码</strong>的形式转换为二进制代码存储在计算机中的<br>   实数是以IEEE754标准转换为二进制代码存储在计算机中的<br>   字符的本质实际上也是与整数的存储方式相同<br>   1、计算机在任何情况下都只能识别二进制<br>   2、计算机在底层存储数据的时候，一律存储的是“二进制的补码形式”计算机采用补码形式存储数据的原因是：补码形式效率最高。<br>   3、什么是补码呢？<br>   实际上是这样的，二进制有：原码 反码 补码<br>   注：一个二进制数，首位0表示该数是正数，首位是1表示该数是负数。<br>   二、正文<br>   对于一个正数来说：二进制原码、反码、补码是同一个，完全相同。</p>
<pre><code>   int i = 1;
</code></pre>
<p>   对应的二进制原码：00000000 00000000 00000000 00000001<br>   对应的二进制反码：00000000 00000000 00000000 00000001<br>   对应的二进制补码：00000000 00000000 00000000 00000001<br>   对于一个负数来说：二进制原码、反码、补码是什么关系呢？</p>
<pre><code>   byte i = -1;
</code></pre>
<p>   对应的二进制原码：10000001<br>   对应的二进制反码：11111110（符号位不变，其它位取反）<br>   对应的二进制补码：11111111（反码+1）<br>   eg.分析 byte b &#x3D; (byte)150;——&gt;这个b是多少？</p>
   <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int类型的4个字节的150的二进制码是什么？</span><br><span class="line">00000000 00000000 00000000 10010110</span><br><span class="line"></span><br><span class="line">将以上的int类型强制类型转为1个字节的byte，最终在计算机中的二进制码是：  10010110</span><br><span class="line"></span><br><span class="line">千万要注意：计算机永远存储的都是二进制补码形式。也就是说上面</span><br><span class="line"></span><br><span class="line">10010110 这个是一个二进制补码形式，你可以采用逆推导的方式推算出</span><br><span class="line">这个二进制补码对应的原码是啥：</span><br><span class="line">	10010110 ---&gt; 二进制补码形式（反码-1）⬇</span><br><span class="line">	10010101 ---&gt; 二进制反码形式（符号位不变，其它位取反）⬇</span><br><span class="line">	11101010 ---&gt; 二进制原码形式 </span><br></pre></td></tr></table></div></figure>

</li>
<li><p>代码规范化<br>代码可读性更强【容易让自己和别人更清楚地看懂程序】<br>使程序更不容易出错</p>
</li>
<li><p>什么是字节<br> 字节就是存储数据的单位，并且是硬件能够访问的最小单位<br> 1字节 &#x3D; 8位<br> 1K &#x3D; 1024字节<br> 1M &#x3D; 1024K<br> 1T &#x3D; 1024M</p>
</li>
<li><p>不同类型数据之间相互赋值的问题<br> 暂不考虑</p>
 <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">45</span>: </span><br><span class="line"><span class="type">long</span> j = <span class="number">102345</span>; </span><br><span class="line">i = j; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld %d\n&quot;</span>,i,j);</span><br><span class="line"><span class="type">float</span> x = <span class="number">6.6</span>; </span><br><span class="line"><span class="type">double</span> y = <span class="number">8.8</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f %lf\n&quot;</span>, x, y);</span><br></pre></td></tr></table></div></figure>

<ol>
<li>什么是ASCII<br>  ASCII不是个值，而是一种《规定》<br>  ASCII规定了不同的字符是使用哪个整数值去表示<br>  它规定了<br>  ‘A’ – 65<br>  B ‘ – 66<br>  a’ - - 97<br>  ‘b’ – 98<br>  ‘0’ – 48</li>
</ol>
</li>
<li><p>字符的存储[字符本质上与整数的存储方式相同]</p>
</li>
</ol>

        <h2 id="基本的输入输出函数的用法"   >
          <a href="#基本的输入输出函数的用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本的输入输出函数的用法" class="headerlink" title="基本的输入输出函数的用法"></a>基本的输入输出函数的用法</h2>
      
        <h3 id="printf-——-将变量的内容输出到显示器上"   >
          <a href="#printf-——-将变量的内容输出到显示器上" class="heading-link"><i class="fas fa-link"></i></a><a href="#printf-——-将变量的内容输出到显示器上" class="headerlink" title="printf()  ——  将变量的内容输出到显示器上"></a>printf()  ——  将变量的内容输出到显示器上</h3>
      <p>​		四种用法<br>​				1.printf(“字符串”);</p>
<p>​				2.printf(“输出控制符”,输出参数);</p>
<p>​				3.printf(“输出控制符1 输出控制符2 。。。”，输出参数1，输出参数2.。。。)</p>
<p>​				4.printf(“输出控制符，非输出控制符”,输出参数) ; </p>
<div class="table-container"><table>
<thead>
<tr>
<th>输出控制符</th>
<th>输出参数类型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>%ld</td>
<td>long int</td>
<td></td>
</tr>
<tr>
<td>%c</td>
<td>char</td>
<td></td>
</tr>
<tr>
<td>%f</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>%lf</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>%x(或者%X或者%#X)</td>
<td>int 或 long int 或 short int</td>
<td></td>
</tr>
<tr>
<td>%0</td>
<td>同上</td>
<td></td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
<td></td>
</tr>
<tr>
<td>输出十进制：</td>
<td>%d</td>
<td></td>
</tr>
<tr>
<td>输出十六进制：</td>
<td>%x</td>
<td></td>
</tr>
<tr>
<td>输出单个字符：</td>
<td>%c</td>
<td></td>
</tr>
<tr>
<td>输出字符串：</td>
<td>%s</td>
<td></td>
</tr>
<tr>
<td>输出变量所在的地址：</td>
<td>%p</td>
<td></td>
</tr>
</tbody></table></div>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	1.printf(&quot;字符串&quot;);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;哈哈&quot;</span>); 			<span class="comment">//\n表示换行 </span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	2.printf(&quot;输出控制符&quot;,输出参数);</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>,i);			<span class="comment">//输出控制符是用来确定把二进制代码到底以什么样的形式进行输出的 </span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	 3.printf(&quot;输出控制符1 输出控制符2 。。。&quot;，输出参数1，输出参数2.。。。)</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,j,k); </span><br><span class="line">	</span><br><span class="line"><span class="comment">//	4.printf(&quot;输出控制符，非输出控制符&quot;,输出参数) ; </span></span><br><span class="line">	<span class="type">int</span> m = <span class="number">50</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%#X\n&quot;</span>,m);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为什么需要输出控制符</p>
<ol>
<li><p>二进制代码 0 1 组成的代码可以表示数据也可以表示指令</p>
</li>
<li><p>如果01组成的代码表示的是数据的话，那么同样的01代码组合以不同的输出格式输出就会有不同的输出结果</p>
</li>
</ol>

        <h3 id="scanf-【通过键盘将数据输入到变量中】"   >
          <a href="#scanf-【通过键盘将数据输入到变量中】" class="heading-link"><i class="fas fa-link"></i></a><a href="#scanf-【通过键盘将数据输入到变量中】" class="headerlink" title="scanf()【通过键盘将数据输入到变量中】"></a>scanf()【通过键盘将数据输入到变量中】</h3>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053859.png" alt="image-20220607203648850"></p>
<p>​		两种用法:</p>
<p>​				用法一：scanf(“输入控制符”,输入参数);</p>
<p>​				功能：将键盘输入的字符转换为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);	<span class="comment">//&amp;i 表示i的地址 &amp;是一个取地址符</span></span><br><span class="line">	<span class="comment">//%d的作用：把键盘输入的这些合法的字符转换为一个10进制数字 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,i);</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>​				用法二：scanf(“非输入控制符 输入控制符”,输入参数);</p>
<p>​				功能：将键盘输入的字符转换为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中，非输入控制符必须原样输入</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;m%d&quot;</span>,&amp;i);	<span class="comment">//m123 正确的输入，123是非法的输入 </span></span><br><span class="line">	<span class="comment">//此处就算输入其它字母也都会被认为是非法字符，因为这里的输入控制符是%d而不是%c </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>​			如何使用scanf编写出高质量代码</p>
<p>​					1.使用scanf之前最好先使用printf提示用户以什么样的方式来输入</p>
<p>​					2.scanf中尽量不要使用非输入控制符，尤其不要使用\n</p>
<p>​					3.应该编写代码对用户的非法输入做适当的处理</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入两个数，以空格隔开\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;i,&amp;j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d,j = %d\n&quot;</span>,i,j);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//过滤垃圾字符</span></span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="运算符"   >
          <a href="#运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053860.png" alt="image-20220607204020895"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053862.png" alt="image-20220608125055036"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d %d \n&quot;</span>,<span class="number">3</span>%<span class="number">3</span>,<span class="number">13</span>%<span class="number">-3</span>,<span class="number">-13</span>%<span class="number">3</span>,<span class="number">-13</span>%<span class="number">-3</span>,<span class="number">-13</span>%<span class="number">23</span>,<span class="number">3</span>%<span class="number">5</span>);</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果是：</span></span><br><span class="line"><span class="comment">	-------------------------</span></span><br><span class="line"><span class="comment">	0 1 -1 -1 -13 3</span></span><br><span class="line"><span class="comment">	------------------------- </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	总结：取余%的运算对象必须是整数，结果是整除后的余数,其余数的符号和被除数相同</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053863.png" alt="image-20220607204045076"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> m,n,b;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	m = (3 &gt; 2) &amp;&amp; (k = 8);</span></span><br><span class="line"><span class="comment">//	printf(&quot;m = %d,k = %d\n&quot;,m,k);//m = 1,k = 8</span></span><br><span class="line"></span><br><span class="line">	b = (<span class="number">3</span> &gt; <span class="number">2</span>) &amp;&amp; (k = <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b = %d,k = %d\n&quot;</span>,b,k);<span class="comment">//b = 0,k = 0</span></span><br><span class="line">	</span><br><span class="line">	n = (<span class="number">3</span> &lt; <span class="number">2</span>) &amp;&amp; (k = <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;n = %d,k = %d\n&quot;</span>,n,k);<span class="comment">//n = 0,k = 20</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>


        <h2 id="流程控制【第一个重点】"   >
          <a href="#流程控制【第一个重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程控制【第一个重点】" class="headerlink" title="流程控制【第一个重点】"></a>流程控制【第一个重点】</h2>
      <p>什么是流程控制</p>
<p>​		程序代码执行的顺序</p>
<p>流程控制的分类</p>

        <h3 id="顺序"   >
          <a href="#顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3>
      <p>自上而下依次执行</p>

        <h3 id="选择"   >
          <a href="#选择" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择" class="headerlink" title="选择"></a>选择</h3>
      <p>​				定义</p>
<p>​						某些代码可能执行，也可能不执行，有选择的执行某些代码</p>
<p>​				分类</p>

        <h4 id="if"   >
          <a href="#if" class="heading-link"><i class="fas fa-link"></i></a><a href="#if" class="headerlink" title="if"></a>if</h4>
      <p>1.if最简单的用法</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	<span class="keyword">if</span>(表达式)</span><br><span class="line">		语句</span><br><span class="line">功能：</span><br><span class="line">	如果表达式为真，执行语句</span><br><span class="line">	如果表达式为假，不执行语句</span><br></pre></td></tr></table></div></figure>

<p>2.if的范围问题</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">	语句A;</span><br><span class="line">	语句B;</span><br><span class="line">解释：<span class="keyword">if</span>默认只能控制语句A的执行或不执行，无法控制语句B的执行或不执行，或者说语句B一定会执行</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">	语句A;</span><br><span class="line">	语句B;</span><br><span class="line">&#125;</span><br><span class="line">此时<span class="keyword">if</span>可以控制语句A和语句B</span><br><span class="line">    由此可见：<span class="keyword">if</span>只能控制一个语句的执行或不执行，如果想控制多个语句，就必须把这些语句用&#123;&#125;阔起来</span><br></pre></td></tr></table></div></figure>


        <h4 id="if…else…"   >
          <a href="#if…else…" class="heading-link"><i class="fas fa-link"></i></a><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h4>
      <p>4.if…else if…else…的用法</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) </span><br><span class="line">	A: </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span>) </span><br><span class="line">	B: </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span>) </span><br><span class="line">	C: </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	D;</span><br></pre></td></tr></table></div></figure>

<p>5.C语言对真假的处理</p>
<p>非零是真<br>        零就是假<br>        真用1表示<br>        假用零表示</p>
<p>6.if举例–求分数的等级</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的成绩：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;score);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(score &gt; <span class="number">100</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;在做梦吧？\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;优秀\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">90</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;良好\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span> &amp;&amp; score &lt;= <span class="number">80</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">60</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>两数交换</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入i的值：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入j的值：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	</span><br><span class="line">	temp = i;</span><br><span class="line">	i = j;</span><br><span class="line">	j = temp;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;两变量交换后的值为：i = %d,j = %d\n&quot;</span>,i,j);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>三数排序</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路</span><br><span class="line">如果a &gt; b </span><br><span class="line">	则a与c做比较，a &gt; c则输出a，a &lt; c则输出c</span><br><span class="line">否则（a&lt;b）</span><br><span class="line">	b与c作比较，b &gt; c则输出b，b &lt; c则输出c</span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修改思路</span><br><span class="line">如果 a &lt; b</span><br><span class="line">	则a与b交换位置</span><br><span class="line">如果 a &lt; c</span><br><span class="line">	则a与c交换位置</span><br><span class="line">如果 b &lt; c</span><br><span class="line">	则b与c交换位置</span><br><span class="line">输出a,b,c</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请随意输入三个数，以空格隔开&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(a &lt; c)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = a;</span><br><span class="line">		a = c;</span><br><span class="line">		c = temp;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">if</span>(b &lt; c)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = b;</span><br><span class="line">		b = c;</span><br><span class="line">		c = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,a,b,c);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="补充："   >
          <a href="#补充：" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">小算法的程序:</span><br><span class="line">判断一个数字是否是素数</span><br><span class="line">判断一个数字是否是回文数</span><br><span class="line">编程实现求一个十进制数字的二进制形式</span><br><span class="line">求一个数字的每位是奇数的数字取出来组合形成的新数字</span><br><span class="line">求一个数字倒过来的数字</span><br><span class="line"></span><br><span class="line">如何一些小算法的程序</span><br><span class="line">尝试自己去编程解决它，大部分人都自己无法解如果解决不了，就看答案</span><br><span class="line">关键是把答案看懂，这个要花很大的精力，也是我们学习的重点</span><br><span class="line">看懂之后尝试自己去修改程序，并且知道修改之后程序的不同输出结果的含义</span><br><span class="line">照着程序去敲</span><br><span class="line">调试错误</span><br><span class="line">不看答案，自己独立把答案敲出来</span><br><span class="line">如果程序实在无法彻底理解， 就把它背会</span><br></pre></td></tr></table></div></figure>

<p>7.if常见问题解析</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1.空语句的问题</span><br><span class="line">	if (3 &gt; 2);</span><br><span class="line">	等价于</span><br><span class="line">	if (3 &gt; 2)</span><br><span class="line">		;//这是一个空语句</span><br><span class="line">		</span><br><span class="line">2.</span><br><span class="line">	if (表达式1)</span><br><span class="line">		A;</span><br><span class="line">	else </span><br><span class="line">		B;</span><br><span class="line">	是正确的</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if (表达式1);</span><br><span class="line">		A;</span><br><span class="line">	else </span><br><span class="line">		B;</span><br><span class="line">	是错误的</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">	if(表达式1)</span><br><span class="line">		A;</span><br><span class="line">	else if(表达式2)</span><br><span class="line">		B;</span><br><span class="line">	else if(表达式3)</span><br><span class="line">		C;</span><br><span class="line">	else</span><br><span class="line">		D;</span><br><span class="line">	即使表达式1和2都成立，也只执行A语句</span><br><span class="line">	</span><br><span class="line">4.</span><br><span class="line">	if(表达式1)</span><br><span class="line">		A;</span><br><span class="line">	else if(表达式2)</span><br><span class="line">		B;</span><br><span class="line">	else if(表达式3)</span><br><span class="line">		C;</span><br><span class="line">	这样写不会报错，但是逻辑上有问题，相当于缺少最后一个约束条件(else的条件)</span><br><span class="line">	</span><br><span class="line">5.</span><br><span class="line">	if(表达式1)</span><br><span class="line">		A;</span><br><span class="line">	else if(表达式2)</span><br><span class="line">		B;</span><br><span class="line">	else if(表达式3)</span><br><span class="line">		C;</span><br><span class="line">	else(表达式4)</span><br><span class="line">		D;</span><br><span class="line">	这样的写法是不对的(报语法错误)，要不然去掉48行的表达式4，要不然在48行的else后加if</span><br><span class="line">	</span><br><span class="line">6.</span><br><span class="line">	if(表达式1)</span><br><span class="line">		A;</span><br><span class="line">	else if(表达式2)</span><br><span class="line">		B;</span><br><span class="line">	else if(表达式3)</span><br><span class="line">		C;</span><br><span class="line">	else(表达式4);</span><br><span class="line">		D;</span><br><span class="line">	这样写语法不会出错，但逻辑上是错误的</span><br><span class="line">	相当于</span><br><span class="line">		else</span><br><span class="line">			(表达式);</span><br><span class="line">		D;</span><br></pre></td></tr></table></div></figure>


        <h4 id="switch"   >
          <a href="#switch" class="heading-link"><i class="fas fa-link"></i></a><a href="#switch" class="headerlink" title="switch"></a>switch</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入您要进入的楼层：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span>(val)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span>(<span class="number">1</span>):</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1层开！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span>(<span class="number">2</span>):</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2层开！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span>(<span class="number">3</span>):			<span class="comment">//程序的入口 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;3层开！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;			<span class="comment">//程序中的break表示着跳出switch，如果没有break，将一直运行到程序结束 </span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;还没盖呢！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;			<span class="comment">//去掉最后一行break不会再次循环回去，程序中switch运行完成 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053864.png" alt="image-20220628222954540"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053865.png" alt="image-20220628223157761"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053866.png" alt="image-20220628223222474"></p>

        <h3 id="循环"   >
          <a href="#循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环" class="headerlink" title="循环"></a>循环</h3>
      <p>什么是循环:</p>
<p>​		某些代码会被重复执行</p>
<p>循环的分类</p>

        <h4 id="for"   >
          <a href="#for" class="heading-link"><i class="fas fa-link"></i></a><a href="#for" class="headerlink" title="for"></a>for</h4>
      <ol>
<li>格式：</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>)</span><br><span class="line">	A;</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li><p>执行的流程【重点】</p>
<p>单个for循环的使用</p>
</li>
</ol>
<p>举例：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)</span><br><span class="line">		sum = sum + i;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">sum = 10</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">分析：for循环</span></span><br><span class="line"><span class="comment">进入循环，先执行i = 1，再执行i &lt;= 4，当满足语句2时，执行sum = sum + i;，循环体执行结束后执行i++，i自加（否则会成为一个死循环），至此，循环执行一次。之后再次执行语句2，来判断是否满足条件，满足继续执行循环体，不满足则跳出循环。</span></span><br><span class="line"><span class="comment">1243	1</span></span><br><span class="line"><span class="comment">243		3</span></span><br><span class="line"><span class="comment">243		6</span></span><br><span class="line"><span class="comment">243		10</span></span><br><span class="line"><span class="comment">2	跳出，执行	printf(&quot;sum = %d\n&quot;,sum);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;		<span class="comment">//执行了5次</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>;sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;		<span class="comment">//由上程序可知，执行了1000次，</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>;sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">56</span>;i &lt; <span class="number">149</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;		<span class="comment">//由上程序可知，执行了93次，</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>;sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>for和if的嵌套使用</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2022年6月10日21:09:24</span></span><br><span class="line"><span class="comment">	求1-10中能被3整除的数之和 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum = sum + i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>,sum);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	printf(&quot;sum = %d\n&quot;,sum);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果为： </span></span><br><span class="line"><span class="comment">	sum = 0</span></span><br><span class="line"><span class="comment">	sum = 0</span></span><br><span class="line"><span class="comment">	sum = 3</span></span><br><span class="line"><span class="comment">	sum = 3</span></span><br><span class="line"><span class="comment">	sum = 3</span></span><br><span class="line"><span class="comment">	sum = 9</span></span><br><span class="line"><span class="comment">	sum = 9</span></span><br><span class="line"><span class="comment">	sum = 9</span></span><br><span class="line"><span class="comment">	sum = 18</span></span><br><span class="line"><span class="comment">	sum = 18</span></span><br><span class="line"><span class="comment">i=	1	2	3	4	5	6	7	8	9	10</span></span><br><span class="line"><span class="comment">sum=0	0	3	3	3	9	9	9	18	18</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></div></figure>

<p>多个for循环的嵌套使用</p>
<p>1、</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>) <span class="comment">//1 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>) <span class="comment">//2 </span></span><br><span class="line">		A; <span class="comment">//3 </span></span><br><span class="line">		B; <span class="comment">//4 </span></span><br><span class="line">整体是两个语句 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> 是一个语句</span><br><span class="line">			 <span class="number">4</span>是一个语句</span><br></pre></td></tr></table></div></figure>

<p>2、</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="number">1</span> ; <span class="number">2</span>; <span class="number">3</span>) </span><br><span class="line">	<span class="keyword">for</span> (<span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A: </span><br><span class="line">		B; </span><br><span class="line">    &#125;</span><br><span class="line">整体是一个语句</span><br></pre></td></tr></table></div></figure>

<p>3、</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="number">7</span> ; <span class="number">8</span>; <span class="number">9</span>) </span><br><span class="line">	<span class="keyword">for</span> (<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		A: </span><br><span class="line">		B; </span><br><span class="line">		<span class="keyword">for</span> (<span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>) </span><br><span class="line">			C; </span><br><span class="line">	&#125;</span><br><span class="line">整体是一语句</span><br></pre></td></tr></table></div></figure>

<ol start="3">
<li><p>范围问题</p>
</li>
<li><p>举例:</p>
</li>
</ol>
<p>1 + 2 + 3 +.. ..+ 100 </p>
<p>1 + 1&#x2F;2 + 1&#x2F;3 +. … + 1&#x2F;100 </p>
<p>【本程序对初学者而言很重要，具体细节可参见我录制的相关视频】</p>

        <h5 id="注意："   >
          <a href="#注意：" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5>
      <ol>
<li>for循环中的变量‘i’不能定义为浮点型（float），因为浮点型是非准确存储大一点点或小一点点存储的。如 i &lt;&#x3D;100 有可能最后加到100时比100大一点点而不能参加循环。</li>
<li>for的多重循环，循环次数较少的放在外面；循环次数较多的放在里面。用来减少CPU跨切循环层的次数。</li>
<li>for循环的语法定义 ++i和 i++的结果是一样的 .但是i++由于是在使用当前值之后再+1，所以需要一个临时的变量来转存i。而++i则是在直接+1，省去了对内存的操作的环节，相对而言能够提高性能。</li>
</ol>

        <h4 id="while"   >
          <a href="#while" class="heading-link"><i class="fas fa-link"></i></a><a href="#while" class="headerlink" title="while"></a>while</h4>
      <ol>
<li>执行顺序</li>
</ol>
<p>格式:</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">	语句;</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li><p>与 for 的相互比较<br>for和while可以相互转换</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>)</span><br><span class="line">	A;</span><br><span class="line">	</span><br><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">	A;</span><br><span class="line">	<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


</li>
<li><p>举例<br>从键盘输入一个数字，如何该数字是回文数，则返回yes，否则返回no，<br>回文数：正着写反着写都一样。例如12321   212</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;<span class="comment">//存放待判断的数字</span></span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入待判断的值：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">	</span><br><span class="line">	m = val;</span><br><span class="line">	<span class="keyword">while</span>(m)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum*<span class="number">10</span> + m%<span class="number">10</span>;</span><br><span class="line">		m /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(sum == val)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//菲波拉契序列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> f1,f2,f3;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入您需要求的序列: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	f1 = <span class="number">1</span>;</span><br><span class="line">	f2 = <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">		f3 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">		f3 = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">3</span>;i &lt;= n;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			f3 = f2 + f1;</span><br><span class="line">			f1 = f2;</span><br><span class="line">			f2 = f3;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f3);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


<p><img src="C:\Users\张智超\Desktop\线性代数\image-20220628112113860.png" alt="image-20220628112113860"></p>
</li>
<li><p>什么时候使用while，什么时候用for<br>没法说，用多了自然就知道了</p>
</li>
</ol>

        <h4 id="do…while"   >
          <a href="#do…while" class="heading-link"><i class="fas fa-link"></i></a><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h4>
      <p>​	格式</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">.......</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式)</span><br><span class="line">    <span class="comment">//先执行一次才去判断条件</span></span><br></pre></td></tr></table></div></figure>

<p>do….while.并不等价于for，当然也不等价于while</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> a,b,c;</span><br><span class="line">	<span class="type">double</span> x1,x2;</span><br><span class="line">	<span class="type">double</span> delta;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入a的值：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入b的值：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入c的值：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;c);</span><br><span class="line"></span><br><span class="line">		delta = b*b - <span class="number">4</span>*a*c;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(delta &gt; <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			x1 = (-b + <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span>*a);</span><br><span class="line">			x2 = (-b - <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span>*a);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;此方程有两个不同的解，x1 = %f,x2 = %f\n&quot;</span>,x1,x2);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(delta == <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			x1 = x2 = (-b) / (<span class="number">2</span>*a);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;有唯一解，x1 = x2 = %lf\n&quot;</span>, x1);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;无实数解！\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;继续计算请输入Y，或输入任意字符退出&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);  <span class="comment">//%c前面必须得加一个空格 原因略</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(ch == <span class="string">&#x27;y&#x27;</span> || ch == <span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="break和continue"   >
          <a href="#break和continue" class="heading-link"><i class="fas fa-link"></i></a><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h4>
      
        <h5 id="break"   >
          <a href="#break" class="heading-link"><i class="fas fa-link"></i></a><a href="#break" class="headerlink" title="break"></a>break</h5>
      <ol>
<li><p>用于循环是用来终止循环</p>
</li>
<li><p>用于swtich是用来终止Switch</p>
</li>
<li><p>不能直接用于if，除非if属于循环内部的一个字句</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">3</span>;i &lt;= <span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span>&gt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//break虽然是if内部的语句，但是break终止的是外部的for循环</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;嘿嘿！\n&quot;</span>);<span class="comment">//永远不会输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>在多层循环中，break只能终止最里面包裹它的那个循环</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j&lt;<span class="number">5</span>;++j)</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//break只能终止距离它最近的循环</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;同志们好\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"><span class="comment">同志们好</span></span><br><span class="line"><span class="comment">同志们好</span></span><br><span class="line"><span class="comment">同志们好</span></span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>在多层switch中，break也只能终止距离它最近的switch</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">0</span>, a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span>(x) <span class="comment">// 第一个switch </span></span><br><span class="line">	&#123;  </span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">		<span class="keyword">switch</span>(y)  <span class="comment">// 第二个switch </span></span><br><span class="line">		&#123;  </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">			a++; </span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//终止的是第二个switch  </span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">			b++; </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		b = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">break</span>;   <span class="comment">//终止的是第一个switch</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">		a++;    </span><br><span class="line">		b++;</span><br><span class="line">		<span class="keyword">break</span>;  </span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,b); <span class="comment">//26行</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：<span class="number">1</span> <span class="number">100</span></span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h5 id="continue"   >
          <a href="#continue" class="heading-link"><i class="fas fa-link"></i></a><a href="#continue" class="headerlink" title="continue"></a>continue</h5>
      <p>用于跳过本次循环余下的语句，转去判断是否需要执行下次循环</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ( (ch=getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="数组"   >
          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h2>
      <p>为什么需要数组</p>
<p>为了解决大量同类型数据的存储和使用问题</p>
<p>为了模拟现实世界</p>

        <h3 id="数组的分类"   >
          <a href="#数组的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h3>
      
        <h4 id="一维数组"   >
          <a href="#一维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4>
      
        <h5 id="怎样定义一维数组"   >
          <a href="#怎样定义一维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎样定义一维数组" class="headerlink" title="怎样定义一维数组"></a>怎样定义一维数组</h5>
      <p>为n个变量连续分配存储空间</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">31</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[i]);<span class="comment">//注意！输出的是看逗号后面写什么，前面的只是控制输出格式的符号，因为要输出的是变量的地址，所以要加上取地址符 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"><span class="comment">000000000062FE00</span></span><br><span class="line"><span class="comment">000000000062FE04</span></span><br><span class="line"><span class="comment">000000000062FE08</span></span><br><span class="line"><span class="comment">000000000062FE0C</span></span><br><span class="line"><span class="comment">000000000062FE10</span></span><br><span class="line"><span class="comment">----------------- </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></div></figure>

<p>所有的变量数据类型必须相同</p>
<p>所有变量所占的字节大小必须相等</p>
<p>​		例子：			</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> a[<span class="number">5</span>]</span><br><span class="line"> 	一维数组名不代表数组中所有的元素</span><br><span class="line"> 	一维数组名代表数组第一个元素的地址</span><br><span class="line">当我们定义一个数组a 时，编译器根据指定的元素个数和元素的类型分配确定大小（元素类型大小*元素个数）的一块内存，并把这块内存的名字命名为a。名字a 一旦与这块内存匹配就不能被改变。a[<span class="number">0</span>] a[<span class="number">1</span>]等为a 的元素，但并非元素的名字。数组的每一个元素都是没有名字的。</span><br></pre></td></tr></table></div></figure>


        <h5 id="有关一维数组的操作"   >
          <a href="#有关一维数组的操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#有关一维数组的操作" class="headerlink" title="有关一维数组的操作"></a>有关一维数组的操作</h5>
      
        <h6 id="初始化"   >
          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">完全初始化</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	</span><br><span class="line">不完全初始化，未被初始化的元素自动为零</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	</span><br><span class="line">不初始化，所有元素都是垃圾值</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]</span><br><span class="line">	</span><br><span class="line">清零</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></div></figure>

<p><strong>错误写法：</strong></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line">	a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; ; / /错误</span><br><span class="line">只有在定义数组的同时才可以整体赋值，</span><br><span class="line">其他情况下整体赋值都是错误的</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; ; </span><br><span class="line">	a[<span class="number">5</span>] = <span class="number">100</span> ; <span class="comment">//error 困为没有a[5]这个元素，最大只有a[4]</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; ; </span><br><span class="line">	<span class="type">int</span> b[<span class="number">5</span>] ; </span><br><span class="line">如果要把a中的值全部复制给b数组</span><br><span class="line">错误的写法</span><br><span class="line">	b = a;/ / error </span><br><span class="line">正确的</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; <span class="number">5</span> ; ++i) </span><br><span class="line">	b [i] = a [i];</span><br></pre></td></tr></table></div></figure>


        <h6 id="赋值"   >
          <a href="#赋值" class="heading-link"><i class="fas fa-link"></i></a><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h6>
      
        <h6 id="排序"   >
          <a href="#排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序" class="headerlink" title="排序"></a>排序</h6>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="type">int</span> date[<span class="number">10</span>] = &#123;<span class="number">45</span>,<span class="number">89</span>,<span class="number">1</span>,<span class="number">464</span>,<span class="number">41</span>,<span class="number">41</span>,<span class="number">2120</span>,<span class="number">14552</span>,<span class="number">78</span>,<span class="number">62</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span><span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">10</span>-i<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(date[j] &lt; date[j+<span class="number">1</span>])	<span class="comment">//降序 </span></span><br><span class="line">			&#123;</span><br><span class="line">				temp = date[j+<span class="number">1</span>];</span><br><span class="line">				date[j+<span class="number">1</span>] = date[j];</span><br><span class="line">				date[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;经过排序后的数组元素为：%d\n&quot;</span>,date[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, t;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>-i; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>])  <span class="comment">// &gt;表示升序 &lt;表示降序</span></span><br><span class="line">			&#123;</span><br><span class="line">				t = a[j];</span><br><span class="line">				a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>] = t; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-8</span>, <span class="number">11</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	sort(a, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="求最大-x2F-小值"   >
          <a href="#求最大-x2F-小值" class="heading-link"><i class="fas fa-link"></i></a><a href="#求最大-x2F-小值" class="headerlink" title="求最大&#x2F;小值"></a>求最大&#x2F;小值</h6>
      
        <h6 id="倒置"   >
          <a href="#倒置" class="heading-link"><i class="fas fa-link"></i></a><a href="#倒置" class="headerlink" title="倒置"></a>倒置</h6>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">7</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		t = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = t;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//设置i和j的规则，避免程序死循环</span></span><br><span class="line">		i++;</span><br><span class="line">		j--; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>,i,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="查找"   >
          <a href="#查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#查找" class="headerlink" title="查找"></a>查找</h6>
      
        <h6 id="插入"   >
          <a href="#插入" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入" class="headerlink" title="插入"></a>插入</h6>
      
        <h6 id="删除"   >
          <a href="#删除" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除" class="headerlink" title="删除"></a>删除</h6>
      
        <h4 id="二维数组"   >
          <a href="#二维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4>
      <p>格式</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4];</span><br></pre></td></tr></table></div></figure>

<p>定义</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4];</span><br><span class="line">总共是12个元素，可以当做3行四列看待，这12个元素的名字依次是</span><br><span class="line">a [0][0] a[0][1] a[0][2] a[0][3]</span><br><span class="line">a [1][0] a[1][1] a[1][2] a[1][3] </span><br><span class="line">a [2][0] a[2][1] a[2][2] a[2][3] </span><br><span class="line">a[i][j] 表示第i+1行第j+1列的元素</span><br><span class="line">int a[m][n];该二维数组右下角位置的元素只能是a[m-1][n-1]</span><br></pre></td></tr></table></div></figure>

<p>初始化</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;</span><br><span class="line">int a[3][4] = &#123;</span><br><span class="line">		&#123;1, 2, 3, 4&#125;</span><br><span class="line">		&#123;5, 6, 7, 8&#125;</span><br><span class="line">		&#123;9,10,11,12&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>操作</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">输出二维数组内容：</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">		&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">		&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组内容</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 二维数组3行4列输出 </span></span><br><span class="line"><span class="comment">int a[3][4] = &#123; &#123;1, 2, 3, 4&#125;, </span></span><br><span class="line"><span class="comment">&#123;1, 2, 3, 4&#125;, </span></span><br><span class="line"><span class="comment">&#123;1, 2, 3, 4&#125;&#125;; </span></span><br><span class="line"><span class="comment">int i, j; </span></span><br><span class="line"><span class="comment"> for(i=0; i&lt;3; i++) </span></span><br><span class="line"><span class="comment"> &#123; </span></span><br><span class="line"><span class="comment">for(j=0; j&lt;4; j++) </span></span><br><span class="line"><span class="comment">&#123; </span></span><br><span class="line"><span class="comment">printf(&quot;a[%d][%d] = %d  &quot;, i, j, a[i][j]);//每四个一行 </span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">printf(&quot;\n&quot;);//换行 </span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>对二维数组排序</p>
<p>求每一行的最大值</p>
<p>判断矩阵是否对称</p>
<p>矩阵的相乘</p>

        <h4 id="多维数组"   >
          <a href="#多维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4>
      <p>是否存在多维数组？</p>
<p>​		不存在</p>
<p>​		因为内存是线性一维的</p>
<p>​		n维数组可以当做每个元素是n-1 维数组的一维数组</p>
<p>​			比如:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4]; </span><br></pre></td></tr></table></div></figure>

<p>​				该数组是含有3个元素的一维数组</p>
<p>​				只不过每个元素都可以再分成4个小元素</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a [3][4][5]; </span><br></pre></td></tr></table></div></figure>

<p>​			该数组是含有3个元素的一维数组</p>
<p>​			只不过每个元素都是4行5列的二维数组</p>

        <h2 id="函数【第二个重点】"   >
          <a href="#函数【第二个重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数【第二个重点】" class="headerlink" title="函数【第二个重点】"></a>函数【第二个重点】</h2>
      <p>为什么需要函数</p>
<ol>
<li>避免了重复性操作</li>
<li>有利于程序的模块化</li>
</ol>
<p>什么叫函数</p>
<p>​	逻辑上：能够完成特定功能的独立的代码块</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//max是函数的名字，i和j是形式参数，简称形参，void表示函数没有返回值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &gt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a,b,c,d,e,f;</span><br><span class="line">	a = <span class="number">1</span>,b = <span class="number">2</span>,c = <span class="number">3</span>,d = <span class="number">9</span>, e = <span class="number">-5</span>;f = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	max(a,b);</span><br><span class="line">	max(c,d);</span><br><span class="line">	max(e,f);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​	物理上：</p>
<p>​			能够接受数据【当然也可以不接受数据】</p>
<p>​			能够对接受的数据进行处理</p>
<p>​			能够将数据处理的结果返回【当然也可以不返回任何值】</p>
<p>​	总结：函数是个工具，它是为了解决大量类似问题而设计的</p>
<p>​				函数也可以当做一个黑匣子</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//括号中的void表示该函数不能接受数据  int表示函数返回值是int类型的数据</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">79</span>;<span class="comment">//向主调函数返回10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">//8行  函数名前面的void表示该函数没有返回值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	return 10; //error 与8行行首的void相矛盾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">50</span>;</span><br><span class="line">	</span><br><span class="line">	i = f();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//	j = g(); //error 因为g函数没有返回值</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="如何定义一个函数"   >
          <a href="#如何定义一个函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何定义一个函数" class="headerlink" title="如何定义一个函数"></a>如何定义一个函数</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数的返回值类型 函数的名字（函数的形参列表）</span><br><span class="line">&#123;</span><br><span class="line">	函数的执行体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li><p>函数定义的本质是：详细描述函数之所以能实现某个特定功能的具体实现方式</p>
</li>
<li><p>return表达式：return用来结束整个函数。无论出现多少个return，执行第一个return后整个函数就结束了，不会再执行其他的return，即也不会再执行其他的语句了。<br>    1&gt; 终止被调函数，向主调函数返回表达式的值<br>    2&gt; 如果表达式为空，则只终止函数，不向主调函数返回任何值<br>    3&gt;<strong> break是用来终止循环和switch的，return使用来终止函数的</strong></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//return 只用来终止函数，不向主调函数返回任何值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;<span class="comment">//第一：终止函数，第二：向主调函数返回10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


</li>
<li><p>函数返回值的类型也称为函数的类型，因为如果 函数名前的返回值类型 和 函数执行体中的 return 表达式; 中表达式类型不同的话，则最终函数返回值的类型 以函数名前的返回值类型为准。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10.5</span>;<span class="comment">//因为函数的返回值类型是int</span></span><br><span class="line">    			<span class="comment">//所以最终f返回的是10，不是10.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在c语言中，凡不加返回值类型限定的函数，就会被编译器作为 返回整形值 处理。但许多程序员却误以为其为void类型。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">add ( <span class="type">int</span> a, <span class="type">int</span> b ) </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="built_in">printf</span> ( <span class="string">&quot;2 + 3 = %d&quot;</span>, add ( <span class="number">2</span>, <span class="number">3</span>) ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行的结果为输出： </span></span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"><span class="comment">2 + 3 = 5 </span></span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">add(<span class="type">float</span> x,<span class="type">float</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a,b;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入两浮点数a，b的值：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;两数之和为%f\n&quot;</span>,add(a,b));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行的结果为输出： </span></span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"><span class="comment">两数之和为0.000000</span></span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">这说明不加返回值说明的函数的确为<span class="type">int</span>函数</span><br></pre></td></tr></table></div></figure></li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> i = <span class="number">99.9</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, i);</span><br><span class="line">	</span><br><span class="line">	i = f(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="函数的分类"   >
          <a href="#函数的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h3>
      <p>有参函数 和 无参函数</p>
<p>有返回值函数 和 无返回值函数</p>
<p>值传递函数 和 地址传递函数</p>
<p>普通函数 和 主函数（main函数）</p>

        <h4 id="重点"   >
          <a href="#重点" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点" class="headerlink" title="重点"></a>重点</h4>
      <p>一个程序必须有且只能有一个主函数</p>
<p>主函数可以调用普通函数 普通函数不能调用主函数</p>
<p>普通函数可以相互调用</p>
<p>主函数是程序的入口，也是程序的出口</p>

        <h4 id="注意的问题"   >
          <a href="#注意的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h4>
      <p>函数调用和函数定义的顺序</p>
<p>​		如果函数调用卸载了函数定义的前面，则必须加函数前置声明</p>
<p>函数前置声明：</p>
<ol>
<li>告诉编译器即将出现的若干个字母代表的是一个函数</li>
<li>告诉编译器即将出现的若干个字母所代表的函数的形参和返回值的具体情况</li>
<li>函数声明是一个语句，末尾必须加分号</li>
<li>对库函数的声明是通过#include&lt;库函数所在的文件的名字.h&gt;来实现的</li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//函数声明， 分号不能丢掉</span></span><br><span class="line"><span class="comment">//无函数声明时，主程序里遇到f();不会认为它是函数</span></span><br><span class="line"><span class="comment">//并且，函数声明必须与函数的返回值类型和形参列表相同，否则无法找到函数，程序将报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	f();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果自定义函数放到main函数后，需要在主函数前加上本函数的函数声明</span></span><br><span class="line"><span class="comment">//否则当主函数调用自定义函数时，将会找不到函数体，因为程序是自下而上依次运行的</span></span><br><span class="line"><span class="comment">//而main函数做为程序的入口先执行 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;测试函数声明\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">//函数声明， 分号不能丢掉</span></span><br><span class="line"><span class="comment">//程序找不到 void f(int) 函数，函数声明不许与自定义函数一致 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	f();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;哈哈!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此程序是错误的 </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void f(void);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	f();<span class="comment">//因为f函数放到了g函数之后，程序无法找到f函数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ll\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	g();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>形参和实参</p>
<p>​		个数相同		位置一一对应		数据类型必须相互兼容</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数的形参和实参定义的变量名可以相同。因为在一个函数内部定义的变量只能在本函数中使用，实参的值传递给形参而不是变量名。本函数结束后函数内部定义的变量将被释放。</span><br><span class="line">形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元，因此，形参只在本函数内部有效。</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	f(<span class="number">9.9</span>, <span class="number">6.6</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">程序运行结果为</span></span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">------------------------------- </span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></div></figure>

<p>如何在软件开发中合理的设计函数来解决问题</p>
<p>​		一个函数的功能尽量独立，单一</p>
<p>​		多学习，多模仿牛人的代码</p>
<p>函数是c语言的基本单位，类是Java，c#，c++的基本单位</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序1，判断素数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2022年7月8日17:21:57</span></span><br><span class="line"><span class="comment">	判断一个数字是否是素数</span></span><br><span class="line"><span class="comment">	只用一个函数实现,不好，代码的利用率不高	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; val;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(val % i == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == val)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Yes!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No!&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2022年7月8日17:27:52 </span></span><br><span class="line"><span class="comment">	用自定义函数实现判断一个数字是否是素数</span></span><br><span class="line"><span class="comment">	用单独的函数来实现, 代码的可重用性提高	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsPrime</span><span class="params">(<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m % i == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(IsPrime(val))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Yes!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2009年11月4日11:18:51</span></span><br><span class="line"><span class="comment">	求1到某个数字之间(包括该数字)所有的素数，并将其输出</span></span><br><span class="line"><span class="comment">	只用main函数实现，有局限性：</span></span><br><span class="line"><span class="comment">		1. 代码的重用性不高</span></span><br><span class="line"><span class="comment">		2. 代码不容易理解		</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;=val; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断i是否是素数，是输出，不是不输出</span></span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> == i%j)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == i)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2009年11月4日11:18:51</span></span><br><span class="line"><span class="comment">	求1到某个数字之间(包括该数字)所有的素数，并将其输出</span></span><br><span class="line"><span class="comment">	用1个函数来判断一个数字是否是素数</span></span><br><span class="line"><span class="comment">		优点:</span></span><br><span class="line"><span class="comment">			代码比  如何设计函数_3.cpp  更容易理解</span></span><br><span class="line"><span class="comment">			代码的可重用性比  如何设计函数_3.cpp 高</span></span><br><span class="line"><span class="comment">		缺点：</span></span><br><span class="line"><span class="comment">			可重用性仍然不是非常高，</span></span><br><span class="line"><span class="comment">			比如有1000个数字，求它们每个数字从1到它本身的素数</span></span><br><span class="line"><span class="comment">			则</span></span><br><span class="line"><span class="comment">					for (i=2; i&lt;=val; ++i)</span></span><br><span class="line"><span class="comment">					&#123;</span></span><br><span class="line"><span class="comment">						if ( IsPrime(i) )</span></span><br><span class="line"><span class="comment">							printf(&quot;%d\n&quot;, i);</span></span><br><span class="line"><span class="comment">					&#125;</span></span><br><span class="line"><span class="comment">			要写1000次</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsPrime</span><span class="params">(<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == m%i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=val; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( IsPrime(i) )</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2009年11月4日11:56:29</span></span><br><span class="line"><span class="comment">	用两个函数来实现求1到某个数字之间所有的素数，并将其输出</span></span><br><span class="line"><span class="comment">	本程序 和 如何合理设计函数_4.cpp 相比较</span></span><br><span class="line"><span class="comment">	代码量更少，可重用性更高</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//本函数的功能是: 判断m是否是素数，是返回true，不是返回false</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsPrime</span><span class="params">(<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == m%i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本函数的功能是把1到n之间所有的素数在显示器上输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TraverseVal</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( IsPrime(i) )</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">	TraverseVal(val);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>常用的系统函数</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double sqrt(double x); </span><br><span class="line">求x的平方根</span><br><span class="line"></span><br><span class="line">int abs (int x) </span><br><span class="line">求x的绝对值</span><br><span class="line"></span><br><span class="line">double fabs(double x) </span><br><span class="line">求x的绝对值</span><br></pre></td></tr></table></div></figure>

<p>专题</p>
<p>​		递归</p>
<p>​				可以参见数据结构视频</p>

        <h3 id="变量的作用于和存储方式"   >
          <a href="#变量的作用于和存储方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量的作用于和存储方式" class="headerlink" title="变量的作用于和存储方式"></a>变量的作用于和存储方式</h3>
      
        <h4 id="按作用域分："   >
          <a href="#按作用域分：" class="heading-link"><i class="fas fa-link"></i></a><a href="#按作用域分：" class="headerlink" title="按作用域分："></a>按作用域分：</h4>
      
        <h5 id="全局变量（又称“外部变量”）："   >
          <a href="#全局变量（又称“外部变量”）：" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局变量（又称“外部变量”）：" class="headerlink" title="全局变量（又称“外部变量”）："></a>全局变量（又称“外部变量”）：</h5>
      <p>在所有函数外部定义的变量叫全局变量</p>
<p>全局变量使用范围：从定义位置开始到整个函数结束</p>

        <h5 id="局部变量"   >
          <a href="#局部变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5>
      <p>在一个函数内部定义的变量  或者  函数的形参  都统称为局部变量 	</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i和j都属于局部变量</span></span><br></pre></td></tr></table></div></figure>

<p>局部变量使用范围：只能在本函数内部使用</p>

        <h5 id="注意的问题："   >
          <a href="#注意的问题：" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意的问题：" class="headerlink" title="注意的问题："></a>注意的问题：</h5>
      
        <h6 id="全局变量和局部变量命名冲突的问题"   >
          <a href="#全局变量和局部变量命名冲突的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#全局变量和局部变量命名冲突的问题" class="headerlink" title="全局变量和局部变量命名冲突的问题"></a>全局变量和局部变量命名冲突的问题</h6>
      <p>在一个函数内部如果定义的局部变量的名字和全局变量名一样时，局部变量会屏蔽掉全局变量。</p>
<p>就近原则，这点与java中类似</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	f();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="按变量的存储方式"   >
          <a href="#按变量的存储方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#按变量的存储方式" class="headerlink" title="按变量的存储方式"></a>按变量的存储方式</h4>
      <p>静态变量</p>
<p>自动变量</p>
<p>寄存器变量</p>

        <h2 id="指针【第三个重点】"   >
          <a href="#指针【第三个重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针【第三个重点】" class="headerlink" title="指针【第三个重点】"></a>指针【第三个重点】</h2>
      <p>一个字节为8位。数据存储是以“字节（Byte）”为单位，数据传输是以大多是以“位”（bit又名比特）为单位，一个位就代表一个0或1（即二进制），每8位组成一个字节，是最小一级的信息单位。</p>
<p>学习指针主要是为了学习动态内存分配和跨函数使用内存</p>

        <h3 id="指针热身"   >
          <a href="#指针热身" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针热身" class="headerlink" title="指针热身"></a>指针热身</h3>
      
        <h4 id="指针的重要性"   >
          <a href="#指针的重要性" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针的重要性" class="headerlink" title="指针的重要性"></a>指针的重要性</h4>
      <p>表示一些复杂的数据结构</p>
<p>快速的纯涤数据，减少了内存的好用【重点】</p>
<p>使函数返回一个以上的值【重点】</p>
<p>直接访问硬件</p>
<p>能够方便的处理字符串</p>
<p>是理解面向对象语言中引用的基础</p>
<p>总结：指针是c语言的灵魂</p>

        <h4 id="指针热身-1"   >
          <a href="#指针热身-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针热身-1" class="headerlink" title="指针热身"></a>指针热身</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">	p = &amp;i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,i);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		0000000000000003</span></span><br><span class="line"><span class="comment">		0000000000000003</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//p = i; //error，因为类型不一致，p只能存放int类型变量的地址，不能存放int类型变量的值</span></span><br><span class="line">	<span class="comment">//p = 55; //error 原因同上</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>*的意思是读一个地址指向的内容,即读取该指针变量 p 中存放的地址所对应的内容 </p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p;<span class="comment">//p是变量的名字，int * 表示 p 变量存放的是int类型变量的地址</span></span><br><span class="line">			<span class="comment">//int * p;表示的不是定义了一个名字叫做*p的整形变量</span></span><br><span class="line">			<span class="comment">//int * p;应该这样理解：p是变量名，int * 是 p 变量的数据类型</span></span><br><span class="line">			<span class="comment">//所谓 int * 类型 实际上就是存放 int 变量地址的类型 </span></span><br><span class="line">			<span class="comment">//p就是指针变量，也可以叫地址变量 </span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	</span><br><span class="line">	p = &amp;i;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1.p保存了i的地址，因此p指向了i</span></span><br><span class="line"><span class="comment">		2.p不是i，i也不是p，更准确的说：修改i的值，并不会影响p的值，同理，修改p的值也并不会影响i</span></span><br><span class="line"><span class="comment">		3.在声明int * p 中 * 表示这个变量是int类型的指针(地址),</span></span><br><span class="line"><span class="comment">		  在声明之外*可以理解成一个运算符  * 和 &amp; 是一对逆运算 </span></span><br><span class="line"><span class="comment">		  &amp; 的意思是读一个变量的地址,比如你声明了int a；&amp;a是a的地址可能是xx1001之类的</span></span><br><span class="line"><span class="comment">		  * 的意思是读一个地址指向的内容,即读取该指针变量中存放的地址的内容 </span></span><br><span class="line"><span class="comment">		4.如果一个指针变量指向了一个普通变量，则 *指针变量 就完全等同于 这个普通变量 </span></span><br><span class="line"><span class="comment">		  例子：</span></span><br><span class="line"><span class="comment">		  		如果 p 是个指针变量，并且 p 存放了普通变量 i 的地址</span></span><br><span class="line"><span class="comment">				则 p 指向了普通变量 i</span></span><br><span class="line"><span class="comment">				*p 就完全等同于i</span></span><br><span class="line"><span class="comment">				或者说：在所有出现*p的地方都可以替换成i</span></span><br><span class="line"><span class="comment">						在所有出现i的地方都可以替换成*p</span></span><br><span class="line"><span class="comment">						</span></span><br><span class="line"><span class="comment">				*p 就是以指针变量 p 存放的地址所对应的内容为地址的变量</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	j = *p; <span class="comment">//等价于 j = i;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d, j = %d\n&quot;</span>, i, j); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053867.png" alt="image-20220709105031600"></p>
<p>自己对指针的理解</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	</span><br><span class="line">	p = &amp;i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);<span class="comment">//6487572</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;i);<span class="comment">//6487572</span></span><br><span class="line">	<span class="comment">//说明p中存储的是i的地址</span></span><br><span class="line">	</span><br><span class="line">	p =  &amp;j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;i);<span class="comment">//6487572</span></span><br><span class="line">	<span class="comment">//改变p的值，并不影响i</span></span><br><span class="line">	</span><br><span class="line">	i = <span class="number">5</span>;</span><br><span class="line">	p = &amp;i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);<span class="comment">//6487572 </span></span><br><span class="line">	<span class="comment">//改变i的值并不影响p，因为p里面存放的是i的地址</span></span><br><span class="line">	</span><br><span class="line">	*p = i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);<span class="comment">//5 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="指针和指针变量"   >
          <a href="#指针和指针变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和指针变量" class="headerlink" title="指针和指针变量"></a>指针和指针变量</h4>
      <p>指针就是地址，地址就是指针</p>
<p>地址就是内存单元的编号</p>
<p>指针变量是存放地址（指针）的变量</p>
<p>指针和指针变量是两个不同的概念</p>
<p>但是要注意：通常我们叙述时会把指针变量简称为指针</p>

        <h3 id="指针的定义"   >
          <a href="#指针的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3>
      
        <h4 id="地址"   >
          <a href="#地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#地址" class="headerlink" title="地址"></a>地址</h4>
      <p>内存单元的编号</p>
<p>从零开始的非负整数</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053868.png" alt="image-20220710093119665"></p>
<p>控制线：控制的是数据传输的方向</p>
<p>数据线：用来进行数据传输</p>
<p>地址线：用来确定是对哪部分内存单元来进行控制</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053869.png" alt="image-20220710092838874"></p>
<p>范围：4G【0–4G-1】</p>

        <h4 id="指针"   >
          <a href="#指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针" class="headerlink" title="指针"></a>指针</h4>
      <p>指针就是地址，地址就是指针</p>
<p>指针变量就是存放内存单元的编号的变量，或者说指针变量就是存放地址的变量</p>
<p>指针和指针变量是两个不同的概念</p>
<p>但是要注意：通常我们叙述时会把指针变量简称为指针，实际他们是不同的</p>
<p>指针的本质就是一个操作受限的非负整数</p>

        <h3 id="指针的分类"   >
          <a href="#指针的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针的分类" class="headerlink" title="指针的分类"></a>指针的分类</h3>
      
        <h4 id="基本类型指针【重点】"   >
          <a href="#基本类型指针【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本类型指针【重点】" class="headerlink" title="基本类型指针【重点】"></a>基本类型指针【重点】</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	</span><br><span class="line">	p = &amp;i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);<span class="comment">//6487572</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;i);<span class="comment">//6487572</span></span><br><span class="line">	<span class="comment">//说明p中存储的是i的地址</span></span><br><span class="line">	</span><br><span class="line">	p =  &amp;j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;i);<span class="comment">//6487572</span></span><br><span class="line">	<span class="comment">//改变p的值，并不影响i</span></span><br><span class="line">	</span><br><span class="line">	i = <span class="number">5</span>;</span><br><span class="line">	p = &amp;i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p);<span class="comment">//6487572 </span></span><br><span class="line">	<span class="comment">//改变i的值并不影响p，因为p里面存放的是i的地址</span></span><br><span class="line">	</span><br><span class="line">	*p = i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);<span class="comment">//5 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>常见错误</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">*p 以p的内容为地址的变量</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	<span class="type">int</span> * q;</span><br><span class="line">	</span><br><span class="line">	p = &amp;i;</span><br><span class="line"><span class="comment">//	*q = p;//error,从“int *”到“int”的无效转换</span></span><br><span class="line"><span class="comment">//	*q = *p;//error</span></span><br><span class="line">	p = q;<span class="comment">//error q是垃圾值，q赋给p，p也变成了垃圾值 </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		q的空间是属于本程序的，所以本程序可以读写q的内容，</span></span><br><span class="line"><span class="comment">		但如果q内部是垃圾值，则本程序将不能读写*q的内容</span></span><br><span class="line"><span class="comment">		因为此时*q所代表的内存单元的权限并没有分配给本程序</span></span><br><span class="line"><span class="comment">		所以本程序运行到14行时就会立即出错 </span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="互换两数"   >
          <a href="#互换两数" class="heading-link"><i class="fas fa-link"></i></a><a href="#互换两数" class="headerlink" title="互换两数"></a>互换两数</h5>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053870.png" alt="image-20220710111652453"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">huhuan_1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">huhuan_2</span><span class="params">(<span class="type">int</span> * p,<span class="type">int</span> * q)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">huhuan_3</span><span class="params">(<span class="type">int</span> * p,<span class="type">int</span> * q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	</span><br><span class="line">	t = *q;</span><br><span class="line">	*q = *p;</span><br><span class="line">	*p = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line">	huhuan_3(&amp;a,&amp;b);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	huhuan_2(&amp;a,&amp;b);</span></span><br><span class="line"><span class="comment">//	huhuan_1(a,b);</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>,a,b);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">huhuan_2</span><span class="params">(<span class="type">int</span> * p,<span class="type">int</span> * q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * t;</span><br><span class="line">	t = q;</span><br><span class="line">	q = p;</span><br><span class="line">	p = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">huhuan_1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">下为huhuan_2的图示</span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053871.png" alt="image-20220710105048764"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">huhuan_3</span><span class="params">(<span class="type">int</span> * p,<span class="type">int</span> * q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	</span><br><span class="line">	t = *q;</span><br><span class="line">	*q = *p;</span><br><span class="line">	*p = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line">	huhuan_3(&amp;a,&amp;b);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>,a,b);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053872.png"></p>

        <h5 id="的含义"   >
          <a href="#的含义" class="heading-link"><i class="fas fa-link"></i></a><a href="#的含义" class="headerlink" title="*的含义"></a>*的含义</h5>
      <ol>
<li><p>乘法</p>
</li>
<li><p>定义指针变量</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p;</span><br><span class="line"><span class="comment">//定义了一个名字叫p的变量， int *表示p只能存放int变量的地址</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>指针运算符<br>该运算符放在已经定义好的指针变量的前面<br>如果p是一个定义好的指针变量<br>则 *p表示以p的内容为地址的变量</p>
</li>
</ol>

        <h5 id="如何通过被调函数修改主调函数普通变量的值"   >
          <a href="#如何通过被调函数修改主调函数普通变量的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何通过被调函数修改主调函数普通变量的值" class="headerlink" title="如何通过被调函数修改主调函数普通变量的值"></a>如何通过被调函数修改主调函数普通变量的值</h5>
      <ol>
<li>实参必须为该普通变量的地址</li>
<li>形参必须为指针变量</li>
<li>在被调函数中通过<br>   *形参名 &#x3D; 。。。<br>的形式就可以修改主调函数相关变量的值</li>
</ol>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.实参必须为该普通变量的地址（实参的‘ 地址 ’传递给形参，若为int *ｐ和a[5]即指针和数组,则直接在实参内写上数组名（首地址）和指针变量名即可如f(p)和f(a)，其他类型实参写为&amp;a ,  &amp;b,  &amp;c等） </span><br><span class="line">2. 形参必须为指针变量（实参的地址传递给形参 , 形参必为指针类型即形参int * a,  int * b,  int * c 等)     </span><br></pre></td></tr></table></div></figure>


        <h4 id="指针和数组"   >
          <a href="#指针和数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4>
      
        <h5 id="指针和一维数组"   >
          <a href="#指针和一维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h5>
      <p>一维数组名</p>
<p>​		一维数组名是个指针（地址）常量</p>
<p>​		它存放的是一维数组第一个元素的地址</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>];<span class="comment">//a是数组名，5是数组的元素个数 元素就是变量 a[0] - a[4] </span></span><br><span class="line"><span class="comment">//	int a[3][4];//3行4列，a[0][0] 是第一个元素，a[i][j]表示第i+1行，第j+1列</span></span><br><span class="line">	<span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//a = b;//error a是常量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%#X\n&quot;</span>,&amp;a[<span class="number">0</span>]); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%#X\n&quot;</span>,a); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%#X\n&quot;</span>,&amp;a[<span class="number">1</span>]); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"><span class="comment">0X62FE00</span></span><br><span class="line"><span class="comment">0X62FE00</span></span><br><span class="line"><span class="comment">0X62FE04</span></span><br><span class="line"><span class="comment">	总结：</span></span><br><span class="line"><span class="comment">		一维数组名</span></span><br><span class="line"><span class="comment">				一维数组名是个指针常量</span></span><br><span class="line"><span class="comment">				它存放的是一维数组第一个元素的地址</span></span><br><span class="line"><span class="comment">--------------------------- </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>下标和指针的关系</p>
<p>​		如果p是个指针变量，则 p[i] 永远等价于 *(p+i) </p>
<p>如果p是指针变量，则 p[ i ] 永远等价于 *(p+i)。</p>
<p>例如，用for循环输出一个数组时，可以这么写：printf(“%d”, <em>(数组名 + i)); 即输出了 <em>数组名、</em>(数组名+1)、</em>(数组名+2) …… 其中一个，等价于printf(“%d”, 数组名[ i ])。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022年7月11日18:03:38</span></span><br><span class="line"><span class="comment">如果p是个指针常量</span></span><br><span class="line"><span class="comment">	p[i] 永远等价于 *(p+i)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而且在数组中，这个 p 不用刻意去定义，而是 数组名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">43</span>,<span class="number">21</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">76</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一维数组名 a 表示 该数组a【0】 的地址，也就是说 a 是个指针（地址）常量 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[3] = %d\n&quot;</span>,a[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[3] = %d\n&quot;</span>,*(a+<span class="number">3</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[0] = %d\n&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[0] = %d\n&quot;</span>,*a);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[0] = %p\n&quot;</span>,&amp;a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[0] = %p\n&quot;</span>,&amp;*a);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[1] = %p\n&quot;</span>,&amp;a[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[1] = %p\n&quot;</span>,&amp;*(a+<span class="number">1</span>));<span class="comment">//这里的加一是因为整形变量在c语言中占4个字节，加的1也是四个字节，所以，加一就是在内存地址中加 4 刚好是下一个数组所在的内存单元的地址 </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[2] = %p\n&quot;</span>,&amp;a[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[2] = %p\n&quot;</span>,&amp;*(a+<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果是：</span></span><br><span class="line"><span class="comment">——————————————</span></span><br><span class="line"><span class="comment">a[3] = 23</span></span><br><span class="line"><span class="comment">a[3] = 23</span></span><br><span class="line"><span class="comment">a[0] = 43</span></span><br><span class="line"><span class="comment">a[0] = 43</span></span><br><span class="line"><span class="comment">a[0] = 000000000062FE00</span></span><br><span class="line"><span class="comment">a[0] = 000000000062FE00</span></span><br><span class="line"><span class="comment">a[1] = 000000000062FE04</span></span><br><span class="line"><span class="comment">a[1] = 000000000062FE04</span></span><br><span class="line"><span class="comment">a[2] = 000000000062FE08</span></span><br><span class="line"><span class="comment">a[2] = 000000000062FE08</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">——————————————</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>对double类型的变量，	p[i] 永远等价于 *(p+i)依旧适用，此时，+1会加8个内存单元。</p>
<p>也就是可以理解为 *(p+i)是直接跳转到下i个内存单元，而不是在内存地址上相加减。</p>
<p>理解数组：为什么a[3]是第四个元素，因为a[3]等价于 *(a+3)，而 (a+3)表示第四个元素的地址</p>
<p>所以*(a+3)表示a[3]表示第四个元素</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053873.png" alt="image-20220711220812196"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> a[<span class="number">6</span>] = &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,a[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,*(a+<span class="number">2</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;*(a+<span class="number">2</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;*(a+<span class="number">3</span>));</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"><span class="comment">000000000062FDD0</span></span><br><span class="line"><span class="comment">000000000062FDD8</span></span><br><span class="line"><span class="comment">000000000062FDE0</span></span><br><span class="line"><span class="comment">000000000062FDE8</span></span><br><span class="line"><span class="comment">000000000062FDF0</span></span><br><span class="line"><span class="comment">000000000062FDF8</span></span><br><span class="line"><span class="comment">6.000000</span></span><br><span class="line"><span class="comment">6.000000</span></span><br><span class="line"><span class="comment">000000000062FDE0</span></span><br><span class="line"><span class="comment">000000000062FDE0</span></span><br><span class="line"><span class="comment">000000000062FDE8</span></span><br><span class="line"><span class="comment">000000000062FDE8</span></span><br><span class="line"><span class="comment">---------------------------- </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>确定一个一维数组需要几个参数？【如果一个函数要处理一个一维数组，则需要接受该数组的哪些信息】</p>
<p>需要两个参数：</p>
<p>​		数组第一个元素的地址</p>
<p>​		数组的长度</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> * pArr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,pArr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">87</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">3</span>] = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="type">int</span> c[<span class="number">100</span>] = &#123;<span class="number">46</span>,<span class="number">8</span>,<span class="number">31</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	f(a,<span class="number">5</span>);</span><br><span class="line">	f(b,<span class="number">3</span>);</span><br><span class="line">	f(c,<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">4  5  9  87  5</span></span><br><span class="line"><span class="comment">2  7  9</span></span><br><span class="line"><span class="comment">46  8  31  4  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0</span></span><br><span class="line"><span class="comment">------------------------------------ </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022年7月11日22:21:05</span></span><br><span class="line"><span class="comment">一定要明白pArr[3]与主函数中的a[3]是同一个变量</span></span><br><span class="line"><span class="comment">注意！这里是同一个变量，而不是指向同一个变量，这里是变量，而不是地址，是取地址！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> * pArr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	pArr[<span class="number">3</span>] = <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">	f(a,<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[<span class="number">3</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">4 </span></span><br><span class="line"><span class="comment">---------------------------------- </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> * pArr, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,  pArr[i]);  <span class="comment">//*(pArr+i) 等价于 pArr[i]  也等价于 b[i] 也等价于 *(b+i) </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">6</span>] = &#123;<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">-6</span>&#125;;</span><br><span class="line"></span><br><span class="line">	f(b, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	b[i]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>指针变量的运算</p>
<p>​		指针变量不能相加，不能相乘，也不能相除</p>
<p>​		如果两个指针变量指向的是同一块连续空间中的不同存储单元，则这两个指针变量才可以相减</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> * p = &amp;i;</span><br><span class="line">	<span class="type">int</span> * q = &amp;j;</span><br><span class="line">	<span class="comment">// q - p没有实际意义</span></span><br><span class="line">	 </span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line">	p = &amp;a[<span class="number">1</span>];</span><br><span class="line">	q = &amp;a[<span class="number">4</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p和q所指向的单元相隔%d个单元\n&quot;</span>,q-p);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>一个指针变量到底占几个字节【非重点】</p>
<p>预备知识：</p>
<p>8bit(位)&#x3D;1Byte(字节)</p>
<p>1024Byte(字节)&#x3D;1KB</p>
<p>1024KB&#x3D;1MB</p>
<p>1024MB&#x3D;1GB</p>
<p>1024GB&#x3D;1TB</p>
<p>​		sizeof(数据类型)</p>
<p>​		功能：返回值就是  该数据类型所占的字节数</p>
<p>​		例子：sizeof(int) &#x3D; 4 sizeof(char) &#x3D; 1</p>
<p>​					sizeof(double) &#x3D; 8</p>
<p>sizeof(变量名)</p>
<p>功能：返回值是该变量所占的字节数</p>
<p>总结：</p>
<p>​		一个指针变量，无论它指向的变量占几个字节，该指针变量本身只占四个字节。</p>
<p>​		一个变量的地址使用该变量首字节的地址来表示</p>
<p><strong>问：一个指针变量到底占几个字节？</strong> </p>
<p>答：因机器不同所占的字节数也有所不同。在32位的机器上，一个指针变量占4个字节，在 64 位的机器上，一个指针变量占8个字节。先看一个例子：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">99</span>;</span><br><span class="line">	<span class="type">double</span> x = <span class="number">66.6</span>;</span><br><span class="line">	<span class="type">char</span> * p = &amp;ch;</span><br><span class="line">	<span class="type">int</span> * q = &amp;i;</span><br><span class="line">	<span class="type">double</span> * r = &amp;x;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,<span class="keyword">sizeof</span>(p),<span class="keyword">sizeof</span>(q),<span class="keyword">sizeof</span>(r));</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>上述代码中，定义了3个变量，分别是char、int、double类型，还定义了3个指针变量p、q、r，分别指向char、int、double类型。然后输出这3个指针变量的值。 按理说，char占1个字节，int占4个字节，double占8个字节，当然分别指向它们的指针变量所占的字节数应该是不同的。可是，果真是这样吗？编译后运行，我们得到结果： 4 4 4 。 </p>
<p>也就是说，分别指向3个不同类型的指针变量它们所占的字节数是相同的，都是4个字节。 这是为什么呢？ </p>
<p>首先，我们来看一看ch 、i、x这3个变量在内存中是如何存储的。 </p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053874.jpg" alt="img">	P指向ch,q指向i,r指向x,ch占1个字节，i占4个字节，r占8个字节，那么是不是p指向了1个字节，q指向了4个字节，r指向了8个字节呢？ </p>
<p>当然不是。 </p>
<p>首先要明白的是，在硬件层面上，最小的单位不是位，而是字节。所以地址不是以位来表示的，而是以字节来表示的。以上图的x变量为例。因为x占了8个字节，所以在地址编号上，它有8个编号。（一个字节一个编号嘛），既然r指向了x,那么r是不是同时指向了这8个编号呢？</p>
<p>不是。r是指向了这8个编号当中的第一个编号。即x的首地址。我们一般都是以一个变量的首地址来表示整个变量的。同理，q指向了i,但它并不是同时指向了4个字节，只是指向了i的首地址。ch就不用说了，因为它只占一个字节。 </p>
<p>为什么r明明只指向了1个字节，但是它却可以表示8个字节？为什么q只指向了1个字节，但是它却可以表示4个字节？我为什么不能说r表示的是从它指向的那个字节开始的4个？我为什么不能说q表示的是从它指向的那个字节开始的2个？这是由什么来决定的呢？ </p>
<p>答案是：这是由指针变量的类型来决定的。 </p>
<p>请看这一句：double * r &#x3D;&amp;x; </p>
<p>因为我们在声明指针变量r时，是把它声明为一个double类型的变量。Double类型的变量在内存中就是占8个字节的，所以，虽然r指向的是x的首地址，但编译器会认为r表示的是从它指向的那个地址开始的8个字节所代表的变量。 </p>
<p>同理，因为q是一个int类型的指针变量，所以编译器会认为q表示的是从它指向的那个地址开始的4个字节所代表的变量。 </p>
<p><strong>接下来：为什么p、q、r中只存放了1个字节的地址，但却都占了4个字节呢？</strong> </p>
<p>这是因为第1个字节的地址只是一个编号，指针变量是存储那个编号的。为了存储那个编号，需要动用4个字节的存储空间。 </p>
<p>听起来似乎有点难以理解。你明明只有1个字节，为什么要用4个字节的空间去存储？这样不是浪费了3个字节吗？ </p>
<p>内存当中有很多的编号，代表着不同的地址。越往后的地址编号越大。有的单元当中可能只存储一个字节，但因为这个单元的位置比较靠后，所以编号当然就大了。 </p>
<p>可是，为什么是4个字节呢？ </p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053875.jpg" alt="img"></p>
<p>在32位的计算机中，CPU是以32根地址总线来控制与内存的数据交换的。1根地址总线可以表示2种状态（1个0和1个1)，2根地址总线可以表示4种状态，3根地址总线可以表示8种状态，32根地址总线总共可以表示 2的32 次方种状态，也就是说他能够确定 2的32次方 个单元或者说它有 2的32次 方个编号。 </p>
<p>因此，从第1个编号一直到最后一个编号，每一个编号都需要用32根线来表示，只不过每一个编号都需要用32根线的不同状态来表示。比如编号为0的单元其实是表示为00000……000000,共32个0，编号为1的单元其实是表示为00000…..000001,共31个0和1个1。最后一个编号其实就是表示为11111……11111，共32个1。所以，从第1个字节一直到最后一个字节都需要用32位来表示。而一个字节是8位，即每个单元要用32&#x2F;8&#x3D;4个字节来表示。 </p>
<p>指针变量是保存一个变量地址的变量，它里面保存的是一个特殊的东西：地址，即内存单元。一个内存单元要用32个状态来表示，（32个0和1），一个0或1占用1个位，8个位是一个字节，所以当然要占用32&#x2F;8&#x3D;4个字节的空间。</p>

        <h5 id="指针和二维数组"   >
          <a href="#指针和二维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a>指针和二维数组</h5>
      
        <h4 id="指针和函数"   >
          <a href="#指针和函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h4>
      
        <h4 id="指针和结构体【重点】"   >
          <a href="#指针和结构体【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和结构体【重点】" class="headerlink" title="指针和结构体【重点】"></a>指针和结构体【重点】</h4>
      
        <h4 id="多级指针"   >
          <a href="#多级指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;i;</span><br><span class="line">    <span class="type">int</span> ** q = &amp;p;</span><br><span class="line">    <span class="type">int</span> *** r = &amp;q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//r = &amp;p;//因为r是int *** 类型，r只能存放 int ** 类型变量的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,***r);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053876.png" alt="image-20220713170959106"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> ** q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//q 是 p 的地址，*q 就是 p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;i;</span><br><span class="line">    </span><br><span class="line">    f(&amp;p);<span class="comment">//p是int * 类型，&amp;p是int ** 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    g();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="专题：动态内存分配"   >
          <a href="#专题：动态内存分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#专题：动态内存分配" class="headerlink" title="专题：动态内存分配"></a>专题：动态内存分配</h3>
      
        <h4 id="传统数组的缺点"   >
          <a href="#传统数组的缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#传统数组的缺点" class="headerlink" title="传统数组的缺点"></a>传统数组的缺点</h4>
      <ol>
<li><p><strong>数组长度必须事先指定，且只能是常整数，不能是变量</strong><br>例子</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];<span class="comment">//OK</span></span><br><span class="line"><span class="type">int</span> len = <span class="number">5</span>;<span class="type">int</span> a[len];<span class="comment">//error</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p><strong>传统形式定义的数组，该数组的内存程序员无法手动释放</strong><br>在一个函数运行的期间，系统为该函数中数组所分配的空间会一直存在，直到该函数运行完毕时，数组的空间才会被系统释放</p>
</li>
<li><p><strong>数组的长度一旦定义，其长度就不能再次更改</strong><br>数组的长度不能在函数运行的过程中动态的扩充或缩小</p>
</li>
<li><p><strong>传统方式定义的数组不能跨函数使用</strong><br>A函数定义的数组，在A函数运行期间可以被其它函数使用，但A函数运行完毕之后，A函数中的数组将无法在其它函数使用</p>
</li>
</ol>

        <h4 id="为什么需要动态分配内存"   >
          <a href="#为什么需要动态分配内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要动态分配内存" class="headerlink" title="为什么需要动态分配内存"></a>为什么需要动态分配内存</h4>
      <p>动态数组很好的解决了传统数组的4个缺陷</p>
<p>传统数组也叫静态数组</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053877.png" alt="image-20220712183915278"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2022年7月12日18:30:50 </span></span><br><span class="line"><span class="comment">	malloc 是 memory(内存) allocate(分配)的缩写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">5</span>;<span class="comment">//分配了4个字节，静态分配</span></span><br><span class="line"><span class="comment">//	int * p = (int)malloc(4);//从&#x27;void*&#x27;转换为&#x27;int&#x27;失去精度[-fpermissive]</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>); </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1.要是用malloc函数，必须添加malloc.h这个头文件</span></span><br><span class="line"><span class="comment">		2.malloc函数 只有一个形参，并且形参是整形</span></span><br><span class="line"><span class="comment">		3.形参（4）表示请求系统为本程序分配4个字节 </span></span><br><span class="line"><span class="comment">		4.malloc函数只能返回第一个字节的地址，(int *)表示将分配的4个字节强制转换为 int *类型</span></span><br><span class="line"><span class="comment">		5.13行分配了8个字节，p占4个字节，p所指向的内存也占4个字节</span></span><br><span class="line"><span class="comment">		6.p本身所占的内存是静态分配的，p所指向的内存是动态分配的 </span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	</span><br><span class="line">	*p = <span class="number">5</span>; <span class="comment">//*p 代表的就是一个int变量， 只不过*p这个整型变量的内存分配方式和11行的i变量的分配方式不同</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">	<span class="built_in">free</span>(p); <span class="comment">//freep(p)表示把p所指向的内存给释放掉  p本身的内存是静态的，不能由程序员手动释放，p本身的内存只能在p变量所在的函数运行终止时由系统自动释放 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;同志们好！\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">--------------------------------</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">10056032</span></span><br><span class="line"><span class="comment">同志们好！</span></span><br><span class="line"><span class="comment">-------------------------------- </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053878.png" alt="image-20220712184149297"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053879.png" alt="image-20220712185932987"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> * q)</span></span><br><span class="line">&#123;</span><br><span class="line">	*q = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">free</span>(q);<span class="comment">//把q所指向的内存单元释放，会导致17行代码出错 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//sizeof(int)返回值是int所占的字节数 </span></span><br><span class="line">	*p = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">	f(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>


        <h4 id="动态内存分配举例-动态数组的构造"   >
          <a href="#动态内存分配举例-动态数组的构造" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态内存分配举例-动态数组的构造" class="headerlink" title="动态内存分配举例_动态数组的构造"></a>动态内存分配举例_动态数组的构造</h4>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053880.png" alt="image-20220713095025757"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053881.png" alt="image-20220713095903713"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>];<span class="comment">//如果int类型占4个字节的话，本数组占20个字节，每四个字节被当做了一个int变量来实用 </span></span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">int</span> * pArr;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要定义的数组的长度：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">	pArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>*len);<span class="comment">//本行动态的构造了一个一维数组，该一维数组的长度是len，该数组的数组名是pArr，该数组的每个元素是int类型，类似于 int a[len];</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1.pArr存放的是第一个字节的地址，但是又由于pArr本身是int *类型，</span></span><br><span class="line"><span class="comment">		  所以pArr指向的是前四个字节！</span></span><br><span class="line"><span class="comment">		  也就是说，如果 强制转换类型 和 pArr 是double *类型的话。pArr存放的就是double类型的首地址，pArr指向的就是前8个字节，是char *；类型的话，指向的就是前1个字节</span></span><br><span class="line"><span class="comment">		2.*(pArr + 1)指向的就是后4个字节（8个，1个）</span></span><br><span class="line"><span class="comment">		参考为什么需要动态分配内存的第一张图，数据类型决定指向多么大的整块的地址 </span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对动态数组的操作</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对数组进行赋值 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Valuation</span><span class="params">(<span class="type">int</span> * f,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d,&quot;</span>,&amp;f[i]);<span class="comment">//以逗号隔开，这里的逗号叫非输入控制符</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数组进行输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outPut</span><span class="params">(<span class="type">int</span> * g,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>];<span class="comment">//如果int类型占4个字节的话，本数组占20个字节，每四个字节被当做了一个int变量来实用 </span></span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">int</span> * pArr;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要定义的数组的长度：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">	pArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>*len);<span class="comment">//本行动态的构造了一个一维数组，该一维数组的长度是len，该数组的数组名是pArr，该数组的每个元素是int类型，类似于 int a[len];</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1.pArr存放的是第一个字节的地址，但是又由于pArr本身是int *类型，</span></span><br><span class="line"><span class="comment">		  所以pArr指向的是前四个字节！</span></span><br><span class="line"><span class="comment">		  也就是说，如果 强制转换类型 和 pArr 是double *类型的话。pArr存放的就是double类型的首地址，pArr指向的就是前8个字节，是char *；类型的话，指向的就是前1个字节</span></span><br><span class="line"><span class="comment">		2.*(pArr + 1)指向的就是后4个字节（8个，1个）</span></span><br><span class="line"><span class="comment">		参考为什么需要动态分配内存的第一张图，数据类型决定指向多么大的整块的地址 </span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//上面已经定义好了一个动态数组，接下来对它进行操作(次数运用函数进行赋值和输出)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入数组的%d元素\n，以英文,隔开&quot;</span>,len);</span><br><span class="line">	</span><br><span class="line">	Valuation(pArr,len);</span><br><span class="line">	</span><br><span class="line">	outPut(pArr,len);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(pArr);</span><br><span class="line">	</span><br><span class="line">	outPut(pArr,len);<span class="comment">//释放内存后再次输出动态数组中的值将是垃圾值 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="动态内存和静态内存的比较"   >
          <a href="#动态内存和静态内存的比较" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态内存和静态内存的比较" class="headerlink" title="动态内存和静态内存的比较"></a>动态内存和静态内存的比较</h4>
      <p>静态内存是由系统自动分配，由系统自动释放</p>
<p>静态内存是在栈分配的</p>
<p>main调用f()函数，就是为f()函数在栈中分配存储空间，而静态内存为什么不能跨函数使用呢？</p>
<p>因为调用的这个函数一终止，为该函数分配的内存空间就会释放，也就是出栈了。<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053882.png" alt="image-20220713165402538"></p>
<p>动态内存是由程序员手动分配，手动释放</p>
<p>动态内存是在堆（堆排序）分配的</p>

        <h4 id="跨函数使用内存的问题"   >
          <a href="#跨函数使用内存的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#跨函数使用内存的问题" class="headerlink" title="跨函数使用内存的问题"></a>跨函数使用内存的问题</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> ** q)</span><span class="comment">//q是一个指针变量，无论q是什么类型的指针变量，都只占4个字节 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">	<span class="comment">//*q 等价于 p </span></span><br><span class="line">	*q = &amp;i;<span class="comment">//等价于 p = &amp;i; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	</span><br><span class="line">	f(&amp;p);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);<span class="comment">//此处无语法错误，但是有逻辑错误</span></span><br><span class="line">	<span class="comment">//f函数中的i在f函数调用完之后，内存单元已经释放，此时输出*p将指向的是一个垃圾值 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>跨函数使用内存（在被调函数中使用动态分配内存）</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> ** q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	q = (int **)malloc(sizeof(int));//sizeof(数据类型) 返回值是该数据类型所占的字节数 </span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	q存放的是p的地址，*q就是p，**q就是*p，</span></span><br><span class="line"><span class="comment">	动态的分配了4个字节给 int ** 类型 </span></span><br><span class="line"><span class="comment">	(int*)malloc(sizeof(int)) 将申请得到的空间地址转换成了int类型空间地址</span></span><br><span class="line"><span class="comment">	而无法申请空间地址转换为 int * 类型空间地址 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		*q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//sizeof(数据类型) 返回值是该数据类型所占的字节数 </span></span><br><span class="line"></span><br><span class="line">	**q = <span class="number">5</span>;<span class="comment">//等价于*p = 5; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	</span><br><span class="line">	f(&amp;p);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="结构体"   >
          <a href="#结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2>
      
        <h3 id="为什么需要结构体"   >
          <a href="#为什么需要结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要结构体" class="headerlink" title="为什么需要结构体"></a>为什么需要结构体</h3>
      <p>为了表示一些复杂的事物，而普通的基本类型无法满足实际要求。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span> &#123;<span class="number">80</span>, <span class="number">66.6</span>, <span class="string">&#x27;F&#x27;</span>&#125;;	</span><br><span class="line"><span class="comment">/*	int age;</span></span><br><span class="line"><span class="comment">	float score;</span></span><br><span class="line"><span class="comment">	char sex;</span></span><br><span class="line"><span class="comment">	int age2;</span></span><br><span class="line"><span class="comment">	float score2;</span></span><br><span class="line"><span class="comment">	char sex2;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="什么叫结构体"   >
          <a href="#什么叫结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么叫结构体" class="headerlink" title="什么叫结构体"></a>什么叫结构体</h3>
      <p>把一些基本类型数据组合在一起形成的一个新的复合数据类型，这个叫做结构体</p>

        <h3 id="如何定义结构体"   >
          <a href="#如何定义结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何定义结构体" class="headerlink" title="如何定义结构体"></a>如何定义结构体</h3>
      <p>3种方式，推荐使用第一种</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">&#125;;<span class="comment">//定义了一个新的数据类型，相当于int 此处并没有定义变量 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>下面的两种定义</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">&#125; st2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">&#125; st3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span> &#123;<span class="number">80</span>, <span class="number">66.6</span>, <span class="string">&#x27;F&#x27;</span>&#125;;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="怎样使用结构体变量"   >
          <a href="#怎样使用结构体变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎样使用结构体变量" class="headerlink" title="怎样使用结构体变量"></a>怎样使用结构体变量</h3>
      
        <h4 id="赋值和初始化"   >
          <a href="#赋值和初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#赋值和初始化" class="headerlink" title="赋值和初始化"></a>赋值和初始化</h4>
      <p>定义的同时可以整体赋初值</p>
<p>如果定义完之后，则只能单个的赋初值</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="type">float</span> score;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">st</span> =</span> &#123;<span class="number">80</span>,<span class="string">&#x27;F&#x27;</span>,<span class="number">66.6F</span> </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">st2</span>;</span></span><br><span class="line">	st2.age = <span class="number">23</span>;</span><br><span class="line">	st2.score = <span class="number">359</span>;</span><br><span class="line">	st2.sex = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %f %c\n&quot;</span>,st2.age,st2.score,st2.sex); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="如何取出结构体变量中的每一个成员【重点】"   >
          <a href="#如何取出结构体变量中的每一个成员【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何取出结构体变量中的每一个成员【重点】" class="headerlink" title="如何取出结构体变量中的每一个成员【重点】"></a>如何取出结构体变量中的每一个成员【重点】</h4>
      <ol>
<li>结构体变量名.成员名</li>
<li>指针变量名 -&gt; 成员名（第二种方式更常用）<br>*<em>指针变量名 -&gt; 成员名 在计算机内部会被转化成 (<em>指针变量名).成员名 的方式来执行，所以说这两种方式是等价的。</em></em></li>
</ol>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span> &#123;<span class="number">80</span>,<span class="number">66.6F</span>,<span class="string">&#x27;F&#x27;</span></span><br><span class="line">	&#125;;<span class="comment">//初始化的同时赋初值</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span> =</span> &amp;st;<span class="comment">// pst是 struct Student * 类型，所以必须是&amp;st;</span></span><br><span class="line">	</span><br><span class="line">	st.age = <span class="number">88</span>;<span class="comment">//第一种方式</span></span><br><span class="line">	pst-&gt;score = <span class="number">56.6F</span>;<span class="comment">//第二种方式</span></span><br><span class="line">    <span class="comment">//66.6默认为double类型，如果需要定义为float类型需要加f或F </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %f&quot;</span>,pst-&gt;age,st.score);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*88 56.599998*/</span></span><br></pre></td></tr></table></div></figure>

<ol>
<li>**pst-&gt;age 在计算机内部会被转换为(*pst).age**，没有什么为什么，这就是-&gt;的含义，也是一种硬性规定。</li>
<li>*<em>所以 pst-&gt;age 等价于 (<em>pst).age 也等价于 st.age</em></em></li>
<li>*<em>我们之所以知道 pst -&gt; age等价于 st.age，是因为pst -&gt; age是被转化成了(<em>pst).age来执行</em></em></li>
<li>pst-&gt;age的含义<br><strong>pst 指向的那个结构体变量中的 age 这个成员</strong></li>
</ol>

        <h3 id="结构体变量和结构体指针变量作为函数参数传递的问题"   >
          <a href="#结构体变量和结构体指针变量作为函数参数传递的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#结构体变量和结构体指针变量作为函数参数传递的问题" class="headerlink" title="结构体变量和结构体指针变量作为函数参数传递的问题"></a>结构体变量和结构体指针变量作为函数参数传递的问题</h3>
      
        <h4 id="内存详解【重点！】"   >
          <a href="#内存详解【重点！】" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存详解【重点！】" class="headerlink" title="内存详解【重点！】"></a>内存详解【重点！】</h4>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053883.png" alt="image-20220714185344439"></p>
<p><strong>double x &#x3D; 6.6;</strong></p>
<p><strong>double * p;</strong></p>
<p><strong>p &#x3D; &amp;x;</strong></p>
<p><strong>定义了一个double类型的变量，分配了8个字节（一个字节有8位：因为是128个字符，第128是100000000，【System&#x2F;360】奠定了字符存储单位采用8位长度的基础，这就是【1字节&#x3D;8位】的由来。）；</strong></p>
<p><strong>又定义了一个double * 类型的变量p，系统分配了4个字节（因为*类型就是用来存放地址的，在32位电脑中，一共有32跟地址总线，也就是有32位数字来表示一个地址单元，8位一个字节，故而分配了4个字节给了p）；</strong></p>
<p>**把x的地址给了p，p只存放了x的首地址，而p是double * ，类型，故系统就知道了p指向的是首地址开始的8个字节（一整块儿），如果x是int类型，p也是int *类型，那么p存放完x的首地址之后，指向之后的4个字节，而 <em>(p + 1)则是指向下4个字节，也是因为p是int <em>类型。</em></em></p>
<p>推荐使用结构体指针变量作为函数参数来传递</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2009年11月24日9:17:43</span></span><br><span class="line"><span class="comment">	老师代码</span></span><br><span class="line"><span class="comment">	通过函数完成对结构体变量的输入和输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">&#125;; <span class="comment">//分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InputStudent</span><span class="params">(<span class="keyword">struct</span> Student *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent</span><span class="params">(<span class="keyword">struct</span> Student ss)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span>  <span class="comment">//15行</span></span><br><span class="line"></span><br><span class="line">	InputStudent(&amp;st); <span class="comment">//对结构体变量输入  必须发送st的地址</span></span><br><span class="line"><span class="comment">//	printf(&quot;%d %c %s\n&quot;, st.age, st.sex, st.name);</span></span><br><span class="line">	OutputStudent(st); <span class="comment">//对结构体变量输出  可以发送st的地址也可以直接发送st的内容</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent</span><span class="params">(<span class="keyword">struct</span> Student ss)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %c %s\n&quot;</span>, ss.age, ss.sex, ss.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InputStudent</span><span class="params">(<span class="keyword">struct</span> Student * pstu)</span> <span class="comment">//pstu只占4个字节</span></span><br><span class="line">&#123;</span><br><span class="line">	(*pstu).age = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(pstu-&gt;name, <span class="string">&quot;张三&quot;</span>);<span class="comment">//strcpy把含有&#x27;\0&#x27;结束符的字符串复制到另一个地址空间，返回值的类型为char*。</span></span><br><span class="line">	pstu-&gt;sex = <span class="string">&#x27;F&#x27;</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//本函数无法修改主函数15行st的值 所以本函数是错误的</span></span><br><span class="line"><span class="comment">void InputStudent(struct Student stu)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	stu.age = 10;</span></span><br><span class="line"><span class="comment">	strcpy(stu.name, &quot;张三&quot;);  //不能写成 stu.name = &quot;张三&quot;;</span></span><br><span class="line"><span class="comment">	stu.sex = &#x27;F&#x27;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022年7月14日21:31:50</span></span><br><span class="line"><span class="comment">自己代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntputStudent1</span><span class="params">(<span class="keyword">struct</span> Student stu)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent1</span><span class="params">(<span class="keyword">struct</span> Student stu)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntputStudent2</span><span class="params">(<span class="keyword">struct</span> Student * stu)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent2</span><span class="params">(<span class="keyword">struct</span> Student stu)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">double</span> score;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">7</span>]; </span><br><span class="line">&#125;;<span class="comment">//至少占 20 个字节 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line">	</span><br><span class="line">	IntputStudent2(&amp;st);</span><br><span class="line">	OutputStudent2(st);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntputStudent2</span><span class="params">(<span class="keyword">struct</span> Student * stu)</span><span class="comment">//形参是struct Student * 类型，存放的是实参的首地址，占4个字节 </span></span><br><span class="line">&#123;</span><br><span class="line">	(*stu).age = <span class="number">20</span>;<span class="comment">//stu存放的是st的地址，*stu就是st本身，故 (*stu).age 等价于 st.age </span></span><br><span class="line">	<span class="built_in">strcpy</span>((*stu).name ,<span class="string">&quot;张智超&quot;</span>);<span class="comment">//stu.name = &quot;张智超&quot;;</span></span><br><span class="line">	(*stu).score = <span class="number">389</span>;</span><br><span class="line">	(*stu).sex = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void IntputStudent2(struct Student * stu)//形参是struct Student * 类型，存放的是实参的首地址，占4个字节 </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	stu-&gt;age = 20;</span></span><br><span class="line"><span class="comment">//	strcpy(stu-&gt;name ,&quot;张智超&quot;);//stu.name = &quot;张智超&quot;;</span></span><br><span class="line"><span class="comment">//	stu-&gt;score = 389;</span></span><br><span class="line"><span class="comment">//	stu-&gt;sex = &#x27;N&#x27;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent2</span><span class="params">(<span class="keyword">struct</span> Student stu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %lf %c %s&quot;</span>,stu.age,stu.score,stu.sex,stu.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntputStudent1</span><span class="params">(<span class="keyword">struct</span> Student stu)</span><span class="comment">//形参是新定义的数据类型，至少占20个字节，函数运行结束之后空间释放，就不行了，故得考虑用指针 </span></span><br><span class="line">&#123;</span><br><span class="line">	stu.age = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(stu.name ,<span class="string">&quot;张智超&quot;</span>);<span class="comment">//stu.name = &quot;张智超&quot;;</span></span><br><span class="line">	stu.score = <span class="number">389</span>;</span><br><span class="line">	stu.sex = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent1</span><span class="params">(<span class="keyword">struct</span> Student stu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %lf %c %s&quot;</span>,stu.age,stu.score,stu.sex,stu.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>发送地址还是发送变量</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2009年11月24日9:17:43</span></span><br><span class="line"><span class="comment">	示例:</span></span><br><span class="line"><span class="comment">		发送地址还是发送内容</span></span><br><span class="line"><span class="comment">	目的:</span></span><br><span class="line"><span class="comment">		指针的优点之一:</span></span><br><span class="line"><span class="comment">			快速的传递数据，</span></span><br><span class="line"><span class="comment">			耗用内存小</span></span><br><span class="line"><span class="comment">			执行速度快</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">&#125;; <span class="comment">//分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InputStudent</span><span class="params">(<span class="keyword">struct</span> Student *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent</span><span class="params">(<span class="keyword">struct</span> Student *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> ;</span>  <span class="comment">//15行</span></span><br><span class="line">	<span class="comment">//printf(&quot;%d\n&quot;, sizeof(st));</span></span><br><span class="line"></span><br><span class="line">	InputStudent(&amp;st); <span class="comment">//对结构体变量输入  必须发送st的地址</span></span><br><span class="line">	OutputStudent(&amp;st); <span class="comment">//对结构体变量输出  可以发送st的地址也可以直接发送st的内容 但为了减少内存的耗费，也为了提高执行速度，推荐发送地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputStudent</span><span class="params">(<span class="keyword">struct</span> Student *pst)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %c %s\n&quot;</span>, pst-&gt;age, pst-&gt;sex, pst-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InputStudent</span><span class="params">(<span class="keyword">struct</span> Student * pstu)</span> <span class="comment">//pstu只占4个字节</span></span><br><span class="line">&#123;</span><br><span class="line">	(*pstu).age = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(pstu-&gt;name, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	pstu-&gt;sex = <span class="string">&#x27;F&#x27;</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//本函数无法修改主函数15行st的值 所以本函数是错误的</span></span><br><span class="line"><span class="comment">void InputStudent(struct Student stu)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	stu.age = 10;</span></span><br><span class="line"><span class="comment">	strcpy(stu.name, &quot;张三&quot;);  //不能写成 stu.name = &quot;张三&quot;;</span></span><br><span class="line"><span class="comment">	stu.sex = &#x27;F&#x27;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="结构体变量的运算"   >
          <a href="#结构体变量的运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#结构体变量的运算" class="headerlink" title="结构体变量的运算"></a>结构体变量的运算</h3>
      <p>结构体变量不能相加，不能相减，也不能相互乘除</p>
<p>但结构体变量可以相互赋值</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">	<span class="type">char</span> sex: </span><br><span class="line">	<span class="type">char</span> name[<span class="number">100</span>J;</span><br><span class="line">&#125;; <span class="comment">//分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st1</span>, <span class="title">st2</span>;</span> </span><br><span class="line">stl+st2 st1*st2 stl/st2 都是错误的</span><br><span class="line">stl = st2 或者st2 = stl 都是正确的</span><br></pre></td></tr></table></div></figure>


        <h4 id="举例（学生管理系统）"   >
          <a href="#举例（学生管理系统）" class="heading-link"><i class="fas fa-link"></i></a><a href="#举例（学生管理系统）" class="headerlink" title="举例（学生管理系统）"></a>举例（学生管理系统）</h4>
      <p>动态构造存放学生信息的结构体数组</p>
<p>动态构造一个数组，存放学生的信息</p>
<p>然后按分数排序输出</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151053884.png" alt="image-20220714223631576"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pArr</span>;</span></span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">t</span>;</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//动态的构造一维数组</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入学生的个数:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;len = &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">	pArr = (<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输入</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个学生的信息:\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;age = &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pArr[i].age);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;name = &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pArr[i].name);  <span class="comment">//name是数组名，本身就已经是数组首元素的地址, 所以pArr[i].name 不能改成 &amp;pArr[i].name</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;score = &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;pArr[i].score);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//按学生成绩升序排序 冒泡算法</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>-i; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (pArr[j].score &gt; pArr[j+<span class="number">1</span>].score) <span class="comment">//&gt;升序 &lt;降序</span></span><br><span class="line">			&#123;</span><br><span class="line">				t = pArr[j];</span><br><span class="line">				pArr[j] = pArr[j+<span class="number">1</span>];</span><br><span class="line">				pArr[j+<span class="number">1</span>] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n学生的信息是:\n&quot;</span>);</span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d个学生的信息是:\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;age = %d\n&quot;</span>, pArr[i].age);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>, pArr[i].name);  <span class="comment">//name是数组名，本身就已经是数组首元素的地址, 所以pArr[i].name 不能改成 &amp;pArr[i].name</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;score = %f\n&quot;</span>, pArr[i].score);</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;数据类型:pArr结构体指针变量,  pArr[i]结构体变量,  pArr[i].age结构体变量的整型元素,  pArr[i].name结构体变量的字符数组元素</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2022年7月15日11:21:09</span></span><br><span class="line"><span class="comment">	用函数实现学生管理系统</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InPut</span><span class="params">(<span class="keyword">struct</span> Student * pAr,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OutPut</span><span class="params">(<span class="keyword">struct</span> Student * pAr,<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="keyword">struct</span> Student * pAr,<span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//动态构造一维数组</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入学生的个数\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pArr</span>;</span><span class="comment">//int * pArr</span></span><br><span class="line">	pArr = (<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line"></span><br><span class="line">	InPut(pArr,len);<span class="comment">//对数组进行输入</span></span><br><span class="line">	sort(pArr,len);<span class="comment">//对数组依据学生成绩排序</span></span><br><span class="line">	OutPut(pArr,len);<span class="comment">//对数组内容进行输出</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InPut</span><span class="params">(<span class="keyword">struct</span> Student * pAr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个学生的年龄：\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pAr[i].age);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个学生的成绩：\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;pAr[i].score);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个学生的名字：\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,pAr[i].name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OutPut</span><span class="params">(<span class="keyword">struct</span> Student * pAr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\n数据库中存储的学生信息为：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d位学生的年龄为\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pAr[i].age);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d个学生的成绩为：\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,pAr[i].score);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d个学生的名字为：\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,pAr[i].name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="keyword">struct</span> Student * pAr,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; len-i<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(pAr[j].score &gt; pAr[j+<span class="number">1</span>].score)<span class="comment">//升序</span></span><br><span class="line">			&#123;</span><br><span class="line">				t = pAr[j];</span><br><span class="line">				pAr[j] = pAr[j+<span class="number">1</span>];</span><br><span class="line">				pAr[j+<span class="number">1</span>] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h2 id="枚举"   >
          <a href="#枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2>
      
        <h3 id="什么是枚举"   >
          <a href="#什么是枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是枚举" class="headerlink" title="什么是枚举"></a>什么是枚举</h3>
      <p>把一个事物所有可能的取值一一列举出来</p>

        <h3 id="怎么使用枚举"   >
          <a href="#怎么使用枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#怎么使用枚举" class="headerlink" title="怎么使用枚举"></a>怎么使用枚举</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里只是定义了一个（枚举类型enumweekday），就像int类型，char类型一样 </span></span><br><span class="line">enumweekday </span><br><span class="line">&#123; </span><br><span class="line"> monday, tuesday, wednesday, tursday, friday, saturday, sunday </span><br><span class="line">&#125;; <span class="comment">//注意：分号不能省略 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line"> enumweekday day; </span><br><span class="line"> day = wednesday;<span class="comment">//右边只能写（枚举类型enumweekday）中的，其物理内部默认从零开始 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, day);<span class="comment">//结果为2。若将enumweekday中monday改为monday=4，运行结果为6 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="枚举的优缺点"   >
          <a href="#枚举的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#枚举的优缺点" class="headerlink" title="枚举的优缺点"></a>枚举的优缺点</h3>
      <p>代码更安全</p>
<p>书写麻烦</p>

        <h2 id="链表"   >
          <a href="#链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#链表" class="headerlink" title="链表"></a>链表</h2>
      
        <h3 id="算法："   >
          <a href="#算法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3>
      
        <h4 id="通俗定义："   >
          <a href="#通俗定义：" class="heading-link"><i class="fas fa-link"></i></a><a href="#通俗定义：" class="headerlink" title="通俗定义："></a>通俗定义：</h4>
      <p>解题的方法和步骤</p>

        <h4 id="狭义定义："   >
          <a href="#狭义定义：" class="heading-link"><i class="fas fa-link"></i></a><a href="#狭义定义：" class="headerlink" title="狭义定义："></a>狭义定义：</h4>
      <p>对存储数据的操作</p>
<p> 对不同的存储结构，要完成某一个功能所执行的操作是不一样的 </p>
<p>比如：要输出数组中所有的元素的操作 和 要输出链表中所有元素的操作肯定是不一样的 这说明：</p>
<p><strong>算法是依附于存储结构的</strong></p>
<p><strong>不同的存储结构，所执行的算法是不一样的</strong></p>

        <h4 id="广义定义："   >
          <a href="#广义定义：" class="heading-link"><i class="fas fa-link"></i></a><a href="#广义定义：" class="headerlink" title="广义定义："></a>广义定义：</h4>
      <p><strong>广义的算法也叫泛型</strong></p>
<p><strong>无论数据是如何存储的，对该数据的操作都是一样的</strong></p>

        <h3 id="我们至少可以通过两种结构来存储数据"   >
          <a href="#我们至少可以通过两种结构来存储数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#我们至少可以通过两种结构来存储数据" class="headerlink" title="我们至少可以通过两种结构来存储数据"></a>我们至少可以通过两种结构来存储数据</h3>
      
        <h4 id="数组-1"   >
          <a href="#数组-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4>
      <p>优点：</p>
<p>​	存取速度快</p>
<p>缺点：</p>
<p>​	需要一个连续的很大的内存</p>
<p>​	插入和删除元素的效率很低</p>

        <h4 id="链表-1"   >
          <a href="#链表-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#链表-1" class="headerlink" title="链表"></a>链表</h4>
      <p>优点：</p>
<p>​		插入删除元素效率高</p>
<p>​		不需要一个连续的很大的内存</p>
<p>缺点：</p>
<p>​		查找某个位置的元素效率低</p>
<p>专业术语：</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207201059543.png" alt="image-20220720105944414"></p>
<p>​		<strong>首节点</strong></p>
<p>​				存放第一个有效数据的节点</p>
<p>​		<strong>尾节点</strong></p>
<p>​				存放最后一个有效数据的节点</p>
<p>​		<strong>头结点</strong></p>
<p>​				头结点的数据类型和首节点的类型是一摸一样的</p>
<p>​				头结点是首节点前面的那个节点 </p>
<p>​				头结点并不存放有效数据</p>
<p>​				设置头结点的目的是为了方便对链表的操作</p>
<p>​		<strong>头指针</strong></p>
<p>​				存放头结点地址的指针变量</p>
<p><strong>确定一个链表需要一个参数</strong></p>
<p>​		<strong>头指针</strong></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207201047867.png" alt="image-20220720104720709"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个链表节点的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> date;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//递归，指向下一个链表的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207201143349.png" alt="image-20220720114312219"></p>

        <h2 id="内存"   >
          <a href="#内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存" class="headerlink" title="内存"></a>内存</h2>
      
        <h3 id="内存的基本概念"   >
          <a href="#内存的基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存的基本概念" class="headerlink" title="内存的基本概念"></a>内存的基本概念</h3>
      <ol>
<li><p>内存是用来存储数据的设备。他的存储速度介于寄存器和硬盘之间。</p>
</li>
<li><p>内存是CPU唯一可以访问的大容量的存储设备！所有硬盘中的程序和数据必须调入内存之后方可被CPU执行！切记：CPU不能直接处理硬盘中的数据！</p>
</li>
<li><p>内存的问题是软件开发中最核心的问题之一！如：内存的分配，内存的释放，内存什么时候分配，内存什么时候释放，由谁来分配，由谁来释放，分配在上面地方，访问权限如何！ </p>
</li>
<li><p>内存是多字节组成的线性一维空间</p>
</li>
<li><p>内存的基本划分单元是字节</p>
</li>
<li><p>每个字节含有8位。每一位存放1个0或1个1</p>
</li>
<li><p>字节和编号是一一对应的。每个字节都有一个唯一确定的编号，一个编号对应一个字节！这个编号叫做地址。</p>
</li>
<li><p>一个系统所能管理的内存空间的大小取决于参与编号的二进制位数！<br>如：DOS系统20位寻址方案，可控制2的20次B即1M的内存</p>
</li>
</ol>

        <h3 id="软件运行与内存关系（垃圾数据）"   >
          <a href="#软件运行与内存关系（垃圾数据）" class="heading-link"><i class="fas fa-link"></i></a><a href="#软件运行与内存关系（垃圾数据）" class="headerlink" title="软件运行与内存关系（垃圾数据）"></a>软件运行与内存关系（垃圾数据）</h3>
      <p>内存是在操作系统的统一管理下使用的！</p>
<ol>
<li>软件在运行前需要向操作系统申请存储空间，在内存空闲空间足够时，操作系统将分配一段内存空间并将外存中软件拷贝一份存入该内存空间中，并启动该软件的运行。</li>
<li>在软件运行期间，该软件所占内存空间不再分配给其它软件</li>
<li>当软件运行完毕后，操作系统将回收该内存空间（注意：操作系统并不清空该内存空间中遗留下来的数据，只将该内存的使用权限关闭），以便分配给其他软件使用</li>
</ol>
<p>综上所述：一个软件所分配到的空间中极可能存在着以前其他软件使用过后的残留数据，这些数据被称之为垃圾数据。所以通常情况下我们为一个变量，为一个数组，分配好存储空间之后都要对该内存空间初始化！</p>

        <h2 id="穿插在课堂中的零散知识笔记"   >
          <a href="#穿插在课堂中的零散知识笔记" class="heading-link"><i class="fas fa-link"></i></a><a href="#穿插在课堂中的零散知识笔记" class="headerlink" title="穿插在课堂中的零散知识笔记"></a>穿插在课堂中的零散知识笔记</h2>
      
        <h3 id="算法"   >
          <a href="#算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法" class="headerlink" title="算法"></a>算法</h3>
      <p>算法就是：解题的方法和步骤</p>

        <h3 id="如何看懂一个程序，分三步"   >
          <a href="#如何看懂一个程序，分三步" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何看懂一个程序，分三步" class="headerlink" title="如何看懂一个程序，分三步:"></a>如何看懂一个程序，分三步:</h3>
      <ol>
<li><p>流程</p>
</li>
<li><p>每个语句的功能</p>
</li>
<li><p>试数</p>
</li>
</ol>

        <h3 id="如何学习一些需要算法的程序【如何掌握一个程序】"   >
          <a href="#如何学习一些需要算法的程序【如何掌握一个程序】" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何学习一些需要算法的程序【如何掌握一个程序】" class="headerlink" title="如何学习一些需要算法的程序【如何掌握一个程序】"></a>如何学习一些需要算法的程序【如何掌握一个程序】</h3>
      <ol>
<li>尝试自己去编程解决它<br>但要意识到大部分人都是自己无法解决的，这时不要气馁，也不要自卑，如果十五分钟还想不出来， 此时我建议您就可以看答案了。</li>
<li>如果解决不了， 就看答案<br>关键是把答案看懂， 这个要花很大的精力，也是我们学习的重点，看懂一个程序要分 3步:流程、每个语句的功能、 试数</li>
<li>看懂之后尝试自己去修改程序，并且知道修改之后程序的输出结果的含义<br>不建议看懂程序之后就立即自己敲程序</li>
<li>照着答案去敲</li>
<li>调试错误</li>
<li>不看答案，自己独立把答案敲出来</li>
<li>如果程序实在无法彻底理解， 就把它背会，不过无法彻底理解的程序非常少，</li>
</ol>
<p>我自己只有在学数据结构时碰到过一个， 学其他语言都没有碰到过</p>

        <h3 id="强制类型转化"   >
          <a href="#强制类型转化" class="heading-link"><i class="fas fa-link"></i></a><a href="#强制类型转化" class="headerlink" title="强制类型转化"></a>强制类型转化</h3>
      <p>格式:</p>
<p>​		(数据类型) (表达式)</p>
<p>功能:</p>
<p>​		把表达式的值强制转化为前面所执行的数据类型</p>
<p>例子:</p>
<p>​		(int) (4. 5+2. 2) 最终值是6</p>
<p>​		(f1oat) (5)     	最终值是 5.000000</p>

        <h3 id="浮点数的存错所带来的问题"   >
          <a href="#浮点数的存错所带来的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#浮点数的存错所带来的问题" class="headerlink" title="浮点数的存错所带来的问题"></a>浮点数的存错所带来的问题</h3>
      <p>float double都不能保证可以把所有的实数都准确的保存在计算机中</p>
<p>例子</p>
<p>​		float i &#x3D; 99.9: </p>
<p>​		printf(“%f\n”,i); </p>
<p>​		最终在Vc++6.0 中的输出结果是: 99. 900002 </p>
<p>因为浮点数无法准确存储，所以就衍生出来两个编程问题</p>
<p>有一个浮点型变量X ,如何判断X的值是否是零</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	if (|X-0. 000001| &lt;= 0.000001) </span><br><span class="line">​		是零</span><br><span class="line">​	else </span><br><span class="line">​		不是零</span><br></pre></td></tr></table></div></figure>

<p>为什么循环中更新的变量不能定义成浮点型</p>
<pre><code>    因为浮点数据在计算机中不是精确的数据，因此，有可能不连续，或是运算出BUG
    因此，不建议用浮点数做循环变量！但是可以用。
</code></pre>

        <h3 id="一些琐碎的运算符知识"   >
          <a href="#一些琐碎的运算符知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些琐碎的运算符知识" class="headerlink" title="一些琐碎的运算符知识"></a>一些琐碎的运算符知识</h3>
      
        <h4 id="自增-或者自减"   >
          <a href="#自增-或者自减" class="heading-link"><i class="fas fa-link"></i></a><a href="#自增-或者自减" class="headerlink" title="自增[或者自减]"></a>自增[或者自减]</h4>
      <ol>
<li>分类:<br>前自增 			++i<br>      后自增 			i++ </li>
<li>前自增和后自增的异同:<br>相同：最终都使i的值加1<br>      不同：前自增整体表达式的值是i加1之后的值<br>                  后自增整体表达式的值是i加1之前的值</li>
<li>为什么会出现自增<br>代码更精练<br>      自增的速度更快</li>
<li>学习自增要明自的几个问题：<br>1、我们编程时应该尽量屏蔽掉前自增和后自增的差别<br>2、自增表达式最好不要作为一个更大的表达式的一部分来使用<br>    或者说<br>    i++ ++i 单独成一个语句，不要把它作为一个完整复合语句的一部分来使用<br>如:</li>
</ol>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int m = i++ + ++i + i + i++; //这样写不但是不规范的代码</span><br><span class="line">							//而且是不可移植的代码</span><br><span class="line">printf(&quot;%d %d %d&quot;,i++,++i,i); //同</span><br></pre></td></tr></table></div></figure>


        <h4 id="三目运算符"   >
          <a href="#三目运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4>
      <p>格式</p>
<p>​		A ? B : C </p>
<p>等价</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A)</span><br><span class="line">B;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">C;</span><br></pre></td></tr></table></div></figure>


        <h4 id="逗号表达式"   >
          <a href="#逗号表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h4>
      <p>格式(A, B, C, D) </p>
<p>功能:</p>
<p>从左到右执行</p>
<p>最终表达式的值是最后一项的值</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> j = (i++,++i,i+<span class="number">2</span>,i<span class="number">-2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d,j = %d\n&quot;</span>,i,j);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为</span></span><br><span class="line"><span class="comment">--------------------</span></span><br><span class="line"><span class="comment">i = 6,j = 4</span></span><br><span class="line"><span class="comment">-------------------- </span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></div></figure>


        <h3 id="进制转换"   >
          <a href="#进制转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151114596.png" alt="image-20220715111456464"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151115008.png" alt="image-20220715111544855"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151116955.png" alt="image-20220715111634772"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151117547.png" alt="image-20220715111721395"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151117213.png" alt="image-20220715111757059"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151118959.png" alt="image-20220715111807806"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202207151118146.png" alt="image-20220715111819033"></p>

        <h3 id="补码："   >
          <a href="#补码：" class="heading-link"><i class="fas fa-link"></i></a><a href="#补码：" class="headerlink" title="补码："></a>补码：</h3>
      
        <h4 id="原码"   >
          <a href="#原码" class="heading-link"><i class="fas fa-link"></i></a><a href="#原码" class="headerlink" title="原码"></a>原码</h4>
      <p>也叫 符号 - 绝对值码</p>
<p>最高位 0 表示正 1 表示负，其余二进制位是该数字的绝对值的二进制位</p>
<p>原码简单易懂</p>
<p>加减运算复杂</p>
<p>存在加减乘除四种运算，增加了 CPU 的复杂度</p>
<p>零的表示不唯一</p>

        <h4 id="反码"   >
          <a href="#反码" class="heading-link"><i class="fas fa-link"></i></a><a href="#反码" class="headerlink" title="反码"></a>反码</h4>
      <p>反码运算不便，也没有在计算机中应用</p>

        <h4 id="移码"   >
          <a href="#移码" class="heading-link"><i class="fas fa-link"></i></a><a href="#移码" class="headerlink" title="移码"></a>移码</h4>
      <p>移码表示数值平移n 位，n 称为移码量</p>
<p>移码主要用 于浮点数的阶码的存储</p>

        <h4 id="补码"   >
          <a href="#补码" class="heading-link"><i class="fas fa-link"></i></a><a href="#补码" class="headerlink" title="补码"></a>补码</h4>
      <p>己知十进制求二进制</p>
<p>求正整数的二进制：</p>
<p>​		除2取余，直至商为零，余数逆排</p>
<p>求负整数的二进制</p>
<p>​		先求与该负数相对应的正整数的二进制代码，然后将</p>
<p>​		所有位取反，末尾加1.不够位数时，左边补1</p>
<p>求零的二进制</p>
<p>​		全是零</p>
<p>己知二进制求十进制</p>
<p>​		如果首位是0，则表明是正整数，按普通方法来求</p>
<p>​		如果首位是1则表明是负整数</p>
<p>​				将所有位取反，末尾加1，所得数字就是该负数的绝对值</p>
<p>​		如果全是零，则对应的十进制数字就是零</p>
<p>int类型变量所能存储的最大正数用十六进制表示是：7FFFFFFF</p>
<p>int类型变量所能存储的绝对值最大的负整数用十六进制表示是：80000000</p>
<p>具体可以参见“8位二进制所代表的十进制示意图. jpg”</p>
<p>绝对值最小负数的二进制代码是多少</p>
<p>最大正数的二进制代码是多少</p>
<p>已知一个整数的二进制代码求出原始的数字</p>
<p>数字超过最大正数会怎样</p>
<p>不同类型数据的相互转化</p>

        <h4 id="位运算符："   >
          <a href="#位运算符：" class="heading-link"><i class="fas fa-link"></i></a><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h4>
      
        <h5 id="amp-—-按位于"   >
          <a href="#amp-—-按位于" class="heading-link"><i class="fas fa-link"></i></a><a href="#amp-—-按位于" class="headerlink" title="&amp; — 按位于"></a>&amp; — 按位于</h5>
      <p>&amp;&amp;逻辑与也叫并且</p>
<p>&amp;&amp;与&amp;的含义完全不同</p>
<p>1&amp;1 &#x3D; 1</p>
<p>1&amp;0 &#x3D; 0</p>
<p>0&amp;1 &#x3D; 0</p>
<p>0&amp;0 &#x3D; 0	</p>
<p>5&amp;7&#x3D;5 21&amp;7&#x3D;5</p>
<p>5&amp;1&#x3D;1 5&amp;10&#x3D;0</p>

        <h5 id="I-–-按位或"   >
          <a href="#I-–-按位或" class="heading-link"><i class="fas fa-link"></i></a><a href="#I-–-按位或" class="headerlink" title="I – 按位或"></a>I – 按位或</h5>
      <p>II逻辑或 </p>
<p>I按位或</p>
<p>1|0 &#x3D; 1</p>
<p>111 &#x3D; 1</p>
<p>0|1 &#x3D; 1 </p>
<p>0|0 &#x3D; 0</p>

        <h5 id="–-按位取反"   >
          <a href="#–-按位取反" class="heading-link"><i class="fas fa-link"></i></a><a href="#–-按位取反" class="headerlink" title="~ – 按位取反"></a>~ – 按位取反</h5>
      <p>~i 就是把 i 变量所有的二进制位取反</p>

        <h5 id="—-按位异或"   >
          <a href="#—-按位异或" class="heading-link"><i class="fas fa-link"></i></a><a href="#—-按位异或" class="headerlink" title="^ — 按位异或"></a>^ — 按位异或</h5>
      <p>相同为零 </p>
<p>不同为1 </p>
<p>1^0 &#x3D; 1 </p>
<p>0^1 &#x3D; 1 </p>
<p>1^1 &#x3D; 0</p>
<p>0^0 &#x3D; 0</p>

        <h5 id="«-–按位左移"   >
          <a href="#«-–按位左移" class="heading-link"><i class="fas fa-link"></i></a><a href="#«-–按位左移" class="headerlink" title="« –按位左移"></a>« –按位左移</h5>
      <p>i«3表示把 i 的所有二进制位左移3位，右边补零 </p>
<p>左移n位相当于乘以2的n次方,前提是数据不能丢失</p>
<p>面试题：</p>
<p>A) i &#x3D; i*8;</p>
<p>B) i &#x3D; i«3;</p>
<p>请问上述两个语句，哪个语句执行的速度快 答案：B快</p>
<p>&gt;&gt; –按位右移</p>
<p>i»3表示把i的所有二进制位右移3位，左边一般是0,当然也可能补1 右移n位相当于除以2的n次方，前提是数据不能丢失</p>
<p>面试题：</p>
<p>A) i &#x3D; i&#x2F;8;</p>
<p>B) i &#x3D; i»3;</p>
<p>请问上述两个语句，哪个语句执行的速度快 答案：B快</p>
<p>位运算的现实意义</p>
<p>通过位运算符我们可以对数据的操作精确到每一位</p>
<p>复习进制的知识：</p>
<ol>
<li><p>什么叫n进制</p>
</li>
<li><p>把r进制转成十进制</p>
</li>
<li><p>十进制转成r进制</p>
</li>
<li><p>不同进制所代表的数值之间的关系<br>十进制的3981转化化成十六进制是F8D<br>十进制的3981和十六进制的F8D所代表的本质上都是同一个数字</p>
</li>
</ol>

        <h5 id="二进制全部为零的含义—0000000000000的含义"   >
          <a href="#二进制全部为零的含义—0000000000000的含义" class="heading-link"><i class="fas fa-link"></i></a><a href="#二进制全部为零的含义—0000000000000的含义" class="headerlink" title="二进制全部为零的含义—0000000000000的含义"></a>二进制全部为零的含义—0000000000000的含义</h5>
      <ol>
<li><p>数值零</p>
</li>
<li><p>字符串结束标记符’\0’</p>
</li>
<li><p>空指针NULL<br>NULL本质也是零，而这个零不代表数字零，而表示的是内存单元的编号零</p>
</li>
</ol>
<p>我们计算机规定了，以零为编号的存储单元的内容不可读，不可写</p>

        <h2 id="The-end"   >
          <a href="#The-end" class="heading-link"><i class="fas fa-link"></i></a><a href="#The-end" class="headerlink" title="The end"></a>The end</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Git用法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Git"   >
          <a href="#Git" class="heading-link"><i class="fas fa-link"></i></a><a href="#Git" class="headerlink" title="Git"></a>Git</h1>
      
        <h2 id="1-git概述"   >
          <a href="#1-git概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-git概述" class="headerlink" title="1 git概述"></a>1 git概述</h2>
      <p>Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。</p>
<p>Git 易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。</p>

        <h3 id="1-1-版本控制"   >
          <a href="#1-1-版本控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-版本控制" class="headerlink" title="1.1 版本控制"></a>1.1 版本控制</h3>
      <p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211113951355.png" alt="image-20230211113951355"></p>

        <h3 id="1-2-为什么需要版本控制"   >
          <a href="#1-2-为什么需要版本控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-为什么需要版本控制" class="headerlink" title="1.2  为什么需要版本控制"></a>1.2  为什么需要版本控制</h3>
      <p>个人开发过渡到团队协作。</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211134930811.png" alt="image-20230211134930811"></p>

        <h3 id="1-3-版本控制工具"   >
          <a href="#1-3-版本控制工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-版本控制工具" class="headerlink" title="1.3  版本控制工具"></a>1.3  版本控制工具</h3>
      
        <h4 id="集中式版本控制工具"   >
          <a href="#集中式版本控制工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#集中式版本控制工具" class="headerlink" title="集中式版本控制工具"></a>集中式版本控制工具</h4>
      <p>CVS、<strong>SVN</strong>、VSS…</p>
<p>集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p>
<p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211135145234.png" alt="image-20230211135145234"></p>

        <h4 id="分布式版本控制工具"   >
          <a href="#分布式版本控制工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#分布式版本控制工具" class="headerlink" title="分布式版本控制工具"></a>分布式版本控制工具</h4>
      <p>Git、Mercurial、Bazaar、Darcs……</p>
<p>像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p>
<p>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:</p>
<ol>
<li><p>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</p>
</li>
<li><p>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</p>
</li>
</ol>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211135307551.png" alt="image-20230211135307551"></p>

        <h3 id="1-4-Git简史"   >
          <a href="#1-4-Git简史" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-Git简史" class="headerlink" title="1.4   Git简史"></a>1.4   Git简史</h3>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211135346403.png" alt="image-20230211135346403"></p>

        <h3 id="1-5-Git工作机制"   >
          <a href="#1-5-Git工作机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-Git工作机制" class="headerlink" title="1.5  Git工作机制"></a>1.5  Git工作机制</h3>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211135414107.png" alt="image-20230211135414107"></p>

        <h3 id="1-6-Git-和代码托管中心"   >
          <a href="#1-6-Git-和代码托管中心" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-6-Git-和代码托管中心" class="headerlink" title="1.6  Git 和代码托管中心"></a>1.6  Git 和代码托管中心</h3>
      <p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p>

        <h4 id="局域网（自己公司内部）"   >
          <a href="#局域网（自己公司内部）" class="heading-link"><i class="fas fa-link"></i></a><a href="#局域网（自己公司内部）" class="headerlink" title="局域网（自己公司内部）"></a>局域网（自己公司内部）</h4>
      <p>GitLab</p>

        <h4 id="互联网"   >
          <a href="#互联网" class="heading-link"><i class="fas fa-link"></i></a><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h4>
      <p>GitHub</p>
<p>Gitee码云</p>

        <h2 id="2-git的安装"   >
          <a href="#2-git的安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-git的安装" class="headerlink" title="2  git的安装"></a>2  git的安装</h2>
      <p>链接：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qv0vQB9H_WJeStd4XRVs_Q" >https://pan.baidu.com/s/1qv0vQB9H_WJeStd4XRVs_Q</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 	提取码：3o5x </p>
<p>安装到英文无空格的路径中，全部默认勾选安装。</p>

        <h2 id="3-Git常用命令"   >
          <a href="#3-Git常用命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Git常用命令" class="headerlink" title="3  Git常用命令"></a>3  Git常用命令</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git config –global user.name 用户名</td>
<td>设置用户标签</td>
</tr>
<tr>
<td>git config –global user.email 邮箱</td>
<td>设置用户签名</td>
</tr>
<tr>
<td><strong>git init</strong></td>
<td><strong>初始化本地库</strong></td>
</tr>
<tr>
<td><strong>git status</strong></td>
<td><strong>查看本地库状态</strong></td>
</tr>
<tr>
<td><strong>git add 文件名</strong></td>
<td><strong>添加文件到暂存区</strong></td>
</tr>
<tr>
<td><strong>git commit -m “日志信息” 文件名</strong></td>
<td><strong>提交到本地库</strong></td>
</tr>
<tr>
<td><strong>git reflog</strong></td>
<td><strong>查看历史记录</strong></td>
</tr>
<tr>
<td><strong>git reset –hard 版本号</strong></td>
<td><strong>版本穿梭</strong></td>
</tr>
</tbody></table></div>
<p>Git 切换版本，底层其实是移动的 HEAD 指针，具体原理如下图所示</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211154745719.png" alt="image-20230211154745719"></p>

        <h3 id="Vim的基本使用"   >
          <a href="#Vim的基本使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vim的基本使用" class="headerlink" title="Vim的基本使用"></a>Vim的基本使用</h3>
      
        <h4 id="一、vim-未找到命令"   >
          <a href="#一、vim-未找到命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、vim-未找到命令" class="headerlink" title="一、vim: 未找到命令"></a>一、vim: 未找到命令</h4>
      <p>这里使用的是centos的系统，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AE%89%E8%A3%85vim&spm=1001.2101.3001.7020" >安装vim</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：<code>yum -y install vim*</code></p>

        <h4 id="二、vim编辑器的三种模式"   >
          <a href="#二、vim编辑器的三种模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、vim编辑器的三种模式" class="headerlink" title="二、vim编辑器的三种模式"></a>二、vim编辑器的三种模式</h4>
      <ol>
<li>命令行模式：使用Esc退到命令行模式，vim编辑一个文件进去默认是命令行模式</li>
<li>编辑模式：该命令可以对文件内容进行编辑</li>
<li>末行模式：输入<code>:</code>进入末行模式</li>
</ol>

        <h4 id="三、末行模式下：文件的新建保存和退出"   >
          <a href="#三、末行模式下：文件的新建保存和退出" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、末行模式下：文件的新建保存和退出" class="headerlink" title="三、末行模式下：文件的新建保存和退出"></a>三、末行模式下：文件的新建保存和退出</h4>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果存在直接打开，不存在就新建一个文件</span></span><br><span class="line">vim hello.txt</span><br><span class="line"><span class="comment"># 编辑完成之后Esc退回末行模式使用（请输入   ：  ）</span></span><br><span class="line">:w <span class="comment"># 写入保存</span></span><br><span class="line">:q <span class="comment"># 不保存退出,看了看文件觉得没用并退出</span></span><br><span class="line">:q! <span class="comment"># 不保存强制退出，用于在编辑了文本之后不保存</span></span><br><span class="line">:wq <span class="comment"># 保存并退出（常用）</span></span><br><span class="line">:/str <span class="comment"># 查找字符：在这个文件内容中搜索str 按回车就会定位到该目标</span></span><br><span class="line">:%s/旧字符/新字符/g <span class="comment"># 替换字符：g代表global全局替换</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="四、命令行模式下"   >
          <a href="#四、命令行模式下" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、命令行模式下" class="headerlink" title="四、命令行模式下"></a>四、命令行模式下</h4>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vim hello.txt</span><br><span class="line"><span class="comment"># 进入一个文件之后</span></span><br><span class="line">i <span class="comment"># 在字符的左边插入</span></span><br><span class="line">a <span class="comment"># 在字符的右边插入</span></span><br><span class="line">I <span class="comment"># 该行最前面插入</span></span><br><span class="line">A <span class="comment"># 该行最后面插入</span></span><br><span class="line">hjkl <span class="comment"># 左下上右移动光标</span></span><br><span class="line">gg <span class="comment"># 定位到首行</span></span><br><span class="line">G <span class="comment"># 到最后一行</span></span><br><span class="line">yy <span class="comment"># 复制整行：光标所在当前行 不提示</span></span><br><span class="line">yw <span class="comment"># 复制单词：光标所在的单词</span></span><br><span class="line">p <span class="comment"># 粘贴 前面加数字n可以一次粘贴n次；</span></span><br><span class="line"><span class="built_in">dd</span> <span class="comment"># 删除光标所在行的内容</span></span><br><span class="line">. <span class="comment"># 重复上一次操作</span></span><br><span class="line">u <span class="comment"># 撤回操作</span></span><br><span class="line">ctrl + r <span class="comment"># 返回上一次操作</span></span><br><span class="line">d <span class="comment"># 删除字符</span></span><br><span class="line"></span><br><span class="line">1.如果是更改字符</span><br><span class="line">dw <span class="comment"># 删除光标所在字符 但要重新进入编辑模式</span></span><br><span class="line">cw <span class="comment"># 更改光标所在字符（推荐）</span></span><br><span class="line">w <span class="comment"># 跳到下一个单词的首部</span></span><br><span class="line">e <span class="comment"># 跳到下一个单词的尾部</span></span><br><span class="line">b <span class="comment"># 跳过头了 跳回上一个单词</span></span><br><span class="line"></span><br><span class="line">2.一次性删除&#123;&#125;[]() 的内容</span><br><span class="line">光标移动到&#123;里的第一个字符输入</span><br><span class="line">ci&#123; <span class="comment"># 删除括号里面的所有内容</span></span><br><span class="line"></span><br><span class="line">3.可视化</span><br><span class="line">ctrl + v <span class="comment"># 选中字符</span></span><br></pre></td></tr></table></div></figure>


        <h2 id="4-Git分支操作"   >
          <a href="#4-Git分支操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Git分支操作" class="headerlink" title="4  Git分支操作"></a>4  Git分支操作</h2>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211154856682.png"></p>

        <h3 id="4-1-什么是分支"   >
          <a href="#4-1-什么是分支" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-什么是分支" class="headerlink" title="4.1  什么是分支"></a>4.1  什么是分支</h3>
      <p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211155147169.png" alt="image-20230211155147169"></p>

        <h3 id="4-2-分支的好处"   >
          <a href="#4-2-分支的好处" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-分支的好处" class="headerlink" title="4.2  分支的好处"></a>4.2  分支的好处</h3>
      <p>同时并行推进多个功能开发，提高开发效率。</p>
<p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p>

        <h3 id="4-3-分支的操作"   >
          <a href="#4-3-分支的操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-3-分支的操作" class="headerlink" title="4.3  分支的操作"></a>4.3  分支的操作</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>命令作用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table></div>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master)</span><br><span class="line">$ git branch hot-fix</span><br><span class="line">Layne@LAPTOP-Layne MINGW64 /d/Git-Space/SH0720 (master)</span><br><span class="line">$ git branch -v</span><br><span class="line">hot-fix 087a1a7 my third commit （刚创建的新的分支，并将主分支 master的内容复制了一份）</span><br><span class="line">* master 087a1a7 my third commit</span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211163253766.png" alt="image-20230211163253766"></p>
<p><img src="C:\Users\张智超\Desktop\image-20230211164350473.png" alt="image-20230211164350473"></p>

        <h4 id="4-4-创建分支和切换分支图解"   >
          <a href="#4-4-创建分支和切换分支图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-4-创建分支和切换分支图解" class="headerlink" title="4.4  创建分支和切换分支图解"></a>4.4  创建分支和切换分支图解</h4>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230211165142386.png" alt="image-20230211165142386"></p>
<p>master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD决定的。所以创建分支的本质就是多创建一个指针。</p>
<p>HEAD 如果指向 master，那么我们现在就在 master 分支上。</p>
<p>HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。</p>
<p>所以切换分支的本质就是移动 HEAD 指针。</p>

        <h2 id="5-Git团队协作机制"   >
          <a href="#5-Git团队协作机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Git团队协作机制" class="headerlink" title="5  Git团队协作机制"></a>5  Git团队协作机制</h2>
      
        <h3 id="5-1-团队内协作"   >
          <a href="#5-1-团队内协作" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-1-团队内协作" class="headerlink" title="5.1  团队内协作"></a>5.1  团队内协作</h3>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230212114112925.png" alt="image-20230212114112925"></p>

        <h3 id="5-2-跨团队合作"   >
          <a href="#5-2-跨团队合作" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-跨团队合作" class="headerlink" title="5.2  跨团队合作"></a>5.2  跨团队合作</h3>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230212114151422.png" alt="image-20230212114151422"></p>

        <h2 id="6-GitHub操作"   >
          <a href="#6-GitHub操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-GitHub操作" class="headerlink" title="6  GitHub操作"></a>6  GitHub操作</h2>
      <p>GitHub 网址：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/" >https://github.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="6-1-创建远程仓库"   >
          <a href="#6-1-创建远程仓库" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1-创建远程仓库" class="headerlink" title="6.1  创建远程仓库"></a>6.1  创建远程仓库</h3>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230212114255166.png" alt="image-20230212114255166"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230212114948014.png" alt="image-20230212114948014"></p>
<p>仓库名通常与本地文件夹名字相同。</p>

        <h3 id="6-2-远程仓库操作"   >
          <a href="#6-2-远程仓库操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-远程仓库操作" class="headerlink" title="6.2  远程仓库操作"></a>6.2  远程仓库操作</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td><strong>git push 别名 分支</strong></td>
<td><strong>推送本地分支上的内容到远程仓库</strong></td>
</tr>
<tr>
<td><strong>git clone 远程地址</strong></td>
<td><strong>将远程仓库的内容克隆到本地</strong></td>
</tr>
<tr>
<td><strong>git pull 远程库地址别名 远程分支名</strong></td>
<td><strong>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</strong></td>
</tr>
</tbody></table></div>

        <h2 id="hexo-常用命令"   >
          <a href="#hexo-常用命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>hexo clean</td>
<td>清除本地</td>
</tr>
<tr>
<td>hexo g</td>
<td>生成文件</td>
</tr>
<tr>
<td>hexo s</td>
<td>测试</td>
</tr>
<tr>
<td>hexo d</td>
<td>推到远端</td>
</tr>
</tbody></table></div>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20230212153322798.png" alt="image-20230212153322798"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">郝斌——数据结构</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="数据结构概述"   >
          <a href="#数据结构概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h1>
      
        <h2 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h2>
      <p>我们如何把现实中大量而复杂的问题以特定的数据类型（个体）和特定的存储结构（个体关系）保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行的相应操作，这个操作也叫算法。</p>
<p><b>数据结构 &#x3D; 个体 + 个体关系</b><br>        <b>算法 &#x3D; 对存储数据的操作</b></p>

        <h2 id="数据结构"   >
          <a href="#数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2>
      <ol>
<li>线性结构</li>
</ol>
<p><em>特点</em>：除第一个元素只有一个“后继”和最后一个元素只有一个“前驱”，其它每个元素只有一个“前驱”元素和一个“后继”元素。</p>
<p><em>常见的线性结构</em>有: 数组、链表、栈以及队列。****<em>注意</em>：栈和队列本身不是一种数据结构，可通过数组或链表实现。</p>
<p>1.1 线性结构又分为顺序存储和链式存储</p>
<p>线性结构又分为顺序存储和链式存储，顺序存储：****<em>各个元素存储的地址空间连续，逻辑相邻的元素在物理内存中也相邻，如数组；</em></p>
<p>链式存储****<em>：各个元素存储在任意的地址空间，逻辑相邻的元素在物理内存中没有联系，如链表。</em></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/wps1.jpg" alt="img"> </p>
<p>1.2 顺序存储和链式存储的区别</p>
<p>1.2.1 顺序存储</p>
<p><em>优点</em>：① 因为各个元素是<em><em><strong><em>连续储存</em>，而且当元素类型一致时</strong></em>*</em>占用空间大小一致<em>，所以可以直接通过首元素地址计算某个元素的内存地址，从而*****访问特定元素</em>效率很高</p>
<p>② 对于<em><em><strong><em>有序数组</em>，还可以通过二分查找提高</strong></em>*</em>元素查找*的速度</p>
<p><em>缺点</em>：① 由于顺序存储的特点，所以在删除或插入元素后需要移动其它元素使得整体的存储空间依然是连续的，所以****<em>删除、插入元素效率低，如下图</em>。</p>
<p>② 由于元素存储空间连续，所以当有大数据时，****<em>较难分配一块连续的大内存空间</em>。</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/wps2.jpg" alt="img"> </p>
<p>1.2.2 链式存储</p>
<p>优点：① 由于链式存储的特点，删除或插入节点很方便，不需要移动其它元素，改变元素“连接”关系即可，所以删除、插入元素效率高，如下图。</p>
<p>缺点：① 因为存储的任意性，只能通过前一个元素访问下一个元素，每一次访问元素都从头节点开始遍历，所以****<em>访问特定元素或查找元素效率低</em>。</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/wps3.jpg" alt="img"> </p>
<p>非线性结构</p>
<p>特点：每个元素可以和多个元素“连接”。</p>
<p><em>常见的非线性结构</em>：二维数组、树和图。</p>

        <h3 id="逻辑结构"   >
          <a href="#逻辑结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3>
      
        <h4 id="线性结构"   >
          <a href="#线性结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4>
      <p>数组</p>
<p>链表</p>
<p>栈和队列是一种特殊的线性结构</p>

        <h4 id="非线性结构"   >
          <a href="#非线性结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4>
      <p>树</p>
<p>图</p>

        <h3 id="物理结构"   >
          <a href="#物理结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3>
      
        <h3 id="算法"   >
          <a href="#算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法" class="headerlink" title="算法"></a>算法</h3>
      <p>解题的方法和步骤</p>
<p>衡量算法的标准</p>
<ol>
<li>时间复杂度<br>大概程序要执行的次数，而非执行的时间</li>
<li>空间复杂度<br>算法执行过程中大概所占用的最大内存</li>
<li>难易程度</li>
<li>健壮性</li>
</ol>

        <h3 id="数据结构的地位"   >
          <a href="#数据结构的地位" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据结构的地位" class="headerlink" title="数据结构的地位"></a>数据结构的地位</h3>
      <p>数据结构是软件中最核心的课程</p>
<p>程序 &#x3D; 数据的存储 + 数据的操作 + 可以被计算机执行的语言</p>

        <h1 id="预备知识"   >
          <a href="#预备知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1>
      
        <h2 id="指针"   >
          <a href="#指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针" class="headerlink" title="指针"></a>指针</h2>
      
        <h3 id="指针的重要性"   >
          <a href="#指针的重要性" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针的重要性" class="headerlink" title="指针的重要性"></a>指针的重要性</h3>
      <p>指针是c语言的灵魂</p>

        <h3 id="定义-1"   >
          <a href="#定义-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3>
      
        <h4 id="地址"   >
          <a href="#地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#地址" class="headerlink" title="地址"></a>地址</h4>
      <p>内存单元的编号</p>
<p>从0开始的非负整数</p>
<p>范围：0 – FFFFFFFF【0 – 4G-1】</p>

        <h4 id="指针-1"   >
          <a href="#指针-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针-1" class="headerlink" title="指针"></a>指针</h4>
      <p>指针就是地址 地址就是指针</p>
<p>指针变量是存放内存单元地址的变量</p>
<p>指针的本质是一个操作受限的非负整数【只能在某种情况下相减】</p>

        <h3 id="分类"   >
          <a href="#分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类" class="headerlink" title="分类"></a>分类</h3>
      
        <h4 id="基本类型指针"   >
          <a href="#基本类型指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本类型指针" class="headerlink" title="基本类型指针"></a>基本类型指针</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> * p;<span class="comment">//p是一个变量名，int *表示该p变量只能存储int类型变量的地址</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">    </span><br><span class="line">    p = &amp;i;</span><br><span class="line">    <span class="comment">//p = 10;//error</span></span><br><span class="line">    j = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d,j = %d,*p = %d\n&quot;</span>,i,j,*p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="指针和数组的关系"   >
          <a href="#指针和数组的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和数组的关系" class="headerlink" title="指针和数组的关系"></a>指针和数组的关系</h4>
      
        <h5 id="指针和一维数组"   >
          <a href="#指针和一维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h5>
      
        <h6 id="数组名"   >
          <a href="#数组名" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h6>
      <p>一维数组名是个指针常量</p>
<p>它存放的是一维数组第一个元素的地址</p>
<p>它的值不能改变</p>
<p>一维数组名指向的是数组的第一个元素</p>

        <h6 id="下标的指针的关系"   >
          <a href="#下标的指针的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#下标的指针的关系" class="headerlink" title="下标的指针的关系"></a>下标的指针的关系</h6>
      <p>a[i] &lt;&lt;&#x3D;&#x3D;&gt;&gt; *(a+1)</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	数组名a是一个指针常量</span></span><br><span class="line"><span class="comment">	a保存的是第一元素的地址</span></span><br><span class="line"><span class="comment">	*a就是第一个元素</span></span><br><span class="line"><span class="comment">	故 *(a+i)就是第i+1个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    a[<span class="number">3</span>] == *(a+<span class="number">3</span>);</span><br><span class="line">    <span class="number">3</span>[a] == *(<span class="number">3</span>+a);<span class="comment">//把方括号理解为一种运算符 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>假设指针变量的名字是p</p>
<p>则p+i的值是第i+1个元素的值</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a+<span class="number">3</span>);<span class="comment">//*a+3等价于a[0]+3</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">000000000062FE04</span></span><br><span class="line"><span class="comment">000000000062FE08</span></span><br><span class="line"><span class="comment">000000000062FE0C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>p + i的值是 p + i * (p所指向的变量所占的字节数)</p>

        <h4 id="结构体"   >
          <a href="#结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4>
      
        <h5 id="为什么需要结构体"   >
          <a href="#为什么需要结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么需要结构体" class="headerlink" title="为什么需要结构体"></a>为什么需要结构体</h5>
      <p>为了表示一些复杂的数据，而普通的基本变量无法满足要求。</p>

        <h5 id="什么叫结构体"   >
          <a href="#什么叫结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么叫结构体" class="headerlink" title="什么叫结构体"></a>什么叫结构体</h5>
      <p>结构体是用户根据实际需要自己定义的复合数据类型</p>

        <h5 id="如何使用结构体"   >
          <a href="#如何使用结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用结构体" class="headerlink" title="如何使用结构体"></a>如何使用结构体</h5>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">两种方式</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span> &#123;<span class="number">1000</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span> =</span> &amp;st;</span><br><span class="line"><span class="number">1.</span></span><br><span class="line">    st,sid;</span><br><span class="line"><span class="number">2.</span></span><br><span class="line">    pst-&gt;sid;</span><br><span class="line">	pst 所指向的结构体变量中的sid这个变量</span><br></pre></td></tr></table></div></figure>


        <h5 id="注意事项"   >
          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5>
      <p>结构体变量不能加减乘除，但可以相互赋值</p>
<p>普通结构体变量和结构体指针变量作为函数传参的问题</p>
<p>​		传给结构体变量的首地址即可</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="keyword">struct</span> Student st)</span>;<span class="comment">//占据内存 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">g2</span><span class="params">(<span class="keyword">struct</span> Student * st1)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>		//定义了一个数据类型 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> sid;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line">	</span><br><span class="line">	f(&amp;st);</span><br><span class="line">	g(st);</span><br><span class="line"><span class="comment">//	printf(&quot;%d %s %d\n&quot;,st.age,st.name,st.sid);</span></span><br><span class="line">	g2(&amp;st);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span></span><br><span class="line">&#123;</span><br><span class="line">	pst-&gt;sid = <span class="number">4000</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(pst-&gt;name,<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">	pst-&gt;age = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="keyword">struct</span> Student st)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %s %d\n&quot;</span>,st.age,st.name,st.sid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g2</span><span class="params">(<span class="keyword">struct</span> Student * st1)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %s %d\n&quot;</span>,st1-&gt;age,st1-&gt;name,st1-&gt;sid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="动态内存的分配和释放"   >
          <a href="#动态内存的分配和释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态内存的分配和释放" class="headerlink" title="动态内存的分配和释放"></a>动态内存的分配和释放</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="type">int</span> len,i;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> * pArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*len);<span class="comment">//动态分配完内存单元后，强制转换为int *类型，也就是将内存区块化，4个4个分好</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	pArr[1] = 10;</span></span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,*(pArr +1)); </span></span><br><span class="line">    </span><br><span class="line">    *pArr = <span class="number">10</span>;			<span class="comment">//类似于a[0] = 10; </span></span><br><span class="line">	*(pArr+<span class="number">3</span>) = <span class="number">23</span>;		<span class="comment">//如果p是个指针变量，则 p[i] 永远等价于 *(p+i), 类似于a[3] = 23;</span></span><br><span class="line">	pArr[<span class="number">2</span>] = <span class="number">21</span>;		<span class="comment">//类似于a[2] = 21;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,pArr[<span class="number">0</span>],pArr[<span class="number">3</span>],pArr[<span class="number">2</span>]); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们可以吧pArr当做普通数组来使用</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pArr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(pArr+i));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="built_in">free</span>(pArr);			<span class="comment">//把pArr所代表的动态分配的内存释放 </span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> sid;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student *<span class="title function_">CreateStudent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStudent</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">st</span>;</span></span><br><span class="line">	</span><br><span class="line">	st = CreateStudent();</span><br><span class="line">	ShowStudent(st);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student *<span class="title function_">CreateStudent</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">p</span> =</span> (<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">	p-&gt;sid = <span class="number">88</span>;</span><br><span class="line">	p-&gt;age = <span class="number">66</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStudent</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,pst-&gt;sid,pst-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="模块一：线性结构【把所有的结点用一根直线穿起来】"   >
          <a href="#模块一：线性结构【把所有的结点用一根直线穿起来】" class="heading-link"><i class="fas fa-link"></i></a><a href="#模块一：线性结构【把所有的结点用一根直线穿起来】" class="headerlink" title="模块一：线性结构【把所有的结点用一根直线穿起来】"></a>模块一：线性结构【把所有的结点用一根直线穿起来】</h1>
      
        <h2 id="连续存储【数组】"   >
          <a href="#连续存储【数组】" class="heading-link"><i class="fas fa-link"></i></a><a href="#连续存储【数组】" class="headerlink" title="连续存储【数组】"></a>连续存储【数组】</h2>
      <p>什么叫数组</p>
<p>元素类型相同，大小相等</p>
<p>数组的优缺点</p>
<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202210011732466.png" alt="image-20221001173136793" style="zoom:50%;" />


        <h2 id="离散存储【链表】"   >
          <a href="#离散存储【链表】" class="heading-link"><i class="fas fa-link"></i></a><a href="#离散存储【链表】" class="headerlink" title="离散存储【链表】"></a>离散存储【链表】</h2>
      
        <h3 id="定义-2"   >
          <a href="#定义-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3>
      <ol>
<li>n个节点离散分配</li>
<li>彼此通过指针相连</li>
<li>每个节点只有一个前驱节点，每个节点只有一个后继节点</li>
<li>首节点没有前驱结点，尾结点没有后继节点</li>
</ol>

        <h4 id="专业术语"   >
          <a href="#专业术语" class="heading-link"><i class="fas fa-link"></i></a><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h4>
      <p>首节点：第一个有效节点</p>
<p>尾节点：最后一个有效节点</p>
<p>头结点：<strong>第一个有效节点之前的那个节点，头结点并不存放有效数据，加头结点的目的主要是为了方便对链表的操作</strong></p>
<p>头指针：指向头结点的指针变量</p>
<p>尾指针：指向尾结点的指针变量</p>
<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202210020914556.png" alt="image-20221002091447336" style="zoom: 50%;" />


        <h4 id="如果希望通过一个函数来对链表进行处理，我们至少需要接收链表的哪些参数"   >
          <a href="#如果希望通过一个函数来对链表进行处理，我们至少需要接收链表的哪些参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#如果希望通过一个函数来对链表进行处理，我们至少需要接收链表的哪些参数" class="headerlink" title="如果希望通过一个函数来对链表进行处理，我们至少需要接收链表的哪些参数"></a><b>如果希望通过一个函数来对链表进行处理，我们至少需要接收链表的哪些参数</b></h4>
      <p>只需要一个参数：头指针</p>
<p>因为我们通过头指针可以推算出链表的其他所有参数</p>
<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202210020829022.png" alt="image-20221002082930861" style="zoom:50%;" />


        <h3 id="分类-1"   >
          <a href="#分类-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3>
      <p>泛型：利用某种技术达到的效果就是：不同的存储方式，执行的操作是一样的。</p>

        <h4 id="单链表"   >
          <a href="#单链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4>
      
        <h4 id="双链表"   >
          <a href="#双链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4>
      <p>每一个节点有两个指针域</p>

        <h4 id="循环链表"   >
          <a href="#循环链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4>
      <p>能通过任何一个节点找到其它所有的节点</p>

        <h4 id="非循环链表"   >
          <a href="#非循环链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#非循环链表" class="headerlink" title="非循环链表"></a>非循环链表</h4>
      
        <h3 id="算法-1"   >
          <a href="#算法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3>
      
        <h4 id="遍历"   >
          <a href="#遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4>
      
        <h4 id="查找"   >
          <a href="#查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#查找" class="headerlink" title="查找"></a>查找</h4>
      
        <h4 id="清空"   >
          <a href="#清空" class="heading-link"><i class="fas fa-link"></i></a><a href="#清空" class="headerlink" title="清空"></a>清空</h4>
      
        <h4 id="销毁"   >
          <a href="#销毁" class="heading-link"><i class="fas fa-link"></i></a><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4>
      
        <h4 id="求长度"   >
          <a href="#求长度" class="heading-link"><i class="fas fa-link"></i></a><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h4>
      
        <h4 id="排序"   >
          <a href="#排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序" class="headerlink" title="排序"></a>排序</h4>
      
        <h4 id="删除节点"   >
          <a href="#删除节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4>
      <p>伪算法分析</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202210021019247.png" alt="image-20221002101936913"></p>

        <h4 id="插入节点"   >
          <a href="#插入节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4>
      <p>伪算法分析<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/202210021013156.png" alt="image-20221002101346681"><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/202210021535197.png" alt="image-20221002153510958"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;NODE, *PNODE; <span class="comment">//NODE等价于struct Node    PNODE等价于struct Node *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line">PNODE <span class="title function_">create_list</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//创建链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(PNODE pHead)</span>;  <span class="comment">//遍历链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(PNODE pHead)</span>;  <span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(PNODE)</span>;  <span class="comment">//求链表长度</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span>;  <span class="comment">//在pHead所指向链表的第pos个节点的前面插入一个新的结点，该节点的值是val， 并且pos的值是从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span>;  <span class="comment">//删除链表第pos个节点，并将删除的结点的值存入pVal所指向的变量中,  并且pos的值是从1开始</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(PNODE)</span>;  <span class="comment">//对链表进行排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	PNODE pHead = <span class="literal">NULL</span>; <span class="comment">//等价于 struct Node * pHead = NULL;</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	pHead = create_list();  <span class="comment">//create_list()功能：创建一个非循环单链表，并将该链表的头结点的地址付给pHead</span></span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//insert_list(pHead, -4, 33);</span></span><br><span class="line">	<span class="keyword">if</span> ( delete_list(pHead, <span class="number">4</span>, &amp;val) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除成功，您删除的元素是: %d\n&quot;</span>, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除失败!您删除的元素不存在!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	traverse_list(pHead);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//int len = length_list(pHead);</span></span><br><span class="line">	<span class="comment">//printf(&quot;链表的长度是%d\n&quot;, len);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort_list(pHead);</span></span><br><span class="line">	<span class="comment">//traverse_list(pHead);</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/*	if ( is_empty(pHead) )</span></span><br><span class="line"><span class="comment">		printf(&quot;链表为空!\n&quot;);</span></span><br><span class="line"><span class="comment">	else</span></span><br><span class="line"><span class="comment">		printf(&quot;链表不空!\n&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">create_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len;  <span class="comment">//用来存放有效节点的个数</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> val; <span class="comment">//用来临时存放用户输入的结点的值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配了一个不存放有效数据的头结点</span></span><br><span class="line">	PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pHead)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;分配失败, 程序终止!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	PNODE pTail = pHead;</span><br><span class="line">	pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入您需要生成的链表节点的个数: len = &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入第%d个节点的值: &quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">		</span><br><span class="line">		PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == pNew)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分配失败, 程序终止!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pNew-&gt;data = val;</span><br><span class="line">		pTail-&gt;pNext = pNew;</span><br><span class="line">		pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">		pTail = pNew;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	PNODE p = pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">NULL</span> != p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pHead-&gt;pNext)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	PNODE p = pHead-&gt;pNext;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">NULL</span> != p)</span><br><span class="line">	&#123;</span><br><span class="line">		++len;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, t;</span><br><span class="line">	<span class="type">int</span> len = length_list(pHead);</span><br><span class="line">	PNODE p, q;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>,p=pHead-&gt;pNext; i&lt;len<span class="number">-1</span>; ++i,p=p-&gt;pNext)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j=i+<span class="number">1</span>,q=p-&gt;pNext; j&lt;len; ++j,q=q-&gt;pNext)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;data &gt; q-&gt;data)  <span class="comment">//类似于数组中的:  a[i] &gt; a[j]</span></span><br><span class="line">			&#123;</span><br><span class="line">				t = p-&gt;data;<span class="comment">//类似于数组中的:  t = a[i];</span></span><br><span class="line">				p-&gt;data = q-&gt;data; <span class="comment">//类似于数组中的:  a[i] = a[j];</span></span><br><span class="line">				q-&gt;data = t; <span class="comment">//类似于数组中的:  a[j] = t;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pHead所指向链表的第pos个节点的前面插入一个新的结点，该节点的值是val， 并且pos的值是从1开始</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	PNODE p = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">NULL</span>!=p &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span>==p)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果程序能执行到这一行说明p已经指向了第pos-1个结点,但第pos-1个节点是否存在无所谓</span></span><br><span class="line">	<span class="comment">//分配新的结点</span></span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pNew)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;动态分配内存失败!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pNew-&gt;data = val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将新的结点存入p节点的后面</span></span><br><span class="line">	PNODE q = p-&gt;pNext;</span><br><span class="line">	p-&gt;pNext = pNew;</span><br><span class="line">	pNew-&gt;pNext = q;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	PNODE p = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">NULL</span>!=p-&gt;pNext &amp;&amp; i&lt;pos<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i&gt;pos<span class="number">-1</span> || <span class="literal">NULL</span>==p-&gt;pNext)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果程序能执行到这一行说明p已经指向了第pos-1个结点，并且第pos个节点是存在的</span></span><br><span class="line">	PNODE q = p-&gt;pNext;  <span class="comment">//q指向待删除的结点</span></span><br><span class="line">	*pVal = q-&gt;data;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除p节点后面的结点</span></span><br><span class="line">	p-&gt;pNext = p-&gt;pNext-&gt;pNext;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//释放q所指向的节点所占的内存</span></span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	q = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="链表的优缺点"   >
          <a href="#链表的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h3>
      
        <h2 id="线性结构的两种常见应用之一-栈"   >
          <a href="#线性结构的两种常见应用之一-栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#线性结构的两种常见应用之一-栈" class="headerlink" title="线性结构的两种常见应用之一 栈"></a>线性结构的两种常见应用之一 栈</h2>
      <p>动态分配的内存在堆中，静态分配的内存在栈中</p>

        <h3 id="定义-3"   >
          <a href="#定义-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3>
      <p>定义：一种可以实现“先进后出”的存储结构。栈类似于纸箱</p>
<p>分类：静态栈（以数组为底层）</p>
<p>​		   动态栈（以链表为底层）</p>
<p>算法：出栈</p>
<p>压栈（进栈）</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/202210042021723.png" alt="image-20221004202118515"></p>
<p>算法：狭义的算法是与数据的存储方式密切相关的</p>
<p>​			广义的算法是与数据的存储方式无关的</p>
<p>泛型：利用某种技术达到的效果是：不同的存储方式，执行的操作是一样的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE,* PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PNODE pTop;</span><br><span class="line">	PNODE pBottom;</span><br><span class="line">&#125;STACK,* PSTACK;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(PSTACK)</span>;<span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PSTACK pS, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushs</span><span class="params">(PSTACK)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(PSTACK)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(PSTACK, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(PSTACK pS)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(PSTACK pS)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	STACK S;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	init(&amp;S);</span><br><span class="line">	pushs(&amp;S);</span><br><span class="line">	traverse(&amp;S);</span><br><span class="line">	<span class="keyword">if</span>(pop(&amp;S,&amp;val))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;出栈成功，出栈的元素为：%d\n\n&quot;</span>,val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈为空！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	traverse(&amp;S);</span><br><span class="line"></span><br><span class="line">	clear(&amp;S);</span><br><span class="line">	traverse(&amp;S);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">	pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pS-&gt;pTop)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;分配失败，退出程序&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pS-&gt;pBottom = pS-&gt;pTop;</span><br><span class="line">		pS-&gt;pTop-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;栈初始化成功！\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多次压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushs</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,y,val;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入您要压栈的次数：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d次压栈的数值为：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line"></span><br><span class="line">		PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"></span><br><span class="line">		pNew-&gt;data = val;</span><br><span class="line">		pNew-&gt;pNext = pS-&gt;pTop;</span><br><span class="line">		pS-&gt;pTop = pNew;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;已经全部压栈成功\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PSTACK pS, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"></span><br><span class="line">	pNew-&gt;data = val;</span><br><span class="line">	pNew-&gt;pNext = pS-&gt;pTop;</span><br><span class="line">	pS-&gt;pTop = pNew;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出与压栈的顺序相反，刚好表明先进后出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (empty(pS))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNODE p = pS-&gt;pTop;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈中元素为：&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (p != pS-&gt;pBottom)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d	&quot;</span>,p-&gt;data);</span><br><span class="line">			p = p-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(pS-&gt;pBottom == pS-&gt;pTop)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(PSTACK pS, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNODE r = pS-&gt;pTop;</span><br><span class="line">		*pVal = r-&gt;data;</span><br><span class="line">		pS-&gt;pTop = r-&gt;pNext;</span><br><span class="line">		<span class="built_in">free</span>(r);</span><br><span class="line">		r = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(empty(pS))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNODE p = pS-&gt;pTop;</span><br><span class="line">		PNODE q = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (p != pS-&gt;pBottom)</span><br><span class="line">		&#123;</span><br><span class="line">			q = p-&gt;pNext;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">			p = q;</span><br><span class="line">		&#125;</span><br><span class="line">		pS-&gt;pTop = pS-&gt;pBottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;已清空栈&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="应用"   >
          <a href="#应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用" class="headerlink" title="应用"></a>应用</h3>
      <p>函数调用</p>
<p>中断</p>
<p>表达式求值</p>
<p>内存分配</p>
<p>缓冲处理</p>
<p>迷宫</p>

        <h2 id="线性结构的两种常见应用之二-队列"   >
          <a href="#线性结构的两种常见应用之二-队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#线性结构的两种常见应用之二-队列" class="headerlink" title="线性结构的两种常见应用之二 队列"></a>线性结构的两种常见应用之二 队列</h2>
      
        <h3 id="定义-4"   >
          <a href="#定义-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3>
      <p>一种可以实现“先进先出”的存储结构</p>
<p>队头（删）：front，队尾（增）：rear</p>

        <h3 id="分类-2"   >
          <a href="#分类-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类-2" class="headerlink" title="分类"></a>分类</h3>
      <p>链式队列 —— 用链表实现</p>
<p>静态队列 —— 用数组实现</p>

        <h4 id="静态队列"   >
          <a href="#静态队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态队列" class="headerlink" title="静态队列"></a>静态队列</h4>
      <p>静态队列通常都必须是循环队列</p>
<p>循环队列的讲解</p>
<ol>
<li><p>静态队列为什么必须是循环队列<br>队头和队尾都只能加，浪费内存，不合理</p>
</li>
<li><p>循环队列需要几个参数来确定<br>两个参数：front，rear</p>
</li>
<li><p>循环队列各个参数的含义</p>
<p>两个参数不同场合有不同的含义<br> 建议初学者先记住，慢慢体会<br> 1、队列初始化<br>       front和rear的值都是0<br>​     2、队列非空 </p>
<p>​         front代表的是队列的第一个元素</p>
<p>​		 rear代表的是队列的最后一个有效元素的下一个元素</p>
<p>​     3、队列空<br>​		   front和rear的值相等，但不一定是零</p>
</li>
<li><p>循环队列入队伪算法讲解<br><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/Snipaste_2022-11-08_20-29-10.png" alt="Snipaste_2022-11-08_20-29-10"></p>
</li>
<li><p>循环队列出队伪算法讲解<br>   front&#x3D; (front+1)%数组的长度</p>
</li>
<li><p>如何判断循环队列是否为空<br>front &#x3D; rear </p>
</li>
<li><p>如何判断循环队列是否已满<br>预备知识：<br>   front的值可能比rant大，也可能比rear小，当然也可能两者相等<br>两种方式：<br>   1、多增加一个标识参数<br>    2、少用一个元素【通常用第二种】<br><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/Snipaste_2022-11-08_21-03-37.png" alt="Snipaste_2022-11-08_21-03-37"></p>
</li>
</ol>

        <h3 id="队列算法"   >
          <a href="#队列算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列算法" class="headerlink" title="队列算法"></a>队列算法</h3>
      <p>入队</p>
<p>出队</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE * pQ)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(QUEUE * pQ)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE * pQ)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ,<span class="type">int</span> * pVal)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    init(&amp;Q);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">1</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">5</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">6</span>);</span><br><span class="line">    en_queue(&amp;Q,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_queue(&amp;Q,&amp;val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功，被删除的元素为：%d\n&quot;</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    pQ-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">6</span>);</span><br><span class="line">    pQ-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((pQ-&gt;rear+<span class="number">1</span>)%<span class="number">6</span> == pQ-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *pQ,<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (full_queue(pQ))</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队已满，无法添加\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear] = val;</span><br><span class="line">        pQ-&gt;rear = (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;添加成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = pQ-&gt;front;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队内元素为：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((i != pQ-&gt;rear))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,pQ-&gt;pBase[i]);</span><br><span class="line">        i = (i+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pQ-&gt;front == pQ-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ,<span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty(pQ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *pVal = pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">        pQ-&gt;front = (pQ-&gt;front+<span class="number">1</span>)%<span class="number">6</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="队列的具体应用"   >
          <a href="#队列的具体应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列的具体应用" class="headerlink" title="队列的具体应用"></a>队列的具体应用</h3>
      <p>所有和时间有关的操作都有队列的影子</p>

        <h2 id="专题：递归"   >
          <a href="#专题：递归" class="heading-link"><i class="fas fa-link"></i></a><a href="#专题：递归" class="headerlink" title="专题：递归"></a>专题：递归</h2>
      
        <h3 id="定义-5"   >
          <a href="#定义-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3>
      <p>一个函数自己直接或者间接调用自己</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221112170158231.png" alt="image-20221112170158231"></p>

        <h3 id="递归满足三个条件"   >
          <a href="#递归满足三个条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归满足三个条件" class="headerlink" title="递归满足三个条件"></a>递归满足三个条件</h3>
      <ol>
<li>递归必须得有一个明确的终止条件</li>
<li>该函数所处理的数据规模必须在递减</li>
<li>这个转化必须是可解的</li>
</ol>

        <h3 id="循环和递归"   >
          <a href="#循环和递归" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环和递归" class="headerlink" title="循环和递归"></a>循环和递归</h3>
      
        <h4 id="递归："   >
          <a href="#递归：" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归：" class="headerlink" title="递归："></a>递归：</h4>
      <p>易于理解</p>
<p>数度慢</p>
<p>存储空间大</p>

        <h4 id="循环"   >
          <a href="#循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环" class="headerlink" title="循环"></a>循环</h4>
      <p>不易理解</p>
<p>速度快</p>
<p>存储空间小</p>

        <h3 id="递归案例"   >
          <a href="#递归案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归案例" class="headerlink" title="递归案例"></a>递归案例</h3>
      <p>1.1+2+3+4+…+100</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,sum(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>2.求阶乘</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假定n的值是1或大于1的值</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> f(n<span class="number">-1</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, f(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>3.汉诺塔</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hannuota</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果是1个盘子</span></span><br><span class="line"><span class="comment">		直接将A柱子上的盘子从A移到C</span></span><br><span class="line"><span class="comment">	否则</span></span><br><span class="line"><span class="comment">		先将A柱子上的n-1个盘子借助C移到B</span></span><br><span class="line"><span class="comment">		直接将A柱子上的第n个盘子从A移到C</span></span><br><span class="line"><span class="comment">		最后将B柱子上的n-1个盘子借助A移到C</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\n&quot;</span>, n, A, C);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		hannuota(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\n&quot;</span>, n, A, C);</span><br><span class="line">		hannuota(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> ch2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> ch3 = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要移动盘子的个数: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">	hannuota(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>4.走迷宫</p>

        <h3 id="递归的应用"   >
          <a href="#递归的应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归的应用" class="headerlink" title="递归的应用"></a>递归的应用</h3>
      <p>树和森林就是以递归的方式定义的</p>
<p>树和图的很多算法都是以递归来实现的</p>
<p>很多数学公式就是以递归的方式定义的</p>
<p>​	斐波拉契序列</p>
<p>​		1 2 3 5 8 13 21 34 55 89 144 233</p>

        <h1 id="模块二：非线性结构"   >
          <a href="#模块二：非线性结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#模块二：非线性结构" class="headerlink" title="模块二：非线性结构"></a>模块二：非线性结构</h1>
      
        <h2 id="树"   >
          <a href="#树" class="heading-link"><i class="fas fa-link"></i></a><a href="#树" class="headerlink" title="树"></a>树</h2>
      
        <h3 id="定义-6"   >
          <a href="#定义-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3>
      <p>专业定义：</p>
<ol>
<li>有且只有一个称为跟的节点</li>
<li>有若干个互不相交的子树，这些子树本身也是一棵树</li>
</ol>
<p>通俗定义</p>
<ol>
<li>树是由节点和边组成</li>
<li>每个节点只有一个父节点但可以有多个子节点</li>
<li>但有一个节点例外，该节点没有父节点，此节点称为跟节点</li>
</ol>

        <h4 id="专业术语-1"   >
          <a href="#专业术语-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#专业术语-1" class="headerlink" title="专业术语"></a>专业术语</h4>
      <p>节点：圈</p>
<p>父节点</p>
<p>子节点</p>
<p>子孙</p>
<p>堂兄弟</p>
<p>深度：从根节点到最底层节点的层数称之为深度，根节点是第一层。</p>
<p>叶子节点：没有子节点的节点</p>
<p>非终端节点：实际上就是非叶子节点</p>
<p>度：子节点的个数称为度（看该节点有几个孩子）</p>
<p>​	树的度：一个树中最大的度</p>

        <h3 id="分类-3"   >
          <a href="#分类-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类-3" class="headerlink" title="分类"></a>分类</h3>
      
        <h4 id="一般树"   >
          <a href="#一般树" class="heading-link"><i class="fas fa-link"></i></a><a href="#一般树" class="headerlink" title="一般树"></a>一般树</h4>
      <p>任意一个节点的子节点的个数都不受限制</p>

        <h4 id="二叉树（有序树）"   >
          <a href="#二叉树（有序树）" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树（有序树）" class="headerlink" title="二叉树（有序树）"></a>二叉树（有序树）</h4>
      <p>任意一个节点的子节点的个数最多两个。且子节点的位置不可更改（左边的叫左子树，右边的叫右子树）</p>

        <h5 id="分类-4"   >
          <a href="#分类-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类-4" class="headerlink" title="分类"></a>分类</h5>
      <p>一般二叉树</p>
<p>满二叉树：在不增加树的层数的前提下，无法再多添加一个节点的二叉树就是满二叉树</p>
<p>完全二叉树：如果只是删除了满二叉树做底层最右边的连续若干个节点，这样形成的二叉树叫完全二叉树。</p>

        <h4 id="森林"   >
          <a href="#森林" class="heading-link"><i class="fas fa-link"></i></a><a href="#森林" class="headerlink" title="森林"></a>森林</h4>
      <p>n个互不相交的树的集合</p>

        <h3 id="树的存储【重点】"   >
          <a href="#树的存储【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#树的存储【重点】" class="headerlink" title="树的存储【重点】"></a>树的存储【重点】</h3>
      
        <h4 id="二叉树的存储【重点】"   >
          <a href="#二叉树的存储【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的存储【重点】" class="headerlink" title="二叉树的存储【重点】"></a>二叉树的存储【重点】</h4>
      
        <h5 id="连续存储-完全二叉树-【重点】"   >
          <a href="#连续存储-完全二叉树-【重点】" class="heading-link"><i class="fas fa-link"></i></a><a href="#连续存储-完全二叉树-【重点】" class="headerlink" title="连续存储 [完全二叉树]【重点】"></a>连续存储 [完全二叉树]【重点】</h5>
      <p>优点：查找某个节点的父节点和子节点（也包括判断有没有子节点）数组很快</p>
<p>缺点：耗用内存过大</p>

        <h5 id="链式存储"   >
          <a href="#链式存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113154137513.png" alt="image-20221113154137513"></h5>
      
        <h4 id="一般树的存储"   >
          <a href="#一般树的存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#一般树的存储" class="headerlink" title="一般树的存储"></a>一般树的存储</h4>
      <p>双亲表示法<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113154700843.png" alt="image-20221113154700843"></p>
<p>孩子表示法</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113154853352.png" alt="image-20221113154853352"></p>
<p>双亲孩子表示法<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113155252090.png" alt="image-20221113155252090"></p>
<p>二叉树表示法【也叫孩子兄弟链表表示法】</p>
<p>先把一般树转化为二叉树，在存储二叉树</p>
<p>一般树转化为二叉树的方法是：</p>
<p>​	设法保证任意一个节点的</p>
<p>​			左指针域指向他的第一个孩子</p>
<p>​			右指针域指向他的下一个兄弟</p>
<p>​		只要满足此条件，就可以把一个普通树转化为二叉树来存储</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113160104677.png" alt="image-20221113160104677"></p>

        <h4 id="森林的存储"   >
          <a href="#森林的存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#森林的存储" class="headerlink" title="森林的存储"></a>森林的存储</h4>
      <p>先把森林转化为二叉树，再存储二叉树</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113161315078.png" alt="image-20221113161315078"></p>

        <h3 id="二叉树操作"   >
          <a href="#二叉树操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树操作" class="headerlink" title="二叉树操作"></a>二叉树操作</h3>
      
        <h4 id="先序遍历-先访问根节点"   >
          <a href="#先序遍历-先访问根节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#先序遍历-先访问根节点" class="headerlink" title="先序遍历[先访问根节点]"></a>先序遍历[先访问根节点]</h4>
      <p>先访问根节点</p>
<p>再先序访问左子树</p>
<p>再先序访问右子树</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113195822507.png" alt="image-20221113195822507"></p>
<p>中：DBAECGF</p>
<p>后：DBEGFCA</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113200009893.png" alt="image-20221113200009893"></p>
<p>先： ABCDEFLQMNS</p>
<p>中：CDFELBAMSNQ</p>
<p>后：FLEDCBSNMQA</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113200449662.png" alt="image-20221113200449662"></p>
<p>先：ABQLCDGEF</p>
<p>中：QBLAGDCEF</p>
<p>后：QLBGDFECA</p>

        <h4 id="中序遍历-中间访问根节点"   >
          <a href="#中序遍历-中间访问根节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#中序遍历-中间访问根节点" class="headerlink" title="中序遍历[中间访问根节点]"></a>中序遍历[中间访问根节点]</h4>
      <p>中序遍历左子树</p>
<p>再访问根节点</p>
<p>再中序遍历右子树</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113201400485.png" alt="image-20221113201400485"></p>
<p>先：ABCDEFLMNQ</p>
<p>中：BDCEALFNQM</p>
<p>后：DECBLQNMFA</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113202316806.png" alt="image-20221113202316806"></p>
<p>先：ABCDEMQLN</p>
<p>中：BDCAMQELN</p>
<p>后：DCBQMNLEA</p>

        <h4 id="后续遍历-最后访问根节点"   >
          <a href="#后续遍历-最后访问根节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#后续遍历-最后访问根节点" class="headerlink" title="后续遍历[最后访问根节点]"></a>后续遍历[最后访问根节点]</h4>
      <p>先中序遍历左子树</p>
<p>再中序遍历右子树</p>
<p>再访问根节点</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113203054980.png" alt="image-20221113203054980"></p>
<p>先：ABCDEFML</p>
<p>中：BADCMFEL</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113203802963.png" alt="image-20221113203802963"></p>
<p>先：MNQSTWLPF</p>
<p>中：NMWTSQLPF</p>
<p>后：NWTSFPLQM</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pLchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pRchild</span>;</span></span><br><span class="line">&#125;BTNODE,* PBTNODE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(PBTNODE pT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(PBTNODE pT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(PBTNODE pT)</span>;</span><br><span class="line">PBTNODE <span class="title function_">CreateBTree</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    PBTNODE pT = CreateBTree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PreTraverseBTree(pT);</span></span><br><span class="line">    <span class="comment">// InTraverseBTree(pT);</span></span><br><span class="line">    PostTraverseBTree(pT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PBTNODE <span class="title function_">CreateBTree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PBTNODE pA = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pB = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pC = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pD = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line">    PBTNODE pE = (PBTNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNODE));</span><br><span class="line"></span><br><span class="line">    pA-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    pB-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    pC-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    pD-&gt;data = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    pE-&gt;data = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    pA-&gt;pLchild = pB;</span><br><span class="line">    pA-&gt;pRchild = pC;</span><br><span class="line">    pB-&gt;pLchild = pB-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pC-&gt;pLchild = pD;</span><br><span class="line">    pC-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pLchild = pE;</span><br><span class="line">    pD-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pE-&gt;pLchild = pE-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != pT)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">		&#123;</span><br><span class="line">			PreTraverseBTree(pT-&gt;pLchild);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">		&#123;</span><br><span class="line">				PreTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">			<span class="comment">//pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	伪算法</span></span><br><span class="line"><span class="comment">	先访问根节点</span></span><br><span class="line"><span class="comment">	再先序访问左子树</span></span><br><span class="line"><span class="comment">	再先序访问右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(PBTNODE pT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != pT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pLchild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,pT-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(PBTNODE pT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != pT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pLchild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,pT-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="已知两种遍历序列求原始二叉树"   >
          <a href="#已知两种遍历序列求原始二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#已知两种遍历序列求原始二叉树" class="headerlink" title="已知两种遍历序列求原始二叉树"></a>已知两种遍历序列求原始二叉树</h3>
      <p>通过先序和中序  或者 中序和后续 我们可以还原出原始的二叉树</p>
<p>但是通过先序和后续是无法还原出原始的二叉树的</p>
<p>换种说法：只有通过先序和中序，或者中序和后续 ，我们才可以唯一的确定一个二叉树 </p>
<p>思路：不断的去根据先序和后续确定每一个根节点，然后根据中序判断左右节点的分布。</p>
<p>先 中：</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113220232753.png" alt="image-20221113220232753"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113221301341.png" alt="image-20221113221301341"></p>
<p>中 后：</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221113222334639.png" alt="image-20221113222334639"></p>
<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221114151150612.png" alt="image-20221114151150612" style="zoom:33%;" />

<p>先：A B C D E F G L H</p>
<p>中：C D B A F L G E H</p>
<p>后：D C B L G F H E A</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221114152944328.png" alt="image-20221114152944328"></p>

        <h2 id="图"   >
          <a href="#图" class="heading-link"><i class="fas fa-link"></i></a><a href="#图" class="headerlink" title="图"></a>图</h2>
      
        <h1 id="模块三：查找和排序"   >
          <a href="#模块三：查找和排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#模块三：查找和排序" class="headerlink" title="模块三：查找和排序"></a>模块三：查找和排序</h1>
      
        <h2 id="折半查找"   >
          <a href="#折半查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2>
      
        <h2 id="排序："   >
          <a href="#排序：" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序：" class="headerlink" title="排序："></a>排序：</h2>
      
        <h3 id="冒泡"   >
          <a href="#冒泡" class="heading-link"><i class="fas fa-link"></i></a><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3>
      
        <h3 id="插入"   >
          <a href="#插入" class="heading-link"><i class="fas fa-link"></i></a><a href="#插入" class="headerlink" title="插入"></a>插入</h3>
      
        <h3 id="选择"   >
          <a href="#选择" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择" class="headerlink" title="选择"></a>选择</h3>
      
        <h3 id="快速排序"   >
          <a href="#快速排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int FindPos(int * a,int low,int high);</span><br><span class="line">void QuickSort(int * a,int low,int high);</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a[6] = &#123;4,7,-2,8,1,5&#125;;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    QuickSort(a,0,5);</span><br><span class="line"></span><br><span class="line">    for(i = 0;i&lt;6;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void QuickSort(int * a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int pos;</span><br><span class="line"></span><br><span class="line">    if(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = FindPos(a,low,high);</span><br><span class="line">        QuickSort(a,low,pos-1);</span><br><span class="line">        QuickSort(a,pos+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindPos(int * a,int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int val = a[low];</span><br><span class="line"></span><br><span class="line">    while (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        while(low &lt; high &amp;&amp; a[high] &gt;= val)</span><br><span class="line">        &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line"></span><br><span class="line">        while(low &lt; high &amp;&amp; a[high] &lt;= val)</span><br><span class="line">        &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a[low] = val; </span><br><span class="line"></span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="归并排序"   >
          <a href="#归并排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3>
      
        <h1 id="Java中容器和数据结构相关知识"   >
          <a href="#Java中容器和数据结构相关知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java中容器和数据结构相关知识" class="headerlink" title="Java中容器和数据结构相关知识"></a>Java中容器和数据结构相关知识</h1>
      
        <h2 id="Iterator接口"   >
          <a href="#Iterator接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2>
      
        <h2 id="Map"   >
          <a href="#Map" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map" class="headerlink" title="Map"></a>Map</h2>
      
        <h3 id="哈希表"   >
          <a href="#哈希表" class="heading-link"><i class="fas fa-link"></i></a><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3>
      <p>如下图所示，给了一个有向图，<code>求邻接矩阵</code><br><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/be74090d0ca0487e9f70e48ea04e11b1.png" alt="在这里插入图片描述"><br>怎么做呢？<br>第一步：和无向图类似，都是先找到你图的所有顶点，<br>画出方形框，如下图所示，图中顶点值为0、1、2、3、4<br><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/a59ca23060eb4e10aae881592fe8493a.png" alt="在这里插入图片描述"></p>
<p>第二步：从顶点0开始寻找与它相邻的点，遇到本身的点直接写0，箭头指向的点<code>写上连接线上的权重</code>，无本身箭头指向的直接写上<code>∞</code><br>如下图所示从0开始，能指向的只有权重3、7的指向箭头</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/cfc49a690afb4d658e1fa3d5b800afa6.png" alt="在这里插入图片描述"><br>最后：根据以上的方法依次写出顶点1 2 3 4的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020" >邻接矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，遇到它本身写0,无法指向的写∞，最后结果如下图所示</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/66ab6427b55445e493c0a04bb3e6e0f0.png" alt="在这里插入图片描述"><br>邻接矩阵画好了，那么邻接表怎么画呢？这个思路和画邻接矩阵差不多，可以对比上一张邻接矩阵的图，就不解释了，如下图所示<br><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/a13051fece014d2781996d3966dbbcf0.png" alt="在这里插入图片描述"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/14/Python/">Python 基础</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Python"   >
          <a href="#Python" class="heading-link"><i class="fas fa-link"></i></a><a href="#Python" class="headerlink" title="Python"></a>Python</h1>
      
        <h2 id="一、Python环境的安装"   >
          <a href="#一、Python环境的安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、Python环境的安装" class="headerlink" title="一、Python环境的安装"></a>一、Python环境的安装</h2>
      <ol>
<li><p>下载Python<br> 访问Python官网: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.python.org/" >https://www.python.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br> 点击downloads按钮，在下拉框中选择系统类型(windows&#x2F;Mac OS&#x2F;Linux等)<br> 选择下载最新版本的Python</p>
<p> <img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228182633493.png" alt="image-20221228182633493"></p>
</li>
<li><p>安装Python<br> 双击下载好的Python安装包<br> 勾选左下角 Add Python 3.7 to PATH 选项，然后选择 Install now 立刻安装Python.<br> 默认安装<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228182704181.png" alt="image-20221228182704181"><br> 自定义安装<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228182713090.png" alt="image-20221228182713090"><br> <img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228182724819.png" alt="image-20221228182724819">安装完成</p>
</li>
<li><p>测试是否安装成功<br> 点击电脑左下角开始按钮，输入 cmd 进入到windows的命令行模式。<br> 在命令行中输入Python,正确显示Python版本，即表示Python安装成功。<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228182800570.png" alt="image-20221228182800570">如果在命令行中输入python出现如下错误<br> <img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228182828355.png" alt="image-20221228182828355"></p>
</li>
<li><p>手动配置Python<br> 注意：如果在安装过程中，已经勾选了 Add Python 3.7 to PATH 选项，并且在 cmd 命令模式下输入 python 指令<br> 不报错，就不需要再手动的配置Python.<br> 右键 此电脑 –&gt; 选择 属性<br> 选择 高级系统设置 –&gt; 环境变量 –&gt;找到并且双击 Path<br> 双击 Path ,在弹框里点击新建，找到Python的安装目录，把路径添加进去<br> 这里新添加的路径 E:\python 是Python安装好以后， Python.exe 这个可执行文件所在的目录。</p>
</li>
</ol>

        <h2 id="二、pip的使用"   >
          <a href="#二、pip的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、pip的使用" class="headerlink" title="二、pip的使用"></a>二、pip的使用</h2>
      <p>pip 是一个现代的，通用的Python包管理工具。提供了对 Python 包的查找、下载、安装、卸载的功能，便于我们对Python的资源包进行管理。</p>
<ol>
<li><p>安装<br>在安装Python时，会自动下载并且安装pip.</p>
</li>
<li><p>配置<br>在windows命令行里，输入 pip -V 可以查看pip的版本。<br>如果在命令行里，运行 pip -V ,出现如下提示:<br>可能是因为在安装python的过程中未勾选 Add Python 3.7 to PATH 选项，需要手动的配置pip的环境变量</p>
<p>​		右键 此电脑 –&gt; 环境变量 –&gt;找到并且双击 Path –&gt;在弹窗里点击新建–&gt;找到pip的安装目录，把路径添加进<br>去。<br>​		这里新添加的路径 E:\python\Scripts 是Python安装好以后， pip.exe 这个可执行文件所在的目录。</p>
</li>
<li><p>使用pip管理Python包<br>pip install &lt;包名&gt; 安装指定的包<br>pip uninstall &lt;包名&gt; 删除指定的包<br>pip list 显示已经安装的包<br>pip freeze 显示已经安装的包，并且以指定的格式显示</p>
</li>
<li><p>修改pip下载源<br>运行pip install 命令会从网站上下载指定的python包，默认是从 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://files.pythonhosted.org/" >https://files.pythonhosted.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 网站上下载。这是个国外的网站，遇到网络情况不好的时候，可能会下载失败，我们可以通过命令，修改pip现在软件时的源。 格式:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名 -i 国内源地址</span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例: pip install ipython -i https://pypi.mirrors.ustc.edu.cn/simple/ 就是从中国科技大学(ustc)的服务器上下载requests(基于python的第三方web框架)</span><br></pre></td></tr></table></div></figure>

<p>国内常用的pip下载源列表:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">豆瓣(douban) http://pypi.douban.com/simple/</span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h2 id="三、运行Python程序"   >
          <a href="#三、运行Python程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、运行Python程序" class="headerlink" title="三、运行Python程序"></a>三、运行Python程序</h2>
      
        <h4 id="1、终端运行"   >
          <a href="#1、终端运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、终端运行" class="headerlink" title="1、终端运行"></a>1、终端运行</h4>
      <ol>
<li><p>直接在python解释器中书写代码<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228183633307.png" alt="image-20221228183633307"><br>退出python环境</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit()</span><br><span class="line">ctrl + z ==&gt;enter</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>使用ipython解释器编写代码<br>使用pip命令，可以快速的安装IPython.</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ipython</span><br></pre></td></tr></table></div></figure>

<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184017013.png" alt="image-20221228184017013"></p>
</li>
</ol>

        <h4 id="2、运行python文件"   >
          <a href="#2、运行python文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、运行python文件" class="headerlink" title="2、运行python文件"></a>2、运行python文件</h4>
      <p>使用python指令运行后缀为.py的python文件</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184059058.png" alt="image-20221228184059058"></p>

        <h4 id="3、Pycharm"   >
          <a href="#3、Pycharm" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、Pycharm" class="headerlink" title="3、Pycharm"></a>3、Pycharm</h4>
      <p>尽管上面介绍的方法已经能够提高我们的编码速度，但是仍然无法应对我们开发中更加复杂的要求。一般情况下，我们都需要借助工具来辅助我们快速的搭建环境，编写代码以及运行程序。</p>
<ul>
<li>IDE的概念<br>IDE(Integrated Development Environment)又被称为集成开发环境。说白了，就是有一款	图形化界面的软件，它集成了编辑代码，编译代码，分析代码，执行代码以及调试代码等	功能。在我们Python开发中，最常用的IDE是Pycharm.</li>
</ul>
<p>pycharm由捷克公司JetBrains开发的一款IDE,提供代码分析、图形化调试器，集成测试器、集成版本控制系统等，主要用来编写Python代码。<br>下载地址:<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.jetbrains.com/pycharm/download" >http://www.jetbrains.com/pycharm/download</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>Pycharm的安装<br>双击安装文件<br>自定义安装路径（可以不用设置）	<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184239791.png" alt="image-20221228184239791"><br>编辑设置（全部选中)<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184248408.png" alt="image-20221228184248408"><br>安装完成后双击<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184254150.png" alt="image-20221228184254150"><br>设置主题<br>启动软件</li>
</ul>

        <h4 id="4、Pycharm的使用介绍"   >
          <a href="#4、Pycharm的使用介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#4、Pycharm的使用介绍" class="headerlink" title="4、Pycharm的使用介绍"></a>4、Pycharm的使用介绍</h4>
      <p>运行Pycharm,选择 Create New Project ,创建一个新的Python工程。<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184844688.png" alt="image-20221228184844688"></p>
<p>选择’Pure Python’创建一个新的纯Python工程项目， Location 表示该项目的保存路径Interpreter 用来指定Python解释器的版本。<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184906031.png" alt="image-20221228184906031"><br>右击项目，选择 New ，再选择 Python File</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184914991.png" alt="image-20221228184914991">在弹出的对话框中输入的文件名 HelloPython ，点击OK，表示创建一个Python程序的文本文件，文本文件后缀名默认.py</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228184927343.png" alt="image-20221228184927343"></p>
<p>在新建的 01_尚硅谷_firstPythonDemo.py 文件里，输入以下代码，并在空白处右键选择 Run 运行，表示输出一段 尚硅谷爬虫 字符串。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;尚硅谷爬虫&#x27;)</span><br></pre></td></tr></table></div></figure>

<p>运行成功后，Pycharm Console窗口将显示我们的输出结果。<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228185011893.png" alt="image-20221228185011893"></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228185031724.png" alt="image-20221228185031724"></p>
<p><strong>文件导航区域</strong>能够 <strong>浏览</strong>／<strong>定位</strong>／ </p>
<p><strong>打开</strong> 项目文件</p>
<p><strong>文件编辑区域</strong> 能够 <strong>编辑</strong> 当前打开的文件</p>
<p><strong>控制台区域</strong> 能够：</p>
<ul>
<li>输出程序执行内容</li>
<li>print(‘尚硅谷爬虫’)跟踪调试代码的执行</li>
</ul>

        <h2 id="四、Python"   >
          <a href="#四、Python" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、Python" class="headerlink" title="四、Python"></a>四、Python</h2>
      
        <h3 id="1-注释"   >
          <a href="#1-注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3>
      
        <h4 id="1-1-注释介绍"   >
          <a href="#1-1-注释介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-注释介绍" class="headerlink" title="1.1 注释介绍"></a><strong>1.1</strong> <strong>注释介绍</strong></h4>
      <p>在我们工作编码的过程中，如果一段代码的逻辑比较复杂，不是特别容易理解，可以适当的添加注释，以辅助自己</p>
<p>或者其他编码人员解读代码。</p>
<p><strong>没注释的代码</strong></p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228185750535.png" alt="image-20221228185750535"></p>
<p><strong>有注释的代码</strong><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228185811180.png" alt="image-20221228185811180"></p>
<p>注意：注释是给程序员看的，为了让程序员方便阅读代码，解释器会忽略注释。使用自己熟悉的语言，适当的对代</p>
<p>码进行注释说明是一种良好的编码习惯。</p>

        <h4 id="1-2-注释的分类"   >
          <a href="#1-2-注释的分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-注释的分类" class="headerlink" title="1.2 注释的分类"></a><strong>1.2</strong> <strong>注释的分类</strong></h4>
      <p>在Python中支持单行注释和多行注释。</p>

        <h5 id="单行注释"   >
          <a href="#单行注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#单行注释" class="headerlink" title="单行注释"></a><strong>单行注释</strong></h5>
      <p>以#开头，#右边的所有东西当做说明，而不是真正要执行的程序，起辅助说明作用</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># #开头右边的都是注释，解析器会忽略注释</span><br><span class="line">print(&#x27;hello world&#x27;) #我的作用是在控制台输出hello world</span><br></pre></td></tr></table></div></figure>


        <h5 id="多行注释"   >
          <a href="#多行注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#多行注释" class="headerlink" title="多行注释"></a><strong>多行注释</strong></h5>
      <p>以 ‘’’ 开始，并以 ‘’’ 结束，我们称之为多行注释。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">_ooOoo_</span></span><br><span class="line"><span class="string">o8888888o</span></span><br><span class="line"><span class="string">88&quot; . &quot;88</span></span><br><span class="line"><span class="string">(| ‐_‐ |)</span></span><br><span class="line"><span class="string">O\ = /O</span></span><br><span class="line"><span class="string">____/`‐‐‐&#x27;\____</span></span><br><span class="line"><span class="string">.&#x27; \\| |// `.</span></span><br><span class="line"><span class="string">/ \\||| : |||// \</span></span><br><span class="line"><span class="string">/ _||||| ‐:‐ |||||‐ \</span></span><br><span class="line"><span class="string">| | \\\ ‐ /// | |</span></span><br><span class="line"><span class="string">| \_| &#x27;&#x27;\‐‐‐/&#x27;&#x27; | |</span></span><br><span class="line"><span class="string">\ .‐\__ `‐` ___/‐. /</span></span><br><span class="line"><span class="string">___`. .&#x27; /‐‐.‐‐\ `. . __</span></span><br><span class="line"><span class="string">.&quot;&quot; &#x27;&lt; `.___\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;.</span></span><br><span class="line"><span class="string">| | : `‐ \`.;`\ _ /`;.`/ ‐ ` : | |</span></span><br><span class="line"><span class="string">\ \ `‐. \_ __\ /__ _/ .‐` / /</span></span><br><span class="line"><span class="string">======`‐.____`‐.___\_____/___.‐`____.‐&#x27;======</span></span><br><span class="line"><span class="string">`=‐‐‐=&#x27;</span></span><br><span class="line"><span class="string">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line"><span class="string">佛祖保佑 永无BUG</span></span><br><span class="line"><span class="string">佛曰:</span></span><br><span class="line"><span class="string">写字楼里写字间，写字间里程序员；</span></span><br><span class="line"><span class="string">程序人员写程序，又拿程序换酒钱。</span></span><br><span class="line"><span class="string">酒醒只在网上坐，酒醉还来网下眠；</span></span><br><span class="line"><span class="string">酒醉酒醒日复日，网上网下年复年。</span></span><br><span class="line"><span class="string">但愿老死电脑间，不愿鞠躬老板前；</span></span><br><span class="line"><span class="string">奔驰宝马贵者趣，公交自行程序员。</span></span><br><span class="line"><span class="string">别人笑我忒疯癫，我笑自己命太贱；</span></span><br><span class="line"><span class="string">不见满街漂亮妹，哪个归得程序员？</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="2-变量以及数据类型"   >
          <a href="#2-变量以及数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-变量以及数据类型" class="headerlink" title="2. 变量以及数据类型"></a><strong>2.</strong> <strong>变量以及数据类型</strong></h3>
      
        <h4 id="2-1-变量的定义"   >
          <a href="#2-1-变量的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-变量的定义" class="headerlink" title="2.1 变量的定义"></a><strong>2.1</strong> <strong>变量的定义</strong></h4>
      <p>思考下列代码有什么问题？</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;今天天气真好&quot;</span>)</span><br><span class="line"><span class="comment">#不使用变量打印九次 &quot;今天天气真好&quot;,如果需要变成打印 &quot;今天天气不好&quot; 需要修改九行代码</span></span><br></pre></td></tr></table></div></figure>

<p>对于重复使用，并且经常需要修改的数据，可以定义为变量，来提高编程效率。</p>
<p>定义变量的语法为: 变量名 &#x3D; 变量值 。(这里的 &#x3D; 作用是赋值。)</p>
<p>定义变量后可以使用变量名来访问变量值。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量表示这个字符串。如果需要修改内容，只需要修改变量对应的值即可</span></span><br><span class="line">weather = <span class="string">&quot;今天天气真好&quot;</span></span><br><span class="line"><span class="built_in">print</span>(weather) <span class="comment"># 注意，变量名不需要使用引号包裹</span></span><br><span class="line"><span class="built_in">print</span>(weather)</span><br><span class="line"><span class="built_in">print</span>(weather)</span><br></pre></td></tr></table></div></figure>

<p>说明:</p>
<ul>
<li>变量即是可以变化的量，可以随时进行修改。</li>
<li>程序就是用来处理数据的，而变量就是用来存储数据的。</li>
</ul>

        <h4 id="2-2-变量的类型"   >
          <a href="#2-2-变量的类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-变量的类型" class="headerlink" title="2.2 变量的类型"></a><strong>2.2</strong> <strong>变量的类型</strong></h4>
      <p>程序中: 在 <strong>Python</strong> <strong>里为了应对不同的业务需求，也把数据分为不同的类型。</strong> 如下图所示：<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228192803702.png" alt="image-20221228192803702"></p>

        <h4 id="2-3-查看数据类型"   >
          <a href="#2-3-查看数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-查看数据类型" class="headerlink" title="2.3 查看数据类型"></a><strong>2.3</strong> <strong>查看数据类型</strong></h4>
      <ul>
<li>在python中，只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要咱们开发者主动的去说明它的类型，系统会自动辨别。也就是说在使用的时候 “变量没有类型，数据才有类型”。</li>
<li>比如下面的示例里，a 的类型可以根据数据来确认,但是我们没法预测变量 b 的类型。</li>
</ul>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228192859124.png" alt="image-20221228192859124"></p>
<ul>
<li><p>如果临时想要查看一个变量存储的数据类型，可以使用 **type(变量的名字)**，来查看变量存储的数据类型。</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228192954390.png" alt="image-20221228192954390"></p>
</li>
</ul>

        <h3 id="3-标识符和关键字"   >
          <a href="#3-标识符和关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-标识符和关键字" class="headerlink" title="3. 标识符和关键字"></a><strong>3.</strong> <strong>标识符和关键字</strong></h3>
      <p>计算机编程语言中，标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名，以建立起名称与使用之间的关系。</p>
<ol>
<li><p>标识符由字母、下划线和数字组成，且数字不能开头。</p>
</li>
<li><p>严格区分大小写。</p>
</li>
<li><p>不能使用关键字。</p>
</li>
</ol>
<p>思考：下面的标识符哪些是正确的，哪些不正确为什么</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fromNo12</span><br><span class="line">from#12</span><br><span class="line">my_Boolean</span><br><span class="line">my‐Boolean</span><br><span class="line">Obj2</span><br><span class="line">2ndObj</span><br><span class="line">myInt</span><br><span class="line">test1</span><br><span class="line">Mike2jack</span><br><span class="line">My_tExt</span><br><span class="line">_test</span><br></pre></td></tr></table></div></figure>


        <h4 id="3-1-命名规范"   >
          <a href="#3-1-命名规范" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-命名规范" class="headerlink" title="3.1 命名规范"></a><strong>3.1</strong> <strong>命名规范</strong></h4>
      <p>标识符命名要做到顾名思义。</p>
<p>起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可读性) 比如: 名字 就定义为 name ,定义学生 用 student </p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;zhangsan&quot;</span> <span class="comment"># bad</span></span><br><span class="line">name = <span class="string">&quot;zhangsan&quot;</span> <span class="comment"># good</span></span><br><span class="line">b = <span class="number">23</span> <span class="comment"># bad</span></span><br><span class="line">age = <span class="number">23</span> <span class="comment"># good</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>遵守一定的命名规范。</p>
<ul>
<li><p>驼峰命名法，又分为大驼峰命名法和小驼峰命名法。<img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221228193311078.png" alt="image-20221228193311078"></p>
<ul>
<li>小驼峰式命名法（lower camel case）： 第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog</li>
<li>大驼峰式命名法（upper camel case）： 每一个单字的首字母都采用大写字母，例如：FirstName、LastName.</li>
</ul>
</li>
<li><p>还有一种命名法是用下划线“_”来连接所有的单词，比如send_buf.</p>
<p>Python的命令规则遵循PEP8标准</p>
</li>
</ul>
</li>
</ul>

        <h4 id="3-2-关键字"   >
          <a href="#3-2-关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a><strong>3.2</strong> <strong>关键字</strong></h4>
      <ul>
<li><p>关键字的概念</p>
<p>一些具有特殊功能的标识符，这就是所谓的关键字。<br>关键字，已经被python官方使用了，所以不允许开发者自己定义和关键字相同名字的标识符。</p>
</li>
<li><p>关键字</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">False 		None 	True 	and 	as 		assert 	break 	class</span><br><span class="line">continue 	def 	del 	elif 	else 	except 	finally for</span><br><span class="line">from 		global 	if 		import 	in 		is 		lambda 	nonlocal</span><br><span class="line">not			or 		pass 	raise 	return 	try 	while 	with</span><br><span class="line">yield</span><br></pre></td></tr></table></div></figure>

<p>关键字的学习以及使用，咱们会在后面的课程中依次一一进行学习。</p>
</li>
</ul>

        <h3 id="4-类型转换"   >
          <a href="#4-类型转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-类型转换" class="headerlink" title="4. 类型转换"></a><strong>4.</strong> <strong>类型转换</strong></h3>
      <div class="table-container"><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换为一个整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换为一个浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串</td>
</tr>
<tr>
<td>bool(x)</td>
<td>将对象x转换成为布尔值</td>
</tr>
</tbody></table></div>
<p>转换成为整数</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;123&quot;</span>)) <span class="comment"># 123 将字符串转换成为整数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">123.78</span>)) <span class="comment"># 123 将浮点数转换成为整数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="literal">True</span>)) <span class="comment"># 1 布尔值True转换成为整数是 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="literal">False</span>)) <span class="comment"># 0 布尔值False转换成为整数是 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下两种情况将会转换失败</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">123.456 和 12ab 字符串，都包含非法字符，不能被转换成为整数，会报错</span></span><br><span class="line"><span class="string">print(int(&quot;123.456&quot;))</span></span><br><span class="line"><span class="string">print(int(&quot;12ab&quot;))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>转换成为浮点数</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f1 = <span class="built_in">float</span>(<span class="string">&quot;12.34&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(f1) <span class="comment"># 12.34</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f1)) <span class="comment"># float 将字符串的 &quot;12.34&quot; 转换成为浮点数 12.34</span></span><br><span class="line">f2 = <span class="built_in">float</span>(<span class="number">23</span>)</span><br><span class="line"><span class="built_in">print</span>(f2) <span class="comment"># 23.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f2)) <span class="comment"># float 将整数转换成为了浮点数</span></span><br></pre></td></tr></table></div></figure>

<p>转换成为字符串</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="built_in">str</span>(<span class="number">45</span>)</span><br><span class="line">str2 = <span class="built_in">str</span>(<span class="number">34.56</span>)</span><br><span class="line">str3 = <span class="built_in">str</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(str1,str2,str3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(str1),<span class="built_in">type</span>(str2),<span class="built_in">type</span>(str3))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">45 34.56 True</span></span><br><span class="line"><span class="string">&lt;class &#x27;str&#x27;&gt; &lt;class &#x27;str&#x27;&gt; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>转换成为布尔值</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(&#123;&#125;))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>([]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(()))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="5-运算符"   >
          <a href="#5-运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-运算符" class="headerlink" title="5. 运算符"></a><strong>5.</strong> <strong>运算符</strong></h3>
      
        <h4 id="5-1-算数运算符"   >
          <a href="#5-1-算数运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-1-算数运算符" class="headerlink" title="5.1 算数运算符"></a><strong>5.1</strong> <strong>算数运算符</strong></h4>
      <p>下面以a&#x3D;10 ,b&#x3D;20为例进行计算</p>
<div class="table-container"><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>两个对象相加 a + b 输出结果 30</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>得到负数或是一个数减去另一个数 a - b 输出结果 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除</td>
<td>b &#x2F; a 输出结果 2</td>
</tr>
<tr>
<td>&#x2F;&#x2F;</td>
<td>取整除</td>
<td>返回商的整数部分 9&#x2F;2 输出结果 4 , 9.0&#x2F;2.0 输出结果 4.0</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>返回除法的余数 b % a 输出结果 0</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>a**b 为10的20次方</td>
</tr>
<tr>
<td>()</td>
<td>小括号</td>
<td>提高运算优先级，比如: (1+2) * 3</td>
</tr>
</tbody></table></div>
<p>注意：混合运算时，优先级顺序为： ** 高于 * &#x2F; % &#x2F;&#x2F; 高于 + - ，为了避免歧义，建议使用 () 来处理运算符优先级。 并且，不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 + 5.5 * 2</span><br><span class="line">21.0</span><br><span class="line">&gt;&gt;&gt; (10 + 5.5) * 2</span><br><span class="line">31.0</span><br></pre></td></tr></table></div></figure>


        <h5 id="算数运算符在字符串里的使用"   >
          <a href="#算数运算符在字符串里的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#算数运算符在字符串里的使用" class="headerlink" title="算数运算符在字符串里的使用"></a><strong>算数运算符在字符串里的使用</strong></h5>
      <p>如果是两个字符串做加法运算，会直接把这两个字符串拼接成一个字符串。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: str1 =<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">In [<span class="number">2</span>]: str2 = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">In [<span class="number">3</span>]: str1+str2</span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line">In [<span class="number">4</span>]:</span><br></pre></td></tr></table></div></figure>

<p>如果是数字和字符串做加法运算，会直接报错。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">In [<span class="number">2</span>]: a = <span class="number">2</span></span><br><span class="line">In [<span class="number">3</span>]: a+str1</span><br><span class="line">‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐</span><br><span class="line">TypeError Traceback (most recent call last)</span><br><span class="line">&lt;ipython‐<span class="built_in">input</span>‐<span class="number">3</span>‐993727a2aa69&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">‐‐‐‐&gt; <span class="number">1</span> a+str1</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>如果是数字和字符串做乘法运算，会将这个字符串重复多次。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: str1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">In [<span class="number">5</span>]: str1*<span class="number">10</span></span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;hellohellohellohellohellohellohellohellohellohello&#x27;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-2-赋值运算符"   >
          <a href="#5-2-赋值运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-赋值运算符" class="headerlink" title="5.2 赋值运算符"></a><strong>5.2</strong> 赋值运算符</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值运算符</td>
<td>把 &#x3D; 号右边的结果 赋给 左边的变量，如 num &#x3D; 1 + 2 * 3，结果num的值为7</td>
</tr>
</tbody></table></div>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个变量赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment"># 同时为多个变量赋值(使用等号连接)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># 多个变量赋值(使用逗号分隔)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num1, f1, str1 = <span class="number">100</span>, <span class="number">3.14</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num1</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-3-复合赋值运算符"   >
          <a href="#5-3-复合赋值运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-3-复合赋值运算符" class="headerlink" title="5.3 复合赋值运算符"></a>5.3 复合赋值运算符</h4>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221229173458134.png" alt="image-20221229173458134"></p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：+=</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span> <span class="comment"># 相当于执行 a = a + 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="comment"># 示例：*=</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a *= <span class="number">2</span> <span class="comment"># 相当于执行 a = a * 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="comment"># 示例：*=，运算时，符号右侧的表达式先计算出结果，再与左边变量的值运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a *= <span class="number">1</span> + <span class="number">2</span> <span class="comment"># 相当于执行 a = a * (1+2)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-比较运算符"   >
          <a href="#5-4-比较运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-4-比较运算符" class="headerlink" title="5.4 比较运算符"></a><strong>5.4</strong> 比较运算符</h4>
      <p>以下假设变量a为10，变量b为20：</p>
<p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221229173716905.png" alt="image-20221229173716905"></p>

        <h4 id="5-5-逻辑运算符"   >
          <a href="#5-5-逻辑运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-5-逻辑运算符" class="headerlink" title="5.5 逻辑运算符"></a><strong>5.5</strong> 逻辑运算符</h4>
      <p><img src="https://cyuyan.oss-cn-beijing.aliyuncs.com/img/image-20221229173933414.png" alt="image-20221229173933414"></p>

        <h5 id="性能提升"   >
          <a href="#性能提升" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h5>
      <p>面试题：一下代码的输出结果是什么，为什么会有这样的输出。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">34</span></span><br><span class="line">a &gt; <span class="number">10</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)		<span class="comment"># hello world</span></span><br><span class="line">a &lt; <span class="number">10</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)		<span class="comment"># 逻辑与短路</span></span><br><span class="line">a &gt;<span class="number">10</span> <span class="keyword">or</span> <span class="built_in">print</span>(<span class="string">&#x27;你好世界&#x27;</span>)			<span class="comment"># 逻辑或短路</span></span><br><span class="line">a &lt;<span class="number">10</span> <span class="keyword">or</span> <span class="built_in">print</span>(<span class="string">&#x27;你好世界&#x27;</span>)			<span class="comment"># 你好世界</span></span><br></pre></td></tr></table></div></figure>

<p>思考：</p>
<ol>
<li><p>逻辑运算的短路问题</p>
</li>
<li><p>逻辑与运算和逻辑或运算取值时为什么是那种规则。</p>
</li>
</ol>

        <h3 id="6-输入输出"   >
          <a href="#6-输入输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-输入输出" class="headerlink" title="6.输入输出"></a>6.输入输出</h3>
      
        <h4 id="6-1-输出"   >
          <a href="#6-1-输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1-输出" class="headerlink" title="6.1 输出"></a><strong>6.1</strong> 输出</h4>
      
        <h5 id="普通输出"   >
          <a href="#普通输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通输出" class="headerlink" title="普通输出"></a>普通输出</h5>
      <p>python中变量的输出</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;吴亦凡火了&#x27;</span>)</span><br></pre></td></tr></table></div></figure>


        <h5 id="格式化输出"   >
          <a href="#格式化输出" class="heading-link"><i class="fas fa-link"></i></a><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5>
      <p>比如有以下代码</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pirnt(<span class="string">&quot;我今年10岁&quot;</span>)</span><br><span class="line">pirnt(<span class="string">&quot;我今年11岁&quot;</span>)</span><br><span class="line">pirnt(<span class="string">&quot;我今年12岁&quot;</span>)</span><br></pre></td></tr></table></div></figure>

<p>想一想:</p>
<p>在输出年龄的时候，用了多次”我今年xx岁”，能否简化一下程序呢？？？</p>
<p>答:</p>
<p>字符串格式化</p>
<p>看如下代码:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我今年%d岁&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">age += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我今年%d岁&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">age += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我今年%d岁&quot;</span> % age)</span><br></pre></td></tr></table></div></figure>

<p>在程序中，看到了%这样的操作符，这就是Python中格式化输出。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">name = <span class="string">&quot;红浪漫晶哥&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的姓名是%s, 年龄是%d&quot;</span> % (name, age))</span><br></pre></td></tr></table></div></figure>


        <h4 id="6-2-输入"   >
          <a href="#6-2-输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-输入" class="headerlink" title="6.2 输入"></a>6.2 输入</h4>
      <p>在Python中，获取键盘输入的数据的方法是采用 input 函数（至于什么是函数，咱们以后的章节中讲解），那么这个 input 怎么用呢?</p>
<p>看如下示例</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;您刚刚输入的密码是:%s&#x27;</span> % password)</span><br></pre></td></tr></table></div></figure>

<p>注意</p>
<ul>
<li><p>input()的小括号中放入的是提示信息，用来在获取数据之前给用户的一个简单提示</p>
</li>
<li><p>input()在从键盘获取了数据以后，会存放到等号右边的变量中</p>
</li>
<li><p>input()会把用户输入的任何值都作为字符串来对待</p>
</li>
</ul>

        <h3 id="7-流程控制语句"   >
          <a href="#7-流程控制语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-流程控制语句" class="headerlink" title="7. 流程控制语句"></a><strong>7.</strong> 流程控制语句</h3>
      
        <h4 id="7-1-if判断语句"   >
          <a href="#7-1-if判断语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-if判断语句" class="headerlink" title="7.1 if判断语句"></a>7.1 if判断语句</h4>
      <p>if语句是用来进行判断的，其使用格式如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 要判断的条件:</span><br><span class="line">	条件成立时，要做的事情</span><br></pre></td></tr></table></div></figure>

<p>demo1:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;我已经成年了&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">我已经成年了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>demo2:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">16</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;我已经成年了&quot;</span>)</span><br></pre></td></tr></table></div></figure>

<p>小总结：</p>
<ul>
<li>以上2个demo仅仅是age变量的值不一样，导致结果却不同；能够看得出if判断语句的作用：就是当满足一定条件时才会执行代码块语句，否则就不执行代码块语句。</li>
<li>注意：代码的缩进为一个tab键，或者4个空格</li>
</ul>
<p><strong>练一练</strong></p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">要求：从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了”</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 使用input从键盘中获取数据，并且存入到一个变量中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 使用if语句，来判断 age&gt;=18是否成立</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#input()输入的格式默认为字符串，如需要与数字比较需要强转</span></span><br><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入您的年龄：&#x27;</span>))</span><br><span class="line"><span class="comment"># print(type(age))</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您已成年，可以去网吧了&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;早点回家睡觉吧&quot;</span>)</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-2-if-else"   >
          <a href="#7-2-if-else" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-if-else" class="headerlink" title="7.2 if else"></a>7.2 if else</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">想一想：在使用if的时候，它只能做到满足条件时要做的事情。那万一需要在不满足条件的时候，做某些事，该怎么办呢？</span><br><span class="line">答：使用 if-else</span><br></pre></td></tr></table></div></figure>

<p><strong>if-else的使用格式</strong></p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">	满足条件时的操作</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	不满足条件时的操作</span><br></pre></td></tr></table></div></figure>

<p>demo1</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;我可以去红浪漫了&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;未成年，不允许去&quot;</span>）</span><br></pre></td></tr></table></div></figure>

<p>结果1：大于等于18的情况</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我可以去红浪漫了</span><br></pre></td></tr></table></div></figure>

<p>结果2：小于18的情况</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未成年，不允许去</span><br></pre></td></tr></table></div></figure>

<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">练一练</span><br><span class="line"></span><br><span class="line">要求：从键盘输入身高，如果身高没有超过150cm，则进动物园不用买票，否则需要买票。</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入您的身高：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> length &lt;= <span class="number">150</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不用买票&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;需要买票&quot;</span>)</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-3-elif"   >
          <a href="#7-3-elif" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-elif" class="headerlink" title="7.3 elif"></a>7.3 elif</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">想一想:</span><br><span class="line">如果有这样一种情况：当条件A满足时做事情1；当条件A不满足、条件B满足时做事情2；当条件B不满足、条件C满足时做事情3，那该怎么实现呢？</span><br><span class="line"></span><br><span class="line">答:</span><br><span class="line">elif</span><br></pre></td></tr></table></div></figure>

<p><strong>elif的功能</strong></p>
<p>elif的使用格式如下:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx1:</span><br><span class="line">	事情<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> xxx2:</span><br><span class="line">	事情<span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span> xxx3:</span><br><span class="line">	事情<span class="number">3</span></span><br></pre></td></tr></table></div></figure>

<p>说明:</p>
<ul>
<li><p>当xxx1满足时，执行事情1，然后整个if结束</p>
</li>
<li><p>当xxx1不满足时，那么判断xxx2，如果xxx2满足，则执行事情2，然后整个if结束</p>
</li>
<li><p>当xxx1不满足时，xxx2也不满足，如果xxx3满足，则执行事情3，然后整个if结束</p>
</li>
</ul>
<p>demo:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">77</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score&gt;=<span class="number">90</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为A&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score&gt;=<span class="number">80</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为B&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score&gt;=<span class="number">70</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为C&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score&gt;=<span class="number">60</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为D&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score&lt;<span class="number">60</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;本次考试，等级为E&#x27;</span>)</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-4-for"   >
          <a href="#7-4-for" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-for" class="headerlink" title="7.4 for"></a>7.4 for</h3>
      <p>在Python中 for循环可以遍历任何序列的项目，如一个列表或者一个字符串等。</p>
<p><strong>for循环的格式</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 临时变量 in 列表或者字符串等可迭代对象:</span><br><span class="line">循环满足条件时执行的代码</span><br></pre></td></tr></table></div></figure>

<p><strong>for循环的使用</strong></p>
<p>遍历字符串:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">e</span></span><br><span class="line"><span class="string">l</span></span><br><span class="line"><span class="string">l</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>打印数字（左闭右开）：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):		<span class="comment">#[0,5)</span></span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>练习</strong></p>
<p>使用for循环，计算1~100的和</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    <span class="built_in">sum</span> += i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-5-range"   >
          <a href="#7-5-range" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-5-range" class="headerlink" title="7.5 range"></a>7.5 range</h3>
      <p>range 可以生成数字供 for 循环遍历,它可以传递三个参数，分别表示 起始、结束和步长。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>, <span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></div></figure>


        <h2 id="8-数据类型高级"   >
          <a href="#8-数据类型高级" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-数据类型高级" class="headerlink" title="8. 数据类型高级"></a>8. 数据类型高级</h2>
      
        <h3 id="8-1-字符串高级"   >
          <a href="#8-1-字符串高级" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-1-字符串高级" class="headerlink" title="8.1 字符串高级"></a>8.1 字符串高级</h3>
      <ul>
<li><p>获取长度：len            len函数可以获取字符串的长度。</p>
</li>
<li><p>查找内容：find            查找指定内容在字符串中是否存在，如果存在就返回该内容在字符串中第一次出现的开始位置索引值，如果不存在，则返回-1</p>
</li>
<li><p>判断：startswith，endswith            判断字符串是不是以谁谁谁开头&#x2F;结尾</p>
</li>
<li><p>计算出现次数：count            返回 str在start和end之间 在 mystr里面出现的次数</p>
</li>
<li><p>替换内容：replace            替换字符串中指定的内容，如果指定次数count，则替换不会超过count次。</p>
</li>
<li><p>切割字符串：split            通过参数的内容切割字符串</p>
</li>
<li><p>修改大小写：upper，lower            将字符串中的大小写互换</p>
</li>
<li><p>空格处理：strip            去空格</p>
</li>
<li><p>字符串拼接：join            字符串拼接</p>
</li>
</ul>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Make great efforts</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://blog.csdn.net/weixin_45708609?spm=1000.2115.3001.5343/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="2215071022@qq.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="2215071022" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="http://2215071022@qq.com" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email Subscribe</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>zhang</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v6.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>