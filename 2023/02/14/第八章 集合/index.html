<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="第8章 集合       Java集合类是一种特别有用的工具类，可用于存储数量等的对象，并可以实现常用的数据结构  如栈、队列等。除此之外，Java集合还可用于保存具有映射关系的关联数组。Java集合大致可分为Set、List、Qucue和Map四种体系，其中Set代表无序，不可重复的集合；List代表有序、重复的集合；Map则代表具有映射关系的集合， Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="《疯狂Java讲义——集合》">
<meta property="og:url" content="http://example.com/2023/02/14/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Xiao Zhang&#39;blog">
<meta property="og:description" content="第8章 集合       Java集合类是一种特别有用的工具类，可用于存储数量等的对象，并可以实现常用的数据结构  如栈、队列等。除此之外，Java集合还可用于保存具有映射关系的关联数组。Java集合大致可分为Set、List、Qucue和Map四种体系，其中Set代表无序，不可重复的集合；List代表有序、重复的集合；Map则代表具有映射关系的集合， Ja">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-02-14T13:40:17.489Z">
<meta property="article:modified_time" content="2023-02-14T13:42:47.616Z">
<meta property="article:author" content="Xiao Zhang">
<meta name="twitter:card" content="summary"><title>《疯狂Java讲义——集合》 | Xiao Zhang'blog</title><link ref="canonical" href="http://example.com/2023/02/14/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E5%90%88/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">menu.Blog</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/software/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">menu.software</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Xiao Zhang's Blod</div><div class="header-banner-info__subtitle">Blod for Xiao Zhang</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">《疯狂Java讲义——集合》</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body">
        <h1 id="第8章-集合"   >
          <a href="#第8章-集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#第8章-集合" class="headerlink" title="第8章 集合"></a>第8章 集合</h1>
      <p>Java集合类是一种特别有用的工具类，可用于存储数量等的对象，并可以实现常用的数据结构  如栈、队列等。除此之外，Java集合还可用于保存具有映射关系的关联数组。<strong>Java集合大致可分为Set、List、Qucue和Map四种体系</strong>，其中Set代表无序，不可重复的集合；List代表有序、重复的集合；Map则代表具有映射关系的集合， Java 5又增加了 Queue 体系集合，代表一种队列集合实现。</p>
<p>而Java集合就像一种容器，可以把多个对象(实际上是对象的引用，但习惯上都称对象)“丢进”  容器中。在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object类型  处理：从Java5增加了泛型以后，Java集合可以记住容器中对象的数据类型，从而可以编写出更简洁、  健壮的代码。本章不会介绍泛型的知识，本章重点介绍Java的4种集合体系的功能和用法。本章将详细介绍Java的4种集合体系的常规功能，深入介绍各集合实现类所提供的独特功能，深入分析各实现类的实现机制，以及用法上的细微差别，并给出不同应用场景选择哪种集合实现类的建议。</p>

        <h2 id="8-1-Java集合概述"   >
          <a href="#8-1-Java集合概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-1-Java集合概述" class="headerlink" title="8.1 Java集合概述"></a>8.1 Java集合概述</h2>
      <p>在编程时，常常需要集中存放多个数据，例如第6章练习题中梭哈游戏里剩下的牌。可以使用数组来保存多个对象，但数组长度不可变化，一旦在初始化数组时指定了数组长度，这个数组长度就是不可变的，如果需要保存数量变化的数据，数组就有点无能为力了；而且数组无法保存具有映射关系的数据，  如成绩表：语文一79,数学一80,这种数据看上去像两个数组，但这两个数组的元素之间有一定的关联关系。</p>
<p>为了保存数量不确定的数据，以及保存具有映关系的数据(也被称为关联数组),Java提供了集合类。集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所有的集合类都位于 Java. util  包下，后来为了处理多线程环境下的并发安全问题，Java 5 还在 java.util.concurrent f包下提供了一些多线程支持的集合类。</p>
<p>集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象(实际上保存的是对象的引用变量)；而集合里只能保存对象(实际上只是保存对的引用变量，但通常习惯上认为集合里保存的是对象)。</p>
<p>Java的集合类主要由两个接口派生而出：Collection 和Map，Collection和Map是集合框架的跟接口，这两个接口又包括了一些子接口或实现类。</p>
<p>Collection接口、子接口及其实现类的继承树。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Collection&lt;--Set</span><br><span class="line">Collection&lt;--Queue</span><br><span class="line">Collection&lt;--List</span><br><span class="line">Set&lt;--EnumSet</span><br><span class="line">Set&lt;--SortedSet</span><br><span class="line">Set&lt;--HashSet</span><br><span class="line">SortedSet&lt;--TreeSet</span><br><span class="line">HashSet&lt;--LinedHashSet</span><br><span class="line">Queue&lt;--Deque</span><br><span class="line">Queue&lt;--PriortyQueue</span><br><span class="line">Deque&lt;--ArrayDeque</span><br><span class="line">List&lt;--LinkedList</span><br><span class="line">Deque&lt;--LinkedList</span><br><span class="line">List&lt;--ArrayList</span><br><span class="line">List&lt;--Vector</span><br><span class="line">Vector&lt;--Stack</span><br></pre></td></tr></table></div></figure>

<p>Set和List是Collection派生出来的两个子类，Set代表无序集合，元素不能重复；List代表有序集合，元素可以重复。Queue是Java提供的队列实现，有点类似与List。</p>
<p>Map继承树，所有的Map实现类用于保存具有映射关系的数据（关联数组）。</p>
<p>Map类保存的每项数据都是key-value对，其中key是不可重复的，key用于标识鞂里的每项数据，如果需要查阅Map中的数据时，总是根据Map的key来获取。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Map&lt;--EnumMap</span><br><span class="line">Map&lt;--IdentityHashMap</span><br><span class="line">Map&lt;--HashMap</span><br><span class="line">Map&lt;--Hashtable</span><br><span class="line">Map&lt;--SortedMap</span><br><span class="line">Map&lt;--WeakHashMap</span><br><span class="line">HashMap&lt;--LinedHashMap</span><br><span class="line">Hashtable&lt;--Properties</span><br><span class="line">SortedMap&lt;--TreeMap</span><br></pre></td></tr></table></div></figure>

<p>Set像一个罐子，把一个对象添加到Set时，无法记住添加这个元素的顺序，所以Set里的元素不能重复。访问时也只能通过元素本身访问；List像一个数组，他可以记住每次添加元素的顺序、而且List的长度是可变的。所以访问List集合中的元素时可以根据元素的索引来访问；Map集合也像一个罐子，只是它里面的每项数据都是由两个值组成的，可以根据每项元素的key来访问其value。</p>
<p>![](C:\Program Files\Typora\image\630ec9edb4bca6cd4e84e5c8efd5ec2.jpg)</p>

        <h2 id="8-2-Java-11新增的-Collection-和-Iterator接口"   >
          <a href="#8-2-Java-11新增的-Collection-和-Iterator接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-Java-11新增的-Collection-和-Iterator接口" class="headerlink" title="8.2 Java 11新增的 Collection 和 Iterator接口"></a>8.2 Java 11新增的 Collection 和 Iterator接口</h2>
      <p>集合器就像容器，现实生活中容器的功能，无非就是添加对象、删除对象、清空容器、判断容器是否为空等，集合类就为这些功能提供了对应的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">List</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//		添加元素</span></span><br><span class="line">		c.add(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line"><span class="comment">//		虽然集合不允许放基本类型的值，但Java支持自动装箱</span></span><br><span class="line">		c.add(<span class="number">6</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;C集合的元素个数为：&quot;</span>+c.size());</span><br><span class="line"><span class="comment">//		删除指定元素,1表示索引</span></span><br><span class="line">		c.remove(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;C集合的元素个数为：&quot;</span>+c.size());</span><br><span class="line"><span class="comment">//		判断是否包含指定字符串</span></span><br><span class="line">		System.out.println(<span class="string">&quot;c集合是包含\&quot;孙悟空\&quot;字符串:&quot;</span>+c.contains(<span class="string">&quot;孙悟空&quot;</span>));</span><br><span class="line">		c.add(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;c集合的元素：&quot;</span>+c);</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;EE 企业级开发&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;c中是否完全包含books&quot;</span>+c.containsAll(books));</span><br><span class="line"><span class="comment">//		用c集合减去Books集合的元素</span></span><br><span class="line">		c.removeAll(books);</span><br><span class="line">		System.out.println(c);</span><br><span class="line">		c.clear();</span><br><span class="line">		System.out.println(c);</span><br><span class="line"><span class="comment">//		retainAll(c)：从集合中删除集合c中不包含的元素</span></span><br><span class="line"><span class="comment">//		控制books集合里只剩下c集合里也包含的元素</span></span><br><span class="line">		books.retainAll(c);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Java 11为Collection新增了一个toArray(IntFunction)方法，使用该方法的主要谜底就是利用泛型。对于传统的toArray()方法而言，不管Collection本身是否使用泛型，toArray()的返回值总是Object[]；但新增的toArray()方法而言，不管Collection本身是否使用泛型，toArray()的返回值总是Object[]；但是新增的方法不同，当集合使用反形式可以返回特定类型的数组。</p>

        <h3 id="8-2-1-使用Lambda表达式遍历集合"   >
          <a href="#8-2-1-使用Lambda表达式遍历集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-1-使用Lambda表达式遍历集合" class="headerlink" title="8.2.1 使用Lambda表达式遍历集合"></a>8.2.1 使用Lambda表达式遍历集合</h3>
      <p>Java 8 为Iterable接口新增了一个forEach默认方法，该方法所需参数的类型是一个函数式接口，而Iterable接口是Collection接口的父接口，因此Collection集合特可以直接调用该方法。</p>
<p>当程序调用 Iterable 的 forEach(Consumer action) 遍历集合元素时，程序会一次将集合元素传给Consumer的	accept(T t)方法（该接口中惟一的抽象方法）。正因为Consumer是函数式接口，因此可以使用Lambda表大会来遍历集合元素。</p>
<p>如下程序示范了使用Lambda表达式来遍历集合元素：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionEach</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		调用forEach()方法遍历集合</span></span><br><span class="line">		books.forEach(obj -&gt; System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));<span class="comment">//粗</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>粗调用了Iterable的forEach()默认方法来遍历数组，传给方法的是一个Lambdm表达式，该Lambda表达式的目标类型是Consumer。forEach方法会自动将集合元素逐个传给Lambda表达式的形参，这样Lambda表达式的代码体即可遍历到集合元素了。</p>

        <h3 id="8-2-2-使用-Iterator-遍历集合元素"   >
          <a href="#8-2-2-使用-Iterator-遍历集合元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-2-使用-Iterator-遍历集合元素" class="headerlink" title="8.2.2 使用 Iterator 遍历集合元素"></a>8.2.2 使用 Iterator 遍历集合元素</h3>
      <p>Iterator主要用于遍历（即迭代访问）Collection集合中的元素，Iterator对象也被称为迭代器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		获取books集合对应的迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> books.iterator();</span><br><span class="line"><span class="comment">//		如果集合中还有剩下的元素，返回ture</span></span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			it.next()方法返回的数据类型是Object类型，因此需要强制类型转换</span></span><br><span class="line"><span class="comment">//			next:返回迭代中的下一个元素</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">book</span> <span class="operator">=</span> (String)it.next();</span><br><span class="line">			System.out.println(book);</span><br><span class="line"><span class="comment">//			equals():将此字符串与指定的对象进行比较。</span></span><br><span class="line"><span class="comment">//			当且仅当参数不为空且是表示与此对象相同字符序列的字符串对象时，结果为真。</span></span><br><span class="line">			<span class="keyword">if</span>(book.equals(<span class="string">&quot;疯狂Java讲义&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				从集合中删除上一次next()方法返回的元素</span></span><br><span class="line">				it.remove();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			对book变量赋值，不会影响集合元素本身</span></span><br><span class="line">			book = <span class="string">&quot;测试字符串&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上可以看出，Iterator本身并不提供承装对象的能力，如果需要创建Iterator对象，则必须有一个被迭代的集合。没有集合的Iterator仿佛无本之木，没有存在的价值。</p>
<p>使用Iterator迭代过程中不可修改集合元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorErrorrTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂 Android 讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		获取books集合对应的迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> books.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">book</span> <span class="operator">=</span> (String)it.next();</span><br><span class="line">			System.out.println(book);</span><br><span class="line">			<span class="keyword">if</span>(book.equals(<span class="string">&quot;疯狂 Android 讲义&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				使用Iterator迭代过程中不可修改集合元素，下面代码将引发异常</span></span><br><span class="line">				books.remove(book);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中修改集合元素的代码位于Iterator迭代块内，也就是在Iterator迭代Collection集合过程中修改了Collection集合，所以程序将在运行时引发异常。</p>

        <h3 id="8-2-3-使用Lambda表达式遍历Iterator"   >
          <a href="#8-2-3-使用Lambda表达式遍历Iterator" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-3-使用Lambda表达式遍历Iterator" class="headerlink" title="8.2.3 使用Lambda表达式遍历Iterator"></a>8.2.3 使用Lambda表达式遍历Iterator</h3>
      <p>forEachRemaining()方法所需的Consumer 参数同样也是函数式接口，当程序调用Iterator的forEachRemaining()遍历集合元素时，程序会依次将集合元素传给Consumer的accept(T t)方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteartorEach</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		使用forEachRemaining方法将形参（Lambda表达式）传入封装的HasNext和Nest方法</span></span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂 Android 讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		获取books集合对应的迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> books.iterator();</span><br><span class="line"><span class="comment">//		使用Lambda表达式（目标类型是Comsumer）来遍历集合数组</span></span><br><span class="line">		it.forEachRemaining(obj-&gt;System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span>+obj));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="8-2-4-使用foreach循环遍历集合元素"   >
          <a href="#8-2-4-使用foreach循环遍历集合元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-4-使用foreach循环遍历集合元素" class="headerlink" title="8.2.4 使用foreach循环遍历集合元素"></a>8.2.4 使用foreach循环遍历集合元素</h3>
      <p>​	foreach循环迭代访问集合元素更加便捷。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeachTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂 Android 讲义&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> obj:books)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			此处的book变量也不是集合元素本身</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">book</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">			System.out.println(book);</span><br><span class="line">			<span class="keyword">if</span>(book.equals(<span class="string">&quot;疯狂 Android 讲义&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				下面代码会引发异常</span></span><br><span class="line">				books.remove(book);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>foreach循环中的迭代变量也不是集合元素本省，系统知识依次把集合元素的值赋给迭代元素，因此在foreach循环中修改迭代元素的值也没有任何实际意义。</p>
<p>同样当使用foreach循环迭代访问集合元素的时候，该集合也不可以被修改，否则会引发ConcurrentModificationException异常。</p>

        <h3 id="8-2-5-使用Predicate操作集合"   >
          <a href="#8-2-5-使用Predicate操作集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-5-使用Predicate操作集合" class="headerlink" title="8.2.5 使用Predicate操作集合"></a>8.2.5 使用Predicate操作集合</h3>
      <p>在Collection集合新增看一个removerIF(Predicate filter)方法，该方法会批量删除符合filter条件的所有元素。该方法需要一个Predicate（谓词）对象作为参数，Predicate也是函数式接口，因此可使用Lambda表达式作为参数。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Ajax讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		使用Lambda表达式（目标类型是Predicate）过滤集合</span></span><br><span class="line">		books.removeIf(ele-&gt;((String)ele).length()&lt;<span class="number">10</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredicateTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Ajax讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		统计书名中包含“疯狂”子串的图书数量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;书名中包含“疯狂”子串的图书数量:&quot;</span>+calAll(books,ele-&gt;((String)ele).contains(<span class="string">&quot;疯狂&quot;</span>)));</span><br><span class="line"><span class="comment">//		统计书名中包含“Java”子串的图书数量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;名中包含“Java”子串的图书数量:&quot;</span>+calAll(books,ele-&gt;((String)ele).contains(<span class="string">&quot;Java&quot;</span>)));</span><br><span class="line"><span class="comment">//		统计书名字符串长度大于10的图书数量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;书名字符串长度大于10的图书数量:&quot;</span>+calAll(books,ele-&gt;((String)ele).length()&gt;<span class="number">10</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calAll</span><span class="params">(Collection books, Predicate p)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> obj:books)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			使用Predicate的test()方法判断该对象是否满足Predicate指定的条件</span></span><br><span class="line">			<span class="keyword">if</span>(p.test(obj))</span><br><span class="line">			&#123;</span><br><span class="line">				total++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序先定义了一个calAll()方法，该方法将会使用Predicate判断每个集合元素是否符合特定的条件——该条件将通过Predicate参数动态传入，冲上面程序中三行粗体字可以看到，程序传入三个Lambda表达式（其目标类型都是Predicate），这样calAll()方法就智慧统计满足Predicate的图书。</p>

        <h3 id="8-2-6-使用Stream操作集合"   >
          <a href="#8-2-6-使用Stream操作集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-6-使用Stream操作集合" class="headerlink" title="8.2.6 使用Stream操作集合"></a>8.2.6 使用Stream操作集合</h3>
      <p>先跳过</p>

        <h2 id="8-3-Set集合"   >
          <a href="#8-3-Set集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-Set集合" class="headerlink" title="8.3 Set集合"></a>8.3 Set集合</h2>
      <p>它类似与一个罐子，程序可以依次把多个对象“丢进”Set集合中，而Set集合通常不能记住元素的添加顺序。Set集合与Collection基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。</p>
<p>如果试图把两个相同的元素加到Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。</p>

        <h3 id="8-3-1-HashSet类"   >
          <a href="#8-3-1-HashSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-1-HashSet类" class="headerlink" title="8.3.1 HashSet类"></a>8.3.1 HashSet类</h3>
      <p>HashSet是Set接口的典型实现，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来储存集合中的元素，因此具有横好的存取和查找功能。</p>
<p>HashSet具有以下特点</p>
<ul>
<li>不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。</li>
<li>HashSet不是同步的，如果多个线程同时访问一个 HashSet，假设有两个或者两个以上线程同时修改了 HashSet集合时，则必须通过代码来保证其同步。</li>
<li>集合元素值可以是null。</li>
</ul>
<p>当向 HashSet集合中存入一个元素时， HashSet会调该对象的 hashCode()方法来得到该对象的   hashCode 值，然后根据该 hashCode值决定该对象在 HashSet 中的存储位置。如果有两个元素通过 equals  方法比较返回true,但它们的 hashCode()方法返回值不相等， HashSet将会把它们存储在不同的位置，  依然可以添加成功。也就是说， HashSet集合判断两个元素相等的标准是两个对象通过 equals方法比较相等，并且两个对象的hashCodet方法返回值也相等  下面程序分别提供了三个类A、B和C,它们分别重写了 equals()、 hashCode()两个方法的一个或全部，通过此程序可以让读者看到 HashSet判断集合元素相同的标准。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line">		books.add(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>以上程序分别添加了两个A两个B两个C，但是其中C同时重写了hashCode方法和equals方法，所以导致HashSet把两个C对象当成了一个对象。</p>
<p>![image-20210413181200991](C:\Program Files\Typora\image\image-20210413181200991.png)</p>
<p>由此可见：当一个对象放进HashSet中时，如果需要重写该对象对应类的equals方法，则也应该重写hashCode（）方法。规则是：如果两个对象通过equals()方法比较返回true，这两个对象的hashCode值也应该相等。</p>
<p>&#x3D;&#x3D;如果两个对象通过 equals方法比较返回true,但这两个对象的hashCode方法返回不同的 hashCode  值时，这将导致 HashSet会把这两个对象保存在Hash表的不同位置，从而使两个对象都可以添加成功，这就与Set集合的规则冲突了。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;如果两个对象的 hashCode方法返回的 hashCode值相同，但它们通过 equals方法比较返回 false  时将更麻烦：因为两个对象的 hashCode值相同， HashSet试图把它们保存在同一个位置，但又不行(否则将只剩下一个对象),所以实际上会在这个位置用链式结构来保存多个对象；而 HashSet访问集合元素时也是根据元素的 hashCode值来快速定位的，如果 HashSet中两个以上的元素具有相同的 hashCode 值，将会导致性能下降。&#x3D;&#x3D;</p>
<p>注意：如果需要把某个类的对象保存到 HashSet集合中，重写这个类的 equals 方法和 hashCode 方法时，应该尽量保证两个对象通过 equals 方法比较返回true时，它们的 hashCode 方法返回值也相等。</p>
<p>HashSet中每个能存储元素的“槽位”(slot)通常称为“桶”( bucket),如果有多个元素的 hashCode值相同，但它们通过equals方法比较返回 false,就需要在一个“桶”里放多个元素，这样会导致性能下降。</p>
<p>前面介绍了 hashCode方法对于 HashSet的重要性，实际上，对象的 hashCode 值对于后面的 HashMap同样重要，下面给出重写 hashCode方法的基本规则。</p>
<ul>
<li>在程序运行过程中，同一个对象多次调用 hashCode方法应该返回相同的值。</li>
<li>当两个对象通过 equals方法比较返回true时，这两个对象的 hashCode方法应返回相等的值。</li>
<li>对象中用作 equals方法比较标准的实例变量，都应该用于计算 hashCode值。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">R</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;R[count:&quot;</span>+count+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == R.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (R)obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.count == r.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">5</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">3</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">9</span>));</span><br><span class="line">		hs.add(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">2</span>));</span><br><span class="line"><span class="comment">//		打印HashSet集合，集合元素没有重复</span></span><br><span class="line">		System.out.println(hs);</span><br><span class="line"><span class="comment">//		取出第一个元素</span></span><br><span class="line"><span class="comment">//		iterator()：返回该集合中所有元素的迭代器。元素的返回没有特定的顺序。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> hs.iterator();</span><br><span class="line">		<span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> (R) it.next();</span><br><span class="line"><span class="comment">//		为第一个元素的count实例变量赋值</span></span><br><span class="line">		first.count = -<span class="number">3</span>;<span class="comment">//①</span></span><br><span class="line"><span class="comment">//		再次输出HashSet集合，集合中有元素重复</span></span><br><span class="line">		System.out.println(hs);</span><br><span class="line"><span class="comment">//		删除count为-3的R对象</span></span><br><span class="line">		hs.remove(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">3</span>));</span><br><span class="line"><span class="comment">//		可以看到被删除了一个R元素</span></span><br><span class="line">		System.out.println(hs);</span><br><span class="line">		System.out.println(<span class="string">&quot;hs是否包含count为-3的R对象？&quot;</span></span><br><span class="line">				+hs.contains(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">3</span>)));</span><br><span class="line">		System.out.println(<span class="string">&quot;hs是否包含count为-2的R对象&quot;</span></span><br><span class="line">				+hs.contains(<span class="keyword">new</span> <span class="title class_">R</span>(-<span class="number">2</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面提供了R类，R类重写了equals(Object obj)方法和hashCode()方法，这两个方法的都是根据R对象的count实例变量来判断的。上面程序①改变了Set集合中第一个R对象的count实例变量值，这导致R对象以集合中的其他R对象相同。</p>
<p>![image-20210413220840853](C:\Program Files\Typora\image\image-20210413220840853.png)</p>
<p>此时的Set集合已经有些混乱，当试图删除count为-3的R对象时，HashSet会计算出该对象的hashCode值，从而找到该对象在集合中的保存位置，然后把此处的对象与count为-3的R对象通过实际上保存在count为-2的R对象进行比较，如果相等则删除该对象——HashSet只有第二个元素才满足该条件（第一个元素实际保存在count为-2的位置上）所以第二个元素被删除。至于第一个count值为-3的R对象，它保存在count为-2的R对象对应位置上，但使用equals()方法拿他和count为-2的对象比较时又返回false——这导致HashSet不能精准访问该元素。</p>
<p>所以程序把可变对象添加到HashSet中之后，不要再去修改该集合元素中参与计算的hashCode()、equals()的实例变量，否则将会导致HashSet无法正确操作这些集合元素。</p>

        <h3 id="8-3-2-LinkedHashSet-类"   >
          <a href="#8-3-2-LinkedHashSet-类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-2-LinkedHashSet-类" class="headerlink" title="8.3.2 LinkedHashSet 类"></a>8.3.2 LinkedHashSet 类</h3>
      <p>HashSet的子类，LinkedHashSet集合也是根据元素的hashCode值来决定元素的储存位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素添加的顺序来访问集合里的元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">HashSet</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;轻量级java EE 企业应用实战&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">		books.remove(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> 虽然LinkedHashSet使用了链表记录集合元素的添加顺序，但是LinkedHashSet依然是HashSet，因此他依然不允许集合元素重复。</p>

        <h3 id="8-3-3-TreeSet类"   >
          <a href="#8-3-3-TreeSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-3-TreeSet类" class="headerlink" title="8.3.3 TreeSet类"></a>8.3.3 TreeSet类</h3>
      <p>是SortedSet接口的实现类，正如SortedSet所暗示的，TreeSet可以确保集合元素处于排序状态。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">		nums.add(<span class="number">5</span>);</span><br><span class="line">		nums.add(<span class="number">2</span>);</span><br><span class="line">		nums.add(<span class="number">10</span>);</span><br><span class="line">		nums.add(-<span class="number">9</span>);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		System.out.println(nums.first());</span><br><span class="line">		System.out.println(nums.last());</span><br><span class="line"><span class="comment">//		返回小于四的子集，不包含四</span></span><br><span class="line">		System.out.println(nums.headSet(<span class="number">4</span>));</span><br><span class="line"><span class="comment">//		返回大于5的子集，包含5</span></span><br><span class="line">		System.out.println(nums.tailSet(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//		返回大于等于-3，小于4的子集</span></span><br><span class="line">		System.out.println(nums.subSet(-<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>与HashSet集合采用hash算法来决定元素的储存位置不同，TreeeSet采用红黑树的数据结构来储存集合元素，TreeSet支持两种排序方法：自然排序和定制排序。默认情况自然排序。</p>

        <h4 id="1-自然排序"   >
          <a href="#1-自然排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-自然排序" class="headerlink" title="1.自然排序"></a>1.自然排序</h4>
      <p> TreeSet调用集合元素的 compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式就是自然排序。</p>
<p><strong>Java提供了一个 Comparable接口，该接口里定义了一个 compareTo(Object ob)方法，该方法返回个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小。</strong>当一个对象调用该方法与另一个对象进行比较时，例：	obj1.compareTo(obj2),如果该方法返回0,则表明这两个对象相等：如果该方法返回一个正整数，则表明obj1大于obj2如果该方法返回一个负整数，则表明obj1小于obj2。</p>
<p>Java的一些常用类已经实现了 Comparable接口，并提供了比较大小的标准。下面是实现了Comparable接口的常用类。</p>
<ul>
<li>Biglnteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较。   </li>
<li>Character:按字符的 Unicode值进行比较。</li>
<li>Boolean : true对应的包装类实例大于 false对应的包装类实例。</li>
<li>String:依次比较字符串中每个字符的 Unicode 值。</li>
<li>Date、Time：后面的时间、日期比前面的时间、日期大。</li>
</ul>
<p>将对象添加到TreeSet时，该对象的类必须实现Comparabele接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Err</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetErrorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">TreeSet</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"><span class="comment">//		向TreeSet集合中添加两个Err对象</span></span><br><span class="line">        <span class="comment">//不实现就应发异常</span></span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Err</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210414143028408](C:\Program Files\Typora\image\image-20210414143028408.png)</p>
<p>还有一点必须指出：大部分类在实现 compareTo (Object obj)方法时，都需要将被比较对象obj强类型转换成相同类型，因为只有相同类的两个实例才会比较大小。当试图把一个对象添加到TreeSet集合时， TreeSet会调用该对象的 compareTo( Object obj)方法与集合中的其他元素进行比较——这就要求集合中的其他元素与该元素是同一个类的实例。也就是说，向TeetSet中添加的应该是同一个类的对象，否则也会引发 Class CastException异常。如下程序示范了这个错误。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetErrorTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"><span class="comment">//		向TreeSet集合中添加两个对象</span></span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//①</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序先向TreeSet集合中添加了一个字符串对象，这个操作完全正常。当添加第二个Date对象时， TreeSet就会调用该对象的 compareTo(Object obj)方法与集合中的其他元素进行比较，Date对象的 compareTo(Object obj)方法无法与字符串对象比大小，所以上面程序将在①号代码处引发异常。</p>
<p>如果向 TreeSet中添加的对象是程序员自定义类的对象，则可以向TreeSet中添加多种类型的对象，  前提是用户自定义类实现了 Comparable接口，且实现 compareTo( Object obj)方法没有进行强制类型转换，但当试图取出 TreeSet里的集合元素时，不同类型的元素依然可能发生 Class CastException异常。</p>
<p>注意：总结起来一句话：如果希望TreeSet能正常运作， TreeSet只能添加同一种类型的对象。</p>
<p>当把一个对象加入 TreeSet 集合中时， TreeSet调用该对象的compareTo(Object obj  )方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过 compare To(Object ob)  方法比较相等，新对象将无法添加到 TreeSet集合中。  对于 TreeSet集合而言，它判断两个对象是否相等的唯标准是：两个对象通过	compareTo(Object obj)方法比较是否返回0——如果通过compareTo(Object obj)方法比较返回0，TreeSet则会认为他们是相等；否则就会认为他们不相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Z</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写equals()方法，总是返回true</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写了compareTo(Object obj)方法，总是返回1</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">		<span class="type">var</span> <span class="variable">z1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Z</span>(<span class="number">6</span>);</span><br><span class="line">		set.add(z1);</span><br><span class="line"><span class="comment">//		第二次添加同一个对象，输出true，表明添加成功</span></span><br><span class="line">		System.out.println(set.add(z1));<span class="comment">//①</span></span><br><span class="line"><span class="comment">//		下面输出set集合，将看到有两个对象</span></span><br><span class="line">		System.out.println(set);</span><br><span class="line"><span class="comment">//		修改set集合的第一个元素的age变量</span></span><br><span class="line">		((Z)(set.first())).age = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//		输出set集合的最后一个元素的age变量，将看到也变成了9；</span></span><br><span class="line">		System.out.println(((Z)(set.last())).age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>程序中①号代码把同一个对象再次添加到TreeSet集合中，因为z1对象的compareTo(Object obj)方法总是返回1，虽然他的equals()方法总是返回true，但是TreeSet会认为z1对象和他自己相等，因此TreeSet可以添加两个z1对象。</p>
<p>实际上TreeSet保存的两个元素他们引用的是同一个对象。所以当修改TreeSet集合里第一个元素的age变量后，该TreeSet集合里的最后一个元素的age变量也随之改变。</p>
<p>向TreeSet添加可变变量后，可变变量改变后，可能会与其他对象的大小顺序发生改变，但TreeSet不会再次调整他们的顺序，甚至可能导致TreeSet中保存的这两个对象通过compareTo(Object obj)方法比较返回0。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R1</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">R1</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;R1[count:&quot;</span>+count+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写了equals()方法，根据count来判断是否相等</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == R1.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (R1) obj;</span><br><span class="line">			<span class="keyword">return</span> r.count == <span class="built_in">this</span>.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写comparTo()方法，根据count来比较大小</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (R1)obj;</span><br><span class="line">		<span class="keyword">return</span> count &gt; r.count?<span class="number">1</span>:</span><br><span class="line">			count&lt;r.count?-<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(<span class="number">5</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(-<span class="number">3</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(<span class="number">9</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">R1</span>(-<span class="number">2</span>));</span><br><span class="line"><span class="comment">//		打印TreeSet集合，集合元素时有序排列的</span></span><br><span class="line">		System.out.println(ts);<span class="comment">//①</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> (R1)ts.first();</span><br><span class="line"><span class="comment">//		对第一个元素的count赋值</span></span><br><span class="line">		first.count = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//		取出最后一个元素</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">last</span> <span class="operator">=</span> (R1)ts.last();</span><br><span class="line"><span class="comment">//		对最后一个元素的count赋值，与第二个元素的count相同</span></span><br><span class="line">		last.count = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//		再次输出将看到TreeSet里的元素处于无序状态，且有重复元素</span></span><br><span class="line">		System.out.println(ts);<span class="comment">//②</span></span><br><span class="line"><span class="comment">//		删除实例变量被改的元素，删除失效</span></span><br><span class="line">		System.out.println(ts.remove(<span class="keyword">new</span> <span class="title class_">R1</span>(-<span class="number">2</span>)));<span class="comment">//③</span></span><br><span class="line">		System.out.println(ts);</span><br><span class="line"><span class="comment">//		删除实例变量没有改变的元素，删除成功</span></span><br><span class="line">		System.out.println(ts.remove(<span class="keyword">new</span> <span class="title class_">R1</span>(<span class="number">5</span>)));<span class="comment">//④</span></span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中的R对象对应的类正常重写了 equals方法和 compareTo方法，这两个方法都以R对象的 count 实例变量作为判断的依据。当程序执行①号代码时，看到程序输出的Set集合元素处于有序状态：<strong>因为R类是一个可变类，因此可以改变R对象的 count实例变量的值，程序通过粗体字代码改变了该集合里第一个元素和最后一个元素的count实例变量的值。</strong>当程序执行②号代码输出时，将看到该集合处于无序状态而且集合中包含了重复元素。</p>
<p>一旦改变了 TreeSet集合里可变元素的实例变量,当再试图删除该对象时, TreeSet也会删除失败(甚至集合中原有的、实例变量没被修改但与修改后元素相等的元素也无法删除),所以在上面程序的③号代码处,删除 count为2的R对象时,没有任何元素被删除;程序执行④号代码时,可以看到删除了 count为5的R对象,这表明<strong>TreeSet可以删除没有被修改实例变量、且不与其他被修改实例变量的对象重复的对象。</strong></p>
<p>注意：当执行了④号代码后，TreeSet会对集合中的元素重新索引(不是重新排序),接下来就可以删除 TreeSet中的所有元素了,包括那些被修改过实例变量的元素。与 HashSet类似的是,如果TreeSet中包含了可变对象,当可变对象的实例变量被修改时, TreeSet在处理这些对象时将非常复杂,而且容易出错。为了让程序更加健壮，推荐不要修改放入HashSet和 TreeSet集合中元素的关键实例变量。</p>

        <h4 id="2-定制排序"   >
          <a href="#2-定制排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-定制排序" class="headerlink" title="2.定制排序"></a>2.定制排序</h4>
      <p> TreeSet 的自然排序是根据集合元素的大小, TreeSet 它们以升序排列。如果需要实现定制排序，例如以降序排列,则可以通过 Comparator接口的帮助。该接口里包含一个 int compare(T o1,T o2)方法,该方法用于比较o1和o2的大小:如果该方法返回正整数,则表明o1大于o2;如果该方法返回0,则表明o等于o2,如果该方法返回负整数,则表明o1小于o2。</p>
<p>如果需要实现定制排序,则需要在创建 TreeSet合对象时,提供一个 Comparator对象与该 TreeSe集合关联,由该 Comparator对象负责集合元素的排序逻辑。由于 Comparator是一个函数式接口,因此可使用 Lambda表达式来代替 Comparator对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">M</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;M[age:&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		此处的Lambda表达式的目标类型是Comparator</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>((o1, o2) -&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">m1</span> <span class="operator">=</span> (M) o1;</span><br><span class="line">			<span class="type">var</span> <span class="variable">m2</span> <span class="operator">=</span> (M) o2;</span><br><span class="line">			<span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span> : m1.age &lt; m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(<span class="number">5</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(-<span class="number">3</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(<span class="number">9</span>));</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字代码使用了目标类型为 Comparator的 Lambda表达式,它负责ts集合的排序所以当把M对象添加到ts集合中时,无须M类 Comparable实现接口,因为此时 TreeSet无须通过l对象本身来比较大小,而是由与 TreeSet关联的 Lambda表达式来负责集合元素的排序。运行程序,看到如下运行结果:</p>
<p> [M [age: 9], M [age: 5], M [age: -3]</p>
<p>注意:当通过 Comparator对象(或 Lambda表达式)来实现 TreeSet的定制排序时,依然不可以向 TreeSet中添加类型不同的对象,否则会引发 ClassCastException异常。使用定制排序时, TreeSet对集合元素排序不管集合元素本身的大小,而是由 Comparator对象(或 LambdaTreeSet表达式)负责集合元素的排序规则。判断两个集合元素相等的标准是:通过Comparator(或 Lambda表达式)比较两个元素返回了0,这样TreeSet不会把第二个元素添加到集合中。</p>

        <h3 id="8-3-4-EnumSet类"   >
          <a href="#8-3-4-EnumSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-4-EnumSet类" class="headerlink" title="8.3.4 EnumSet类"></a>8.3.4 EnumSet类</h3>
      <p> EnumSet是一个专为枚举类设计的集合类, EnumSet中的所有元素都必须是指定枚举类型的枚举值，集合该枚举类型在创建 EnumSet时显式或隐式地指定。 EnumSet的集合元素也是有序的, EnumSet以枚举值在Enum类内的定义顺序来决定集合元素的顺序。</p>
<p> EnumSet中的内部以位向量的形式存储,这种存储形式非常紧凑、高效，因此  EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作(如调用containsAll()和 retainAll()方法)时,如果其参数也是 EnumSet集合,则该批量操作的执行速度也非常快。</p>
<p> EnumSet集合不允许加入null元素,如果试图插入null元素, EnumSet将抛出 NullPointerEXce异常。如果只是想判断 EnumSet是否包含null素或试图删除null元素都不会抛出异常,只是删除操作将返回 false,因为没有任何nul元素被删除。</p>
<p> EnumSet类没有暴露任何构造器来创建该类的实例,程序应该通过它提供的类方法来创建 EnumSet对象。 EnumSet类它提供了如下常用的类方法来创建 EnumSet对象。</p>
<ul>
<li>EnumSet allOf(Class elementType):创建一个包含指定枚举类里所有枚举值的 EnumSet集合。</li>
<li>EnumSet complementOf(EnumSet):创建一个其元素类型与指定 EnumSet里元素类型相同的EnumSet集合,新 EnumSet集合包含原 EnumSet集合所不包含的、此枚举类剩下的枚举值(即新 EnumSet集合和原 EnumSet集合的集合元素加起来就是该枚举类的所有枚举值)。</li>
<li>EnumSet copyOf(Collection c):使用一个普通集合来创建 EnumSet集合。</li>
<li>EnumSet copyOf(EnumSet f):创建一个与指定 EnumSet 具有相同元素类型、相同集合元素的 EnumSet集合。</li>
<li>EnumSet noneOf(Class elementType):创建一个元素类型为指定枚举类型的空 EnumSet。</li>
<li>EnumSet of(E first,elementType):创建一个包含一个或多个枚举值的 EnumSet集合,传入的多个枚举值必须属于同一个枚举类。</li>
<li>EnumSet range(E from,E to):创建一个包含从 from 枚举值到 to 枚举值范围内所有枚举值的EnumSet集合。</li>
</ul>
<p>下面程序示范了如何使用 EnumSet来保存枚举类的多个枚举值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span></span><br><span class="line">&#123;</span><br><span class="line">	SPRING,SUMER,FALL,WINTER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSetTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es1</span> <span class="operator">=</span> EnumSet.allOf(Season.class);</span><br><span class="line">		System.out.println(es1);</span><br><span class="line"><span class="comment">//		创建一个空EnumSet集合，集合元素就是Season的枚举类</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es2</span> <span class="operator">=</span> EnumSet.noneOf(Season.class);</span><br><span class="line">		System.out.println(es2);</span><br><span class="line"><span class="comment">//		手动添加两个元素</span></span><br><span class="line">		es2.add(Season.FALL);</span><br><span class="line">		es2.add(Season.SPRING);</span><br><span class="line">		System.out.println(es2);</span><br><span class="line"><span class="comment">//		以指定枚举值创建EnumSet集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es3</span> <span class="operator">=</span> EnumSet.of(Season.FALL,Season.SPRING);</span><br><span class="line">		System.out.println(es3);</span><br><span class="line"><span class="comment">//		EnumSet range(E from,E to):创建一个包含从 from 枚举值到 to 枚举值范围内所有枚举值的EnumSet集合。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es4</span> <span class="operator">=</span> EnumSet.range(Season.SUMER, Season.WINTER);</span><br><span class="line">		System.out.println(es4);</span><br><span class="line"><span class="comment">//		新创建的EnumSet集合元素和es4集合元素有相同的类型</span></span><br><span class="line"><span class="comment">//		es5集合元素+es4集合元素 = season枚举类的全部枚举值</span></span><br><span class="line"><span class="comment">/*		EnumSet complementOf(EnumSet):创建一个其元素类型与指定 EnumSet里元素类型相同的EnumSet集合,</span></span><br><span class="line"><span class="comment"> * 		新 EnumSet集合包含原 EnumSet集合所不包含的、此枚举类剩下的枚举值</span></span><br><span class="line"><span class="comment"> * 		(即新 EnumSet集合和原 EnumSet集合的集合元素加起来就是该枚举类的所有枚举值)。*/</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">es5</span> <span class="operator">=</span> EnumSet.complementOf(es4);</span><br><span class="line">		System.out.println(es5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​	上面示范了EnumSet集合的常规用法。除此之外，还可以赋值另一个EnumSet集合中的所有元素来创建新的EnumSet集合。或者赋值另一个Collection集合中的所有元素来创建新的EnumSet集合。当复制Collection集合中的所有元素来创建新的EnumSet集合时，要求Collection集合中的所有元素必须是同一个枚举类的枚举值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSetTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		c.clear();</span><br><span class="line">		c.add(Season.FALL);</span><br><span class="line">		c.add(Season.SPRING);</span><br><span class="line"><span class="comment">//		复制Collection集合中的所有元素来创建EnumSet集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">enumSet</span> <span class="operator">=</span> EnumSet.copyOf(c);</span><br><span class="line">		System.out.println(enumSet);</span><br><span class="line">        <span class="comment">//当复制Collection集合中的所有元素来创建新的EnumSet集合时，要求Collection集合中的所有元素必须是同一个枚举类的枚举值。</span></span><br><span class="line">		c.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		c.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		enumSet = EnumSet.copyOf(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>当复制Collection集合中的所有元素来创建新的EnumSet集合时，要求Collection集合中的所有元素必须是同一个枚举类的枚举值。</p>

        <h3 id="8-3-5-各Set实现类的性能分析"   >
          <a href="#8-3-5-各Set实现类的性能分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-5-各Set实现类的性能分析" class="headerlink" title="8.3.5 各Set实现类的性能分析"></a>8.3.5 各Set实现类的性能分析</h3>
      <p> HashSet和 TreeSet是 Set 的两个典型实现,到底如何选择 HashSet和 TreeSet呢? HashSet的性能总是比 TreeSet好(特别是最常用的添加、查询元素等操作),因为 TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的 Set 时,应该使用 TreeSet,否则都应该使用 HashsSet。</p>
<p>HashSet还有一个子类: LinkedHashSet,对于普通的插入、删除操作, LinkedHashSet HashsSe要略微慢一点,这是由维护链表所带来的额外开销造成的,但由于有了链表,遍历 LinkedHashSet会更快。</p>
<p> EnumSet 是所有 Set 实现类中性能最好的,但它只能保存同一个枚举类的枚举值作为集合元素。</p>
<p>必须指出的是,Set的三个实现类 HashSet、 TreeSet和 EnumSet都是线程不安全的。如果有多个线程同时访问一个Set集合,并且有超过一个线程修改了该Set集合,则必须手动保证该Set集合的同步性。通常可以通过Collections工具类的 synchronizedSorte方法来“包装”该Set集合。此操作最好在创建时进行,以防止对Set集合的意外非同步访问。例如: SortedSet Collections. synchronizeds(new TreeSet (…))关于 Collections工具类的更进一步用法,可以参考8.8节的内容。</p>

        <h2 id="8-4List集合"   >
          <a href="#8-4List集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4List集合" class="headerlink" title="8.4List集合"></a>8.4List集合</h2>
      <p><strong>List集合代表一个元素有序、可重复的集合,集合中每个元素都有其对应的顺序索引。List集合许使用重复元素,可以通过索引来访问指定位置的集合元素。</strong>List集合默认按元素的添加顺序设置元素的索引,例如第一次添加的元素索引为0,第二次添加的元素索引为1。</p>

        <h3 id="8-4-1改进的List接口和-Listlterator接口"   >
          <a href="#8-4-1改进的List接口和-Listlterator接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4-1改进的List接口和-Listlterator接口" class="headerlink" title="8.4.1改进的List接口和 Listlterator接口"></a>8.4.1改进的List接口和 Listlterator接口</h3>
      <p>List作为 Collection接口的子接口,当然可以使用 Collection接口里的全部方法。而且由于List是有序集合,因此List集合里增加了一些根据索引来操作集合元素的方法。</p>
<ul>
<li>void add (int index, Object element):将元素 element插入到List集合的 index处</li>
<li>boolean addAll(int index, Collection)将集合c所包含的所有元素都插入到List集合的 index处。</li>
<li>Object get(int index):返回集合 index索引处的元素。 </li>
<li>int indexOf(Object):返回对象o在List集合中第一次出现的位置索引。</li>
<li>int lastIndexOf(Object):返回对象o在Lis集合中最后一次出现的位置索引。</li>
<li>Object remove(int index):删除并返回 index索引处的元素。</li>
<li>Object set(int index, Object element:将 index索引处的元素替换成 element对象,返回被替换的旧元素。</li>
<li>List subList(int fromIndex, int toIndex:返回从索引 fromIndex(包含)到索引 oIndex(不包含)处所有集合元素组成的子集合。</li>
</ul>
<p>所有的List实现类都可以调用这些方法来操作集合元素。与Set集合相比,List增加了根据索弘来插入、替换和删除集合元素的方法。除此之外,Java8还为List接口添加了如两今默认方法：</p>
<ul>
<li>void replaceAlUnaryOperator( operator):根据 operator指定的计算规则重新设置List集合的所有元素。</li>
<li>void sort(Comparator c):根据 Comparator参数对List集合的元素排序。</li>
</ul>
<p>下面程序示范了List集合的常规用法:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//		向books集合中添加三个元素</span></span><br><span class="line">		books.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;智&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;超&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		将新的字符串对象插入到第二个元素</span></span><br><span class="line">		books.add(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; books.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(books.get(i));</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		删除第三个元素</span></span><br><span class="line">		books.remove(<span class="number">2</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		判断指定元素在List集合中的位置：输出1，表明位于第二位</span></span><br><span class="line"><span class="comment">//		使用new创建的新对象，通过equals()方法比较返回true</span></span><br><span class="line">		System.out.println(books.indexOf(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>)));</span><br><span class="line"><span class="comment">//		使用字符串本身来判断</span></span><br><span class="line">		System.out.println(books.indexOf(<span class="string">&quot;超&quot;</span>));</span><br><span class="line"><span class="comment">//		将第二个元素替换成新的字符串对象</span></span><br><span class="line">		books.set(<span class="number">1</span>, <span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		将books集合的第二个元素</span></span><br><span class="line"><span class="comment">//		到第三个元素（不包括）截取成子集合</span></span><br><span class="line">		System.out.println(books.subList(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>示范了List的规范用法，List集合可以根据位置索引来访问集合中的元素，因此List增加了一种新的遍历集合元素的方法：使用普通的for循环来遍历集合元素。</p>
<p>注意①，也是通过new关键字创建的新字符串对象，两个字符串明显不是同一个对象，但是List的indexOf()方法依旧可以返回1，List判断两个对象相等的标准是什么？List判断两个对象相等只需要通过equals()方法比较返回true即可。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//		向books集合中添加三个元素</span></span><br><span class="line">		books.add(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;智&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;超&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		删除集合中A的对象，将导致第一个元素被删除</span></span><br><span class="line">		books.remove(<span class="keyword">new</span> <span class="title class_">A1</span>());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">		books.remove(<span class="keyword">new</span> <span class="title class_">A1</span>());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>执行删除代码时，程序试图删除A中的一个对象，List将会调用该A对象的equals()方法依次与集合元素进行比较，如果该equals()方法以某个元素作为参数时返回true，List将会删除该元素。</p>
<p>注意：当调用List的set方法通过改变List集合指定索引处的元素时，指定的索引必须是有效地索引，也就是说set方法不可以改变集合的索引。</p>
<p>Java8为List集合增加了 sort和 replaceAll()两个常用的默认方法,其中 sort方法需要一个Comparator 对象来控制元素排序,程序可使用 Lambda表达式来作为参数;而方法则需要一个 UnaryOperator来替换所有集合元素，UnaryOperator也是一个函数式接口,因此程序也可使用 Lambda表达式作为参数。如下程序示范了List集合的两个默认方法的功能。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级java EE 企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Androiod讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		使用目标类型为Comparator的Lambda表达式对List集合排序</span></span><br><span class="line">		books.sort((o1,o2)-&gt;((String)o1).length() - ((String)o2).length());<span class="comment">//①</span></span><br><span class="line">		System.out.println(books);</span><br><span class="line"><span class="comment">//		使用目标类型为UnaryOperator的Lambda表达式来替换集合中的所有元素</span></span><br><span class="line"><span class="comment">//		该Lambda表达式控制使用每个字符串的长度作为新的元素</span></span><br><span class="line">		books.replaceAll(ele -&gt; ((String)ele).length());<span class="comment">//2</span></span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>1代码控制对List集合进行排序，传给sort()方法的Lambda表达式指定的排序规则是：字符串程度越长，字符串越大。所以执行完后，List集合中的字符串惠安由短到长的顺序排序。</p>
<p>程序中2代码传给 replaceAll()方法的 Lambda表达式指定了替换集合元素的规则:直接用集合元素(字符串)的长度作为新的集合元素执行该方法后,集合元素被替换为[7,8,11,16]。</p>
<p>与Set只提供了一个 iterator()方法不同,List还额外提供了一个 listIterator()方法,该方法返回一个ListIterator, ListIterator接口继承了 Iterator接口，提供了专门操作List的方法 ListIterator接口在Iterator接口基础上增加了如下方法。</p>
<ul>
<li>boolean hasPrevious()：返回该迭代器关联的集合是否还有上一个元素。</li>
<li>Object previous()：返回该迭代器的上一个元素。</li>
<li>void add(Object)：在指定位置插入一个元素。</li>
</ul>
<p>拿 ListIterator与普通的 Iterator进行对比不难发现 ListIterator增加了向前迭代的功能(Iterator只能向后迭代),而且ListIterator还可通过add方法向List集合中添加元素(terator只能删除元素)下面程序示范了 ListIterator的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] books = &#123;</span><br><span class="line">				<span class="string">&quot;疯狂java讲义&quot;</span>,<span class="string">&quot;疯狂iOS讲义&quot;</span>,</span><br><span class="line">				<span class="string">&quot;轻量级java EE 企业应用实战&quot;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">bookList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;books.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			bookList.add(books[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">var</span> <span class="variable">lit</span> <span class="operator">=</span> bookList.listIterator();</span><br><span class="line"><span class="comment">//		从前向后遍历</span></span><br><span class="line">		<span class="keyword">while</span>(lit.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(lit.next());</span><br><span class="line">			System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;=========下面开始方向迭代===========&quot;</span>);</span><br><span class="line"><span class="comment">//		从后往前遍历</span></span><br><span class="line">		<span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(lit.previous());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>开始也需要采用正向迭代，即先使用next()方法进行迭代，在迭代过程中可以使用add()方法向上一次迭代元素的后面添加一个新元素。</p>

        <h3 id="8-4-2-ArrayLISt和Vector实现类"   >
          <a href="#8-4-2-ArrayLISt和Vector实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4-2-ArrayLISt和Vector实现类" class="headerlink" title="8.4.2 ArrayLISt和Vector实现类"></a>8.4.2 ArrayLISt和Vector实现类</h3>
      <p>ArrayList 和 Vector作为List类的两个典型实现,完全支持前面介绍的List接口的全部功能。</p>
<p>ArrayList和 Vector类都是基于数组实现的List类,所以ArrayList和 Vector类封装了一个动态的、允许再分配的 Object数组。 ArrayList或 Vector对象使用 initialCapacity参数来设置该数组的长度,当向 ArrayList或 Vector中添加元素超出了该数组的长度时,它们的 initialCapacity会自动增加。</p>
<p>对于通常的编程场景,程序员无须关心 ArrayList或 Vector的 initialCapacity但如果向 ArrayList或 Vector集合中添加大量元素时,可使用 ensureCapacity(int minCapacity)方法一次性地增加 initialCapacity 这可以减少重分配的次数,从而提高性能。</p>
<p>如果开始就知道 ArrayList或 Vector集合需要保存多少个元素,则可以在创建它们时就指定 initialCapacity大小。如果创建空的 ArrayList或 Vector集合时不指定 initialCapacity参数,则Object数组的长度默认为10。</p>
<p>ArrayList和 Vector还提供了如下两个方法来重新分配 Object数组</p>
<ul>
<li>void ensureCapacity(int minCapacity):将 ArrayList或 Vector集合的 Object数组长度增加大于或等于 minCapacity值。</li>
<li>void trimToSize:调整 ArrayList或 Vector集合的 Object[]数组长度为当前元素的个数。调用该方法可减少 ArrayList或 Vector集合对象占用的存储空间。</li>
</ul>
<p> ArrayList和 Vector在用法上几乎完全相同,但由于 Vector是一个古老的集合(从DK1.0就有了），那时候Java还没有提供系统的集合框架,所以 Vector里提供了一些方法名很长的方法,例如 addElement(Object obj),实际上这个方法与add(Object obj)没有任何区别。从JDK1.2以后,Java提供了系统的集合框架,就将 Vector改为实现List接口,作为List的实现之一,从而导致 Vector里有一些功能重复的方法。</p>
<p> Vector的系列方法中方法名更短的方法属于后来新增的方法,方法名更长的方法则是 Vector原有的方法。Java改写了 Vector原有的方法,将其方法名缩短是为了简化编程。而 ArrayList开始就作为List的主要实现类,因此没有那些方法名很长的方法。实际上, Vector具有很多缺点,通常尽量少用 Vector实现类。</p>
<p>除此之外, ArrayList和 Vector的著区别是: ArrayList是线程不安全的,当多个线程访问同一个 ArrayList集合时,如果有超过一个线程修改了 ArrayList集合,则程序必须手动保证该集合的同步性;但 Vector集合则是线程安全的,无须程序保证该集合的同步性。因为 Vector是线程安全的,所以Vector的性能比 ArrayList的性能要低。实际上,即使需要保证List集合线程安全,也同样不推荐使用 Vector后面会介绍一个Collections工具类,它可以将一个 ArrayList变成线程安全的。</p>
<p> Vector还供了一个 Stack子类,它用于模拟“栈”这种数据结构,“栈通常是指“后进先出”(LFO)的容器。最后“push”进桟的元素,将最先被“pop”出与Java中的其他集合一样,进栈出栈的都是 Object,因此从栈中取出元素后必须进行类型转换,除非你只是使用 Object 具有的操作。所以Stack类里提供了如下几个方法。</p>
<ul>
<li>Object peek():返回“栈”的第一个元素,但并不将该元素“pop”出栈</li>
<li>Object pop():返回“栈”的第一个元素并将该元素“pop”出栈。</li>
</ul>
<p>需要指出的是,由于 Stack继承了 Vector,因此它也是一个非常古老的Java集合类,它同样是线程安全的、性能较差的,因此应该尽量少用 Stack。如果程序需要使用“栈”这种数据结构,建议使用队列，后面将要介绍的 ArrayDeque代替它。</p>

        <h3 id="8-4-3-固定长度的List"   >
          <a href="#8-4-3-固定长度的List" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-4-3-固定长度的List" class="headerlink" title="8.4.3 固定长度的List"></a>8.4.3 固定长度的List</h3>
      <p>前面讲数组时介绍了一个操作数组的工具类：Ayyars，该工具类里提供了 asList(Object..a)方法,该方法可以把一个数组或指定个数的对象转换成一个List集合,这个List集合既不是 Array List实现类的实例,也不是 Vector实现类的实例,而是 Arrays的内部类 ArrayList的实例。</p>
<p>Arrays.ArrayList是一个固定长度的List集合程序只能遍历访问该集合里的元素,不可增加、删除该集合的元素</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIxedSizeList</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">fixedList</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;疯狂Java讲义&quot;</span></span><br><span class="line">				+ <span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line"><span class="comment">//		获取fixedList的实现类，将输出ArraysArrayList</span></span><br><span class="line">		System.out.println(fixedList.getClass());</span><br><span class="line"><span class="comment">//		使用方法遍历集合元素</span></span><br><span class="line">		fixedList.forEach(System.out :: println);</span><br><span class="line"><span class="comment">//		试图修改集合元素都会引发异常</span></span><br><span class="line">		fixedList.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line">		fixedList.remove(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中两行粗体字代码对于普通的List集合完全正常,但如果试图通过这两个方法来增加、删除 Arrays$ArrayList集合里的元素,将会引发异常。所以上面程序在编译时完全正常,但会在运行第一行粗体字标识的代码行处引发 UnsupportedOperation Exception异常。</p>

        <h2 id="8-5-Queue集合"   >
          <a href="#8-5-Queue集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-Queue集合" class="headerlink" title="8.5 Queue集合"></a>8.5 Queue集合</h2>
      <p> <strong>Queue用于模拟队列这种数据结构,队列通常是指“先进先出”(FIFO)的容器。队列的头部保存在队列中存放时间最长的元素,队列的尾部保存在队列中存放时间最短的元素新元素插入(offer)到队列的尾部,访问元素(poll)操作会返回队列头部的元素。通常,队列不允许随机访问队列中的元素</strong></p>
<p> Queue接口中定义了如下几个方法。</p>
<ul>
<li>void add(Object c):将指定元素加入此队列的尾部。</li>
<li>Object element():获取队列头部的元素,但是不删除该元素。</li>
<li>boolean offer(Object c):将指定元素加入此队列的尾部。当使用有容量限制的队列时,此方法通常比add(Object c)方法更好。</li>
<li>Object peek()：获取队列头部的元素，但是不删除该元素。如果此队列为空,则返回null</li>
<li>Object poll()：获取队列头部的元素，并删除该元素。如果此队列为空,则返回nul</li>
<li>Object remove()：获取队列头部的元素，并删除该元素。</li>
</ul>
<p>Queue接口有一个 PriorityQueue实现类。除此之外, Queue还有一个 Deque接口, Deque代表一个“双端队列”,双端队列可以同时从两端来添加、删除元素,因此 Deque的实现类既可当成队列使用,也可当成桟使用。Java为 Deque提供了 ArrayDeque和 LinkedList两个实现类</p>

        <h3 id="8-5-1-PriorityQueue实现类"   >
          <a href="#8-5-1-PriorityQueue实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-1-PriorityQueue实现类" class="headerlink" title="8.5.1 PriorityQueue实现类"></a>8.5.1 PriorityQueue实现类</h3>
      <p>PriorityQueue是一个&#x3D;&#x3D;比较标准的队列实现类&#x3D;&#x3D;。之所以说它是比较标准的队列实现,而不是绝对标准的队列实现,是因为 &#x3D;&#x3D;PriorityQueue保存队列元素的顺序并不是按加入队列的顺序,而是按队列元素的大小进行重新排序&#x3D;&#x3D;。因此当调用 peek方法或者 pollo方法取出队列中的元素时,并不是取出最先进入队列的元素,而是取出队列中最小的元素。从这个意义上来看, PriorityQueue已经违反了队列的最基本规则:先进先出(FIFO)下面程序示范了 PriorityQueue队列的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line"><span class="comment">//		下面代码依次向pq加入四个元素</span></span><br><span class="line">		pq.add(<span class="number">9</span>);</span><br><span class="line">		pq.add(-<span class="number">3</span>);</span><br><span class="line">		pq.add(<span class="number">20</span>);</span><br><span class="line">		pq.add(<span class="number">18</span>);</span><br><span class="line"><span class="comment">//		输出pq队列，并不是按元素的加入顺序排列</span></span><br><span class="line">		System.out.println(pq);</span><br><span class="line">		System.out.println(pq.poll());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行上面程序直接输出 PriorityQueue 集合时，可能看到该队列里的元素并没有很好地按大小进行排序,但这只是受到PriorityQueue的 toString() 方法返回值的影响实际上,程序多次调用 PriorityQueue集合对方法可看到元素按从小到大的顺序“移出队列”。</p>
<p>PriorityQueue不允许插入null元素,它还需要对队列元素进行排序, PriorityQueue的元素有两种排序方式。</p>
<ul>
<li>自然排序：采用自然顺序的 PriorityQucue集合中的元素必须实现了 Compar是同一个类的多个实例,否则可能导致 ClassCastE xception异常</li>
<li>定制排序：创建 PriorityQueue列时,传入一个 Comparator对象,该对象负责对队序方式。元素进行排序。采用定制排序时不要求队列元素实现 Comparable接口。</li>
</ul>
<p>PriorityQucue素的要求与 Treset对元素的要求基本一致,因此关于使用自然排序和定制排序的详细介绍请参考8.33节。</p>

        <h3 id="8-5-2-Deque接口与-ArrayDeque实现类"   >
          <a href="#8-5-2-Deque接口与-ArrayDeque实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-2-Deque接口与-ArrayDeque实现类" class="headerlink" title="8.5.2 Deque接口与 ArrayDeque实现类"></a>8.5.2 Deque接口与 ArrayDeque实现类</h3>
      <p>Deque接口是Queue接口的子接口,它代表一个双端队列, Deque接口里定义了一些双端队列的方法,这些方法允许从两端来操作队列的元素。</p>
<ul>
<li><p>void addFirst(Object e)：将指定元素插入该双端队列的开头。</p>
</li>
<li><p>void addLast(Object e)：将指定元素插入该双端队列的末尾。</p>
</li>
<li><p>Iterator descendinglterator()：返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。</p>
</li>
<li><p>Object getFirst()：获取但不删除双端队列的第一个元素。</p>
</li>
<li><p>Object getLast()):获取但不删除双端队列的最后一个元素。</p>
</li>
<li><p>boolean offerfirst(Object e)：将指定元素插入该双端队列的开头。</p>
</li>
<li><p>boolean offerLast(Object e)：将指定元素插入该双端队列的末尾。</p>
</li>
<li><p>Object peekFirst()：获取但不删除该双端队列的第一个元素;如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object peekLast()：获取但不删除该双端队列的最后一个元素:如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object pollFirst()：获取并删除该双端队列的第一个元素;如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object pollLast()：获取并删除该双端队列的最后一个元素:如果此双端队列为空,则返回null。</p>
</li>
<li><p>Object pop(栈方法)：pop出该双端队列所示的栈的栈顶元素。相当于 removeFirst()。</p>
</li>
<li><p>void push(Object c)(栈方法):将一个元素push进该双端队列所表示的栈的栈顶 。相当于addFirst(e)。</p>
</li>
<li><p>Object removeFirst()：获取并删除双端队列的第一个元素。</p>
</li>
<li><p>Object removeFirstOccurrence(Objecet o)：删除该双端队列的第一次出现的元素o。</p>
</li>
<li><p>Object removeLast()：获取并删除双端队列的最后一个元素。</p>
</li>
<li><p>Object removeListOccurrence(Objecet o)：删除该双端队列的第一次出现的元素o。</p>
</li>
</ul>
<p>Dequq不仅可以当成双端队列使用，而且可以被当成栈使用，因为该类力还包含了pop（出栈）、push（入栈）两个方法。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>Queue的方法</th>
<th>Deque的方法</th>
</tr>
</thead>
<tbody><tr>
<td>add(e)&#x2F;offer(e)</td>
<td>addLast(e)&#x2F;addFirst(e)</td>
</tr>
<tr>
<td>remove()&#x2F;poll()</td>
<td>removeFirst()&#x2F;pollFirst()</td>
</tr>
<tr>
<td>element()&#x2F;peek()</td>
<td>getFirst()&#x2F;peekFirst()</td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>Stack的方法</th>
<th>Deque的方法</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFirst(e)&#x2F;offerFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()&#x2F;pollFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>getFirst()&#x2F;peekFirst()</td>
</tr>
</tbody></table></div>
<p>Deque接口提供了一个典型的实现类ArrayDeque，从名称则可以看出，他是一个基于数组实现的双端队列，创建Deque时同样可以指定一个nujmElements参数，该参数用于指定Object[]数组的长度，</p>
<p>下面示范了把ArrayDeque当成“栈”来使用：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDequeTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">		stack.push(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		stack.add(<span class="string">&quot;轻量级&quot;</span>);</span><br><span class="line">		stack.push(<span class="string">&quot;疯狂讲义&quot;</span>);</span><br><span class="line">		System.out.println(stack);</span><br><span class="line"><span class="comment">//		访问第一个元素，但不将其pop出栈</span></span><br><span class="line"><span class="comment">//		当成栈使用</span></span><br><span class="line">		System.out.println(stack.peek());</span><br><span class="line"><span class="comment">//		依次输出</span></span><br><span class="line">		System.out.println(stack);</span><br><span class="line">		System.out.println(stack.pop());</span><br><span class="line">		System.out.println(stacka);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>当需要栈这种结构时，推荐使用“ArrayQeque”，尽量避免使用Stack——因为Stack是古老的集合，性能差。</p>
<p>ArrayDeque将按“先进先出”的方式操作集合元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDequeQueueTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">ArrayDeque</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line"><span class="comment">//		依次将三个元素插入队列</span></span><br><span class="line">		queue.offer(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		queue.offer(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		queue.offer(<span class="string">&quot;讲义&quot;</span>);</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		System.out.println(queue.peek());</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		System.out.println(queue.poll());</span><br><span class="line">		System.out.println(queue);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210417120831241](C:\Program Files\Typora\image\image-20210417120831241.png)ArrayDeque不仅可以作为栈使用，也可以作为队列使用。</p>

        <h3 id="8-5-3-LinkedList-实现类"   >
          <a href="#8-5-3-LinkedList-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-3-LinkedList-实现类" class="headerlink" title="8.5.3 LinkedList 实现类"></a>8.5.3 LinkedList 实现类</h3>
      <p>LinkedList类是一个List实现类——这就意味着他是一个LIst集合，也可以根据索引来随机访问集合中的元素。除此之外，LinkedList还是先了Deque接口，可以被当成双端队列来使用，因此既可以被当成“栈”来使用，也可以当成队列来使用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">		books.offer(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		books.push(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">		books.offerFirst(<span class="string">&quot;讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		以Link的方式（按索引的方式）来遍历集合元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;books.size();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;遍历中:&quot;</span>+books.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(books.peekFirst());</span><br><span class="line"><span class="comment">//		访问并不删除队列的最后一个元素</span></span><br><span class="line">		System.out.println(books.peekLast());</span><br><span class="line"><span class="comment">//		将栈顶的元素导出栈</span></span><br><span class="line">		System.out.println(books.pop());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">		System.out.println(books.pollLast());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>分别示范了LinkedList作为List集合、双端队列、栈的用法。由此可见LinkedList是一个功能强大的集合类。</p>
<p> LinkedList与 ArrayList、 ArrayDeque的实现机制完全不同, ArrayList、 ArrayDeque内部以数组的形式来保存集合中的元素,因此随机访问集合元素时有较好的性能;而 LinkedList内部以链表的形式来保存集合中的元素,因此随机访问集合元素时性能较差但在插入、删除元素时性能比较出色(只改变指针所指的地址即可)。需要指出的是,虽然Vector也是以数组的形式来存储集合元素的,但因它实现了线程同步功能(而且实现机制也不好),所以各方面性能都比较差。</p>
<p>注意：对于所有的内部基于数组的集合实现,例如ArrayList、ArrayDque等,使用随机访问的性能比使用 Iterator迭代访问的性能要好,因为随机访问会被映射成对数组元素的访问。</p>

        <h3 id="8-5-4各种线性表的性能分析"   >
          <a href="#8-5-4各种线性表的性能分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-5-4各种线性表的性能分析" class="headerlink" title="8.5.4各种线性表的性能分析"></a>8.5.4各种线性表的性能分析</h3>
      <p>Java提供的List就是一个线性表接口,而ArrayList、 LinkedList又是线性表的两种典型实现:基于数组的线性表和基于链的线性表。 Queue代表了队列 Deque代表了双端队列(既可作为队列使用,也可作为栈使用),接下来对各种实现类的性能进行分析。</p>
<p>初学者可以无须理会 ArrayList和 LinkedList之间的性能差异,只需要知道 LinkedList集合不仅提供了List的功能,还提供了双端队列、栈的功能就行。但对于一个成熟的Java程序员,在一些性能非常敏感的地方,可能需要慎重选择哪个List实现。</p>
<p>一般来说,由于数组以一块连续内存区来保存所有的数组元素,所以数组在随机访问时性能最好,所有的内部以数组作为底层实现的集合在随机访问时性能都比较好;而内部以链表作为底层实现的集合在执行插入、删除操作时有较好的性能。但总体来说, ArrayList的性能比 LinkedList的性能要好,因此大部分时候都应该考虑使用 ArrayList</p>
<p>关于使用List集合有如下建议。</p>
<ul>
<li>如果需要遍历List集合元素,对于 Arrayis Vector集合,应该使用随机访问方法(get)来遍历集合元素,这样性能更好;对于 LinkedList集合,则应该采用迭代器(Iterator)来遍历集合</li>
<li>如果需要经常执行插入、删除操作来改变包含大量数据的List集合的大小,可考虑使用元素。LinkedList集合。使用 ArrayList、 Vector集合可能需要经常重新分配内部数组的大小,效果可能较差。</li>
<li>如果有多个线程需要同时访问List集合中的元素,开发者可考虑使用 Collections将集合包装成线程安全的集合。</li>
</ul>

        <h2 id="8-6增强的Map集合"   >
          <a href="#8-6增强的Map集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6增强的Map集合" class="headerlink" title="8.6增强的Map集合"></a>8.6增强的Map集合</h2>
      <p>Map用于保存具有映射关系的数据，因此Map集合里保存着两组值，一组用于保存Map里的key，另一组值用于保存Map里的value，key和value都可以是任何引用类型的数据，Map的key不允许重复，即同一个Map对象的任何两个key通过equal方法比较总返回false。</p>
<p>![](C:\Program Files\Typora\image\微信图片_20210417135403.jpg)</p>
<p>果需要从List集合中取出元素,则需要提供该元素的数字索引;如果需要从Map中取出元素,则需提供该元素的key索引。因此,Map有时也被称为字典,或关联数组Map接口中定义了如下常方法</p>
<ul>
<li>&gt;void clear:删除该Map对象中的所有key -value-对。</li>
<li>&gt;boolean containsKey(Object key):查询Map中是否包含指定的key,如果包含则返回true</li>
<li>&gt;boolean contains Value(Object value):查询Map中是否包含一个或多个 value,如果包含则返回</li>
<li>&gt;Set entrySet:返回Map中包含的key-vale对所组成的Set集合,每个集合元素都是Map.Entry（Entry是Map的内部类)对象。</li>
<li>&gt;Object get(Object key):返回指定key所对应的vale;如果此Map中不包含该key,则返回null</li>
<li>&gt;boolean is Empty:查询该Map是否为空(即不包含任何key -value-对),如果为空则返回true</li>
<li>&gt;Set keySet:返回该Map中所有key组成的Set集合。</li>
<li>&gt;Object put(Object key, Object value):添加一个ky-vaue对,如果当前Map中已有一个与该key相等的key- value对,则新的key- value对会覆盖原来的key- -value对。</li>
<li>&gt;void putAll(MMapm):将指定Map中的key- -value对复制到本Map中</li>
<li>&gt;Object remove(Object key):删除指定key所对应的key- -value对,返回被删除key所关联的 value如果该key不存在,则返回null</li>
<li>&gt;boolean remove(Object key, Object value):是Java8新增的方法,删除指定key-value所对应的key- -value对。如果从该Map中成功地删除该ey- -value对,该方法返回true,否则返回 false</li>
<li>&gt;int size:返回该Map里的key -value-对的个数。</li>
<li>&gt;Collection values:返回该Map里所有 value组成的 Collection</li>
</ul>
<p>Map接口提供了大量的实现类,典型实现如 HashMap和 Hashtable等、 HashMap的子类LinkedHashMap,还有 SortedMap子接口及该接口的实现类 TreeMap,以及 WeakHashMap、IdentityHashMap等下面将详细介绍Map接口实现类。</p>
<p>Map中包括一 Entry个内部类,该类封装了一个key -value-对 Entry包含如下三个方法。</p>
<ul>
<li>&gt;Object getKey:返回该 Entry里包含的key值。</li>
<li>&gt;Object get Value:返回该 Entry里包含的 value值。</li>
<li>&gt;Object set Value( value):设置该 Entry里包含的 value值,并返回新设置的 value值。</li>
</ul>
<p>Map集合最典型的用法就是成对地添加、删除key- -value对,接下来即可判断该Map中是否包含指定key,是否包含指定 value,也可以通过Map提供的 keySet方法获取所有key组成的集合,进而遍历Map中所有的key- -value对。下面程序示范了Map的基本功能。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		成对放入多个key-value对</span></span><br><span class="line">		map.put(<span class="string">&quot;疯狂&quot;</span>, <span class="number">109</span>);</span><br><span class="line">		map.put(<span class="string">&quot;java&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		map.put(<span class="string">&quot;讲义&quot;</span>, <span class="number">108</span>);</span><br><span class="line">		map.put(<span class="string">&quot;张智超·&quot;</span>, <span class="number">107</span>);</span><br><span class="line">		System.out.println(map.put(<span class="string">&quot;java&quot;</span>, <span class="number">107</span>));</span><br><span class="line">		System.out.println(map);</span><br><span class="line">		System.out.println(map.containsKey(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">		System.out.println(map.containsValue(<span class="number">107</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> key : map.keySet())</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			map.get(key)方法获取指定key对应的value</span></span><br><span class="line">			System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+map.get(key));</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		根据key来删除value</span></span><br><span class="line">		map.remove(<span class="string">&quot;讲义&quot;</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>添加key-value对是，Map允许多个value重复，但如果添加key-value对时Map已经有重复的key，那么新添加value会覆盖该key原来对应的value，该方法将会返回被覆盖的value。</p>
<p>Map实现类重写了toString()方法，调用Map对象的toString()方法总是返回键值对的形式。</p>

        <h3 id="8-6-1-Java-8为Map新增的方法"   >
          <a href="#8-6-1-Java-8为Map新增的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-1-Java-8为Map新增的方法" class="headerlink" title="8.6.1 Java 8为Map新增的方法"></a>8.6.1 Java 8为Map新增的方法</h3>
      <p>![](C:\Program Files\Typora\image\fbf7c155315178ab3a2b30f83b79c11.jpg)</p>
<p>replaceAll(BiFunction Function)：该方法使用BiFunction对原key-value对执行计算，并将计算结果作为该键值对的value值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		成对放入多个key-value对</span></span><br><span class="line">		map.put(<span class="string">&quot;疯狂java讲义&quot;</span>, <span class="number">109</span>);</span><br><span class="line">		map.put(<span class="string">&quot;疯狂iOS讲义&quot;</span>, <span class="number">99</span>);</span><br><span class="line">		map.put(<span class="string">&quot;疯狂Ajax&quot;</span>,<span class="number">79</span>);</span><br><span class="line"><span class="comment">//		尝试替换key为“疯狂XML讲义”的value，由于原Map中没有对应的key</span></span><br><span class="line"><span class="comment">//		因此Map没有改变，没有添加新的键值对</span></span><br><span class="line">		map.replace(<span class="string">&quot;疯狂XML讲义&quot;</span>, <span class="number">66</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line"><span class="comment">//		使用原value与传入参数计算出来的结果覆盖原有的value</span></span><br><span class="line">		map.merge(<span class="string">&quot;疯狂iOS讲义&quot;</span>, <span class="number">10</span>,</span><br><span class="line">				(oldVal,param)-&gt;(Integer)oldVal +(Integer)param);</span><br><span class="line">		System.out.println(map);</span><br><span class="line"><span class="comment">//		当key为“Java”对应的value为null是，使用计算的结果作为新的value</span></span><br><span class="line">		map.computeIfAbsent(<span class="string">&quot;Java&quot;</span>, key-&gt;((String)key).length());</span><br><span class="line">		System.out.println(map);</span><br><span class="line">		map.computeIfPresent(<span class="string">&quot;Java&quot;</span>, (key,value)-&gt;(Integer)value*(Integer)value);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210417162717188](C:\Program Files\Typora\image\image-20210417162717188.png)</p>

        <h3 id="8-6-2-改进的-HashMap-和-Hashtable-实现类"   >
          <a href="#8-6-2-改进的-HashMap-和-Hashtable-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-2-改进的-HashMap-和-Hashtable-实现类" class="headerlink" title="8.6.2 改进的 HashMap 和 Hashtable 实现类"></a>8.6.2 改进的 HashMap 和 Hashtable 实现类</h3>
      <p>HashMap和Hashtable都是Map接口的典型实现类，他们之间的关系完全类似于ArrayList和Vector的关系：Hashtable是一个古老的Map实现类，它从JDK1.0就开始了，但它出现时，Java还没提供Map接口</p>
<p>由于HashMap中的key不能重复，所以HashMap中只能有一个key为null，但是可以有无数个key-value对的value为null，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullInHashMap</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		试图将两个key为null值的key-value对放入HashMap中</span></span><br><span class="line">		hm.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">		hm.put(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//		讲一个value为null的值放入HashMap</span></span><br><span class="line">		hm.put(<span class="string">&quot;a&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">		System.out.println(hm);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了成功的在HashMap、Hashtable中储存、获取对象，用作key的对象必须事先hashCode()方法和equals()方法。</p>
<p>与HashSet集合保证元素的顺序一样，HashMap、Hashtable也不能保证其中的key-value对的顺序。类似于HashSet、HashMap、Hashtable判断两个key相等的标准也是：两个key通过equals()方法比较返回true，两个key的hashCode()值也相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A9</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A9</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="built_in">this</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == A.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> (A9) obj;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.count == a.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	重写了equals方法，b对象与任何对象通过equals方法比较都返回ture</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashtableTset</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">6000</span>), <span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>), <span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">1232</span>), <span class="keyword">new</span> <span class="title class_">B2</span>());</span><br><span class="line">		System.out.println(ht);</span><br><span class="line"><span class="comment">//		只要两个对象通过equals()方法比较返回true</span></span><br><span class="line"><span class="comment">//		Hashtable就认为他们是相等的value</span></span><br><span class="line">		System.out.println(ht.containsValue(<span class="string">&quot;测试字符串&quot;</span>));</span><br><span class="line"><span class="comment">//		只要两个A对象的count相等，他们他们通过equals()返回true，而且hashCode值相等</span></span><br><span class="line">		System.out.println(ht.containsKey(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>)));</span><br><span class="line">		ht.remove(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">1232</span>));</span><br><span class="line">		System.out.println(ht);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面定义了A类和B类，其中A类判断两个A对象相等的标准是count实例变量：只要两个A对象的count变量相等，则通过equals()方法比较他们返回true，他们的hashCode值也相等：而B对象则可以与任何对象相等。</p>
<p>Hashtable判断value相等的标准是：value与另外一个对象通过equals()方法比较返回true即可，上满程序中的ht对象中包含了一个B对象，他与任何对象通过equals比较总会返回true，所以在①号粗体字代码处返回true。在这种情况下，不管传给ht对象的containtsValue()方法参数是上满，程序总返回true。</p>
<p>根据Hashtable判断两个key相等的标准，程序在2号也将返回true，且hashCode值相等，HashCode值相等，Hashtable即认为他们是同一个key，类似的是，程序在3也可以删除对应的键值对。</p>
<p>当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同。因为HashMap、Hashtable保存key的方式与HashSet保存集合元素的方式完全相等，所以HashMap、Hashtable对key的要求与HashSet对集合元素的要求相同。</p>
<p>与HashSet类似的是，如果使用可变对象作为HashMap、Hashtable的key，并且程序修改了作为key的可变对象，则也有可能出现于HashSet类似的情况：程序再也无法访问到Map中被修改过的key</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapErrorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//		此处的A类与前一个程序的A类是同一个类</span></span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">60000</span>), <span class="string">&quot;疯狂java讲义&quot;</span>);</span><br><span class="line">		ht.put(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>), <span class="string">&quot;轻量级Java EE 企业应用实战&quot;</span>);</span><br><span class="line"><span class="comment">//		获取Hashtable的key Set集合对应的Iterator迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> ht.keySet().iterator();</span><br><span class="line"><span class="comment">//		取出Map中第一个key，并修改它的count值</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> (A9) it.next();</span><br><span class="line">		first.count = <span class="number">87563</span>;</span><br><span class="line">		System.out.println(ht);</span><br><span class="line"><span class="comment">//		只能删除没有修改过的key所对应的key-value对</span></span><br><span class="line">		ht.remove(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>));</span><br><span class="line">		System.out.println(ht);</span><br><span class="line"><span class="comment">//		无法获取剩下的value，下面两个代码都将输出null</span></span><br><span class="line">		System.out.println(ht.get(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">87563</span>)));</span><br><span class="line">		System.out.println(ht.get(<span class="keyword">new</span> <span class="title class_">A9</span>(<span class="number">60000</span>)));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="8-6-3-LinkedHashMap-实现类"   >
          <a href="#8-6-3-LinkedHashMap-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-3-LinkedHashMap-实现类" class="headerlink" title="8.6.3 LinkedHashMap 实现类"></a>8.6.3 LinkedHashMap 实现类</h4>
      <p>HashSet有一个LinkedHashSet子类，HashMasp也有一个LinkedHashMap子类；LinkedHashMap也使用双向链表来维护key-value对的顺序（其实也要考虑key的顺序），该链表负责维护Map的迭代顺序，迭代顺序与key-value对的插入顺序保持一致。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">scores</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">		scores.put(<span class="string">&quot;语文&quot;</span>, <span class="number">90</span>);</span><br><span class="line">		scores.put(<span class="string">&quot;数学&quot;</span>, <span class="number">150</span>);</span><br><span class="line">		scores.put(<span class="string">&quot;英语&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="comment">//		调用forEach()方法遍历scores里的所有键值对</span></span><br><span class="line">		scores.forEach((key,value)-&gt;System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面最后一句使用Java 8为Map新增的forEach()方法来遍历Map集合。LinkedHashMap可以记住key-value对的添加顺序。</p>

        <h3 id="8-6-4-使用Properties读写属性文件"   >
          <a href="#8-6-4-使用Properties读写属性文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-4-使用Properties读写属性文件" class="headerlink" title="8.6.4 使用Properties读写属性文件"></a>8.6.4 使用Properties读写属性文件</h3>
      <p>Properties类是Hashtable类的子类，正如它的名字所暗示的，该对象在处理属性文件时特别方便（Windows操作平台上的ini文件就是一种属性文件）。Properties类可以把Map对象和属性文件关联起来，从而可以把Map中的键值对写入属性文件中，也可以把属性文件中的“属性名&#x3D;属性值”加载到Map对象中。由于属性文件里的属性名、属性值只能是字符串类型，所以Properties里的key、value都是字符串类型。提供了三个方法需要改键值对的值。</p>
<p>提示：**Properties相当于一个key、value都是String类型的Map。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//		向Properties中添加属性</span></span><br><span class="line">		props.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;yeeku&quot;</span>);</span><br><span class="line">		props.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//		将Properties中的key-value对保存到a.ini文件中</span></span><br><span class="line">		props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.ini&quot;</span>), <span class="string">&quot;comment line&quot;</span>);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//		创建一个Properties中添加属性</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">props2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//		向Properties中添加属性</span></span><br><span class="line">		props2.setProperty(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"><span class="comment">//		将a.ini文件中的键值对追加到props2中</span></span><br><span class="line">		props2.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.ini&quot;</span>));<span class="comment">//2</span></span><br><span class="line">		System.out.println(props2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>1将Properties对象中的键值对写入a.ini文件中，2则从a.ini文件中读取键值对，并添加到props2对象中。</p>

        <h3 id="8-6-5-SortedMap接口和TreeMap实现类"   >
          <a href="#8-6-5-SortedMap接口和TreeMap实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-5-SortedMap接口和TreeMap实现类" class="headerlink" title="8.6.5 SortedMap接口和TreeMap实现类"></a>8.6.5 SortedMap接口和TreeMap实现类</h3>
      <p>正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出SortedMap子接口，SortedMap接口也有一个TreeMap实现类。</p>
<p>TreeMap就是一个红黑树数据结构，每个键值对机作为红黑树的一个节点。TreeMap存储键值对（节点）时，需要根据key对节点进行排序。TreeMap可以保证所有的键值对处于有序状态。TreeMap也有自然排序和定序排序两种排序方式。</p>
<ul>
<li>自然排序: TreeMap的所有key必须实现 Comparable接口,而且所有的key应该是同一个类的对象,否则将会抛出 ClassCastException异常。</li>
<li>定制排序:创建TreeMap时,传入一个 Comparator对象,该对象负责对TreeMap中的所有key进行排序。采用定制排序时不要求Map的key实现 Comparable接口，</li>
</ul>
<p>类似于 TreeSet中判断两个元素相等的标准, TreeMap中判断两个key相等的标准是:两个key通过 compare方法返回0, TreeMap即认为这两个key是相等的。</p>
<p>如果使用自定义类作为 TreeMap的key,且想让TreeMap良好地工作,则重写该类的 equals方法和 compare To方法时应保持一致的返回结果:两个key通过 equals方法比较返回true时,它们通过compareTo方法比较应该返回0.如果 equals方法与 compareTo方法的返回结果不一致,TreeMap与Map接口的规则就会冲突。</p>
<p>注意：再次强调：Set和Map的关系十分密切,Java源码就是先实现了 HashMap，TreeMap等集合,然后通过包装一个所有的value都为空对象的Map集合实现了Set集合类。</p>
<p>与 TreeSet类似的是, TreeMap中也提供了一系列根据key顺序访问key-value对的方法。</p>
<ul>
<li><p>Map. Entry firstEntry:返回该Map中最小key所对应的key- -value对,如果该Map为空,则返回null</p>
</li>
<li><p>Object firstKey:返回该Map中的最小ey值,如果该Map为空,则返回null</p>
</li>
<li><p>Map. Entry lastEntry:返回该Map中最大key所对应的key- value对,如果该Map为空或不存在这样的key-value对,则都返回null</p>
</li>
<li><p>Object lastKey:返回该Map中的最大key值如果该Map为空或不存在这样的key,则都返回null</p>
</li>
<li><p>Map. Entry higherEntry(Object key):返回该Map中位于key后一位的key- value对(即大于指定key的最小key所对应的key- -value对)。如果该Map为空,则返回null</p>
</li>
<li><p>Object higherKey(Object key):返回该Map中位于key后一位的key值(即大于指定key的最小key值)。如果该Map为空或不存在这样的key- -value对,则都返回 null</p>
</li>
<li><p>Map. Entry lowerEntry(Object key):返回该Map中位于key前一位的key- -value对(即小于指定key的最大key所对应的key- -value对)。如果该Map为空或不存在这样的key- -value对,则都返回null</p>
</li>
<li><p>Object lowerKey(Object key):返回该Map中位于key前一位的key值(即小于指定key的最大key值)。如果该Map为空或不存在这样的key,则都返回 null</p>
</li>
<li><p>NavigableMap subMap(Object fromKey boolean fromInclusive, Object toKey, booleantoInclusive):返回该Map的子Map,其key的范围是从 fromKey(是包括取决于第二个参数)到 toKey(是否包括取决于第四个参数)</p>
</li>
<li><p>SortedMap subMap(Object fromKey, Object toKey):返回该Map的子Map,其key的范围是从fromKey（包括）到toKey（不包括）。</p>
</li>
<li><p>SortedMap tailMap(Object fromKey)：返回Map的子Map，其key的范围是大于fromKey（是否包括取决于第二参数）的所有key。</p>
</li>
</ul>
<p>表面复杂，实则简单，因为TreeMap中的key-value对是有序的，所以增加了访问第一个、前一个、后一个、最后一个、key-value对的方法，并提供了几个从TreeMap中截取子TreeMap的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">U</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">U</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;R[count:&quot;</span>+count+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	根据count判断两个对象是否相等</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equanls</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> != <span class="literal">null</span> &amp;&amp; obj.getClass() == U.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (U)obj;</span><br><span class="line">			<span class="keyword">return</span> r.count == <span class="built_in">this</span>.count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> (U)obj;</span><br><span class="line"><span class="comment">//		count前省略this,在方法中调用同一个类中的实例，可省略</span></span><br><span class="line">		<span class="keyword">return</span> count&gt;r.count?<span class="number">1</span>: count&lt;r.count?-<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">		tm.put(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">3</span>), <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">		tm.put(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">9</span>), <span class="string">&quot;789&quot;</span>);</span><br><span class="line">		tm.put(<span class="keyword">new</span> <span class="title class_">U</span>(-<span class="number">5</span>), <span class="string">&quot;4569&quot;</span>);</span><br><span class="line">		System.out.println(tm);</span><br><span class="line"><span class="comment">//		返回该TreeMap的第一个Entry对象</span></span><br><span class="line">		System.out.println(tm.firstEntry());</span><br><span class="line"><span class="comment">//		返回该TreeMap的最后一个key值</span></span><br><span class="line">		System.out.println(tm.lastKey());</span><br><span class="line"><span class="comment">//		返回该TreeMap的比new U(2)大的最小的key值</span></span><br><span class="line">		System.out.println(tm.higherKey(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">//		返回该TreeMap的比new R(2)最小的key-value对</span></span><br><span class="line">		System.out.println(tm.lowerEntry(<span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">2</span>)));</span><br><span class="line"><span class="comment">//		返回该TreeMap的子TreeMap</span></span><br><span class="line">		System.out.println(tm.subMap(<span class="keyword">new</span> <span class="title class_">U</span>(-<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">U</span>(<span class="number">4</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用该U对象作为TreeMap的key，该TreeMap采用自然排序</p>

        <h3 id="8-6-6-WeakHashMap-实现类"   >
          <a href="#8-6-6-WeakHashMap-实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-6-WeakHashMap-实现类" class="headerlink" title="8.6.6 WeakHashMap 实现类"></a>8.6.6 WeakHashMap 实现类</h3>
      <p>HashMap的key保留了对实际对象的强引用，这意味着只要HashMap对象不被销毁，该HashMap的所有key所引用的对象就不会被垃圾回收，HashMap也不会自动删除这些key对应的key-value第；但WeakHashMap对象的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象将可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的键值对。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">whm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>();</span><br><span class="line"><span class="comment">//		三个key都是匿名字符串对象（没有其他引用）</span></span><br><span class="line">		whm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;语文&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;良好&quot;</span>));</span><br><span class="line">		whm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;数学&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;满分&quot;</span>));</span><br><span class="line">		whm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;英语&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;优秀&quot;</span>));</span><br><span class="line"><span class="comment">//		向WeakHashMap中添加一个键值对</span></span><br><span class="line"><span class="comment">//		该key是一个系统缓存的字符串对象</span></span><br><span class="line">		whm.put(<span class="string">&quot;java&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;中等&quot;</span>));</span><br><span class="line">		System.out.println(whm);</span><br><span class="line">		whm.forEach((key,value)-&gt;System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+value));</span><br><span class="line"><span class="comment">//		通知系统回收垃圾</span></span><br><span class="line">		System.gc();</span><br><span class="line">		System.runFinalization();</span><br><span class="line"><span class="comment">//		通常情况下，只能看到一组</span></span><br><span class="line">		System.out.println(whm);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用forEach（正则表达式）方法遍历集合，被删除的前三个键值对都是匿名的字符串对象，WeakHashMap只保留了他们的弱引用，这样垃圾回收是会自动删除这三个键值对。</p>
<p>第四个键值对的key是一个字符串直接常量，（系统会使用缓存池保留对该字符串对象的强引用），所以垃圾回收时不会回收他。</p>

        <h3 id="8-6-7-IdentityHashMap实现类"   >
          <a href="#8-6-7-IdentityHashMap实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-7-IdentityHashMap实现类" class="headerlink" title="8.6.7 IdentityHashMap实现类"></a>8.6.7 IdentityHashMap实现类</h3>
      <p>在IdentityHashMap中，当且仅当两个key严格相等(key1&#x3D;&#x3D;key2)的时候，IdentityHashMap才会认为两个key相等，对于普通的HashMap而言，只要key1和key2通过equals()方法比较返回true，且他们的hashCode()相等即可。</p>
<p>注意：IdentityHashMap是一个特殊的Map实现类！此类实现Map接口时，他又以违反了Map的通常规范：IdentityHashMap要求只有两个key相等时才会认为两个key相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.IdentityHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityHashMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ihm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>();</span><br><span class="line">		ihm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;语文&quot;</span>), <span class="number">98</span>);</span><br><span class="line">		ihm.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;语文&quot;</span>), <span class="number">99</span>);</span><br><span class="line">		ihm.put(<span class="string">&quot;Java&quot;</span>, <span class="number">99</span>);</span><br><span class="line">		ihm.put(<span class="string">&quot;Java&quot;</span>,<span class="number">100</span>);</span><br><span class="line">		ihm.forEach((key,value)-&gt;System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+value));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>前两个键值对是新创建的字符串对象，通过=&#x3D;比较不相同，所以会当成两个不相等的key，后两个是字符串直接量，=&#x3D;比较相等，所以传入了一对键值对。</p>

        <h3 id="8-6-8-EnumMap实现类"   >
          <a href="#8-6-8-EnumMap实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-8-EnumMap实现类" class="headerlink" title="8.6.8 EnumMap实现类"></a>8.6.8 EnumMap实现类</h3>
      <p>是一个与枚举类一起使用的Map实现，EnumMap中所有的key都必须是单个枚举类型的枚举值。创建EnumMap时，必须显示或隐式指定他对应的枚举类。有如下特征：</p>
<ul>
<li>以数组的形式保存，实现形式十分紧凑、高效</li>
<li>根据key的自然顺序来维护key-value对的顺序，当程序通过keySet()、entrySet()、values()等方法遍历EnumMap时可以看到这种顺序。</li>
<li>EnumMap不允许使用null作为key，但允许使用null作为value。</li>
</ul>
<p>与创建普通的Map有所区别的是，创建EnumMap时必须指定一个枚举类，从而将该EnumMap和指定枚举类关联起来。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span></span><br><span class="line">&#123;</span><br><span class="line">	SPRING,SUMMER,FALL,WINTER</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMapTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">enumMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnumMap</span>(Season1.class);</span><br><span class="line">		enumMap.put(Season1.FALL, <span class="string">&quot;秋风瑟瑟&quot;</span>);</span><br><span class="line">		enumMap.put(Season1.SPRING, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">		System.out.println(enumMap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>创建该EnumMap对象时指定它的key只能是Season枚举类的枚举值，向EnumMap添加了键值对后，这两个键值对会按Season枚举值的自然顺序排序。</p>

        <h3 id="8-6-9-各Map实现类的性能分析"   >
          <a href="#8-6-9-各Map实现类的性能分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-6-9-各Map实现类的性能分析" class="headerlink" title="8.6.9 各Map实现类的性能分析"></a>8.6.9 各Map实现类的性能分析</h3>
      <p>对于Map的常用实现类而言，HashMap通常比Hashtable快。</p>
<p>TreeMap通常比HashMap和Hashtable要慢（尤其在插入、删除key-value对时更慢），因为TreeMap底层采用红黑树来管理键值对（红黑树的每个节点就是一个键值对）。</p>
<p>使用TreeMap有一个好处：TreeMap中的键值对总是要处于有序状态，无须专门进行排序操作。放TreeMap被谭崇之后，就可以调用keySet()，去得有key组成的Set，然后使用toArray()方法生成key的数组，接下来使用Arrays的binarySearch()方法在已排序的数组中快速查询对象。</p>
<p>对于一般的场景一般采用HashMap,因为HashMap正是为快速查询设计的（HashMap底层其实也是采用数组来存储键值对）。但如果城西需要一个总是排好序的Map时，则可以考虑TreeMap。</p>
<p>LinkedHashMap比HashMap慢一点，因为他需要维护链表来爆出Map中的键值对的添加顺序。只是他使用&#x3D;&#x3D;而不是equals()方法来判断元素相等。EnumMap的性能最好，但它只能使用同一枚举值作为key。</p>

        <h2 id="8-8-操作集合的工具类：Collections"   >
          <a href="#8-8-操作集合的工具类：Collections" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-操作集合的工具类：Collections" class="headerlink" title="8.8 操作集合的工具类：Collections"></a>8.8 操作集合的工具类：Collections</h2>
      
        <h3 id="8-8-1-排序操作"   >
          <a href="#8-8-1-排序操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-1-排序操作" class="headerlink" title="8.8.1 排序操作"></a>8.8.1 排序操作</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		nums.add(<span class="number">2</span>);</span><br><span class="line">		nums.add(-<span class="number">5</span>);</span><br><span class="line">		nums.add(<span class="number">3</span>);</span><br><span class="line">		nums.add(<span class="number">0</span>);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		Collections.reverse(nums);<span class="comment">//次序反转.</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		Collections.sort(nums);<span class="comment">//自然排序</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		Collections.shuffle(nums);<span class="comment">//将List集合元素按随机顺序排序</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShowHand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义游戏做多支持多个个玩家</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PLAY_NUM</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">//	定义扑克牌的所有花色和数值</span></span><br><span class="line">	<span class="keyword">private</span> String[] types = &#123;</span><br><span class="line">			<span class="string">&quot;方块&quot;</span>,<span class="string">&quot;草花&quot;</span>,<span class="string">&quot;红心&quot;</span>,<span class="string">&quot;黑桃&quot;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">private</span> String[] values = &#123;</span><br><span class="line">			<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;A&quot;</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//	cards是以巨额游戏中剩下的扑克牌</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt;cards = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//	定义所有玩家</span></span><br><span class="line">	<span class="keyword">private</span> String[] players = <span class="keyword">new</span> <span class="title class_">String</span>[PLAY_NUM];</span><br><span class="line"><span class="comment">//	所有玩家手上的扑克牌</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt;[] playersCards = <span class="keyword">new</span> <span class="title class_">List</span>[PLAY_NUM];</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化扑克牌，放入52张扑克牌</span></span><br><span class="line"><span class="comment">	 * 并使用shuffle方法将它们按随机顺序排列</span></span><br><span class="line"><span class="comment">	 **/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initCodes</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;types.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;values.length;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cards.add(types[i]+values[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Collections.shuffle(cards);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化玩家，为每个玩家分派用户名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPlayer</span><span class="params">(String...names)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(names.length&gt;PLAY_NUM||names.length&lt;<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			检验玩家数量，此处使用异常机制更合理</span></span><br><span class="line">			System.out.println(<span class="string">&quot;玩家数量不对&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			初始化玩家用户名</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;names.length;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				players[i] = names[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化玩家手中的扑克牌，开始游戏时，每个玩家手上的扑克牌为空</span></span><br><span class="line"><span class="comment">	 * 程序使用一个长度为0的LinkedList表示</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initPlayerCards</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;players.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span> &amp;&amp; !players[i].equals(<span class="string">&quot;&quot;</span>));</span><br><span class="line">			&#123;</span><br><span class="line">				playersCards[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 输出全部扑克牌，该功能没有具体功能，只用来测试</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAllCards</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> card:cards)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(card);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 派发扑克牌</span></span><br><span class="line"><span class="comment">	 * @param first最先派给谁</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dellvarCard</span><span class="params">(String first)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		调用ArrayUtils工具类search方法</span></span><br><span class="line"><span class="comment">//		查询出指定元素在数组中的索引</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">firstPos</span> <span class="operator">=</span> Arrays.binarySearch(players,first);</span><br><span class="line"><span class="comment">//		依次给位于该指定原价之后的每个玩家之后的每个玩家派发扑克牌</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> firstPos;i&lt;PLAY_NUM;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				playersCards[i].add(cards.get(<span class="number">0</span>));</span><br><span class="line">				cards.remove(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		依次给位于该指定玩家之前的每个玩家派扑克牌</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;firstPos;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				playersCards[i].add(cards.get(<span class="number">0</span>));</span><br><span class="line">				cards.remove(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 输出玩家手中的扑克牌</span></span><br><span class="line"><span class="comment">	 * 实现该方法时，应该控制每个玩家看不到别人的第一张牌，但此处没有增加这个功能</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPlayerCards</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;PLAY_NUM;i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			当玩家不为空时</span></span><br><span class="line">			<span class="keyword">if</span>(players[i] != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				输出玩家</span></span><br><span class="line">				System.out.println(players[i]+<span class="string">&quot; :   &quot;</span>);</span><br><span class="line"><span class="comment">//				遍历输出玩家手上的扑克牌</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">var</span> card:cards)</span><br><span class="line">				&#123;</span><br><span class="line">					System.out.println(card+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShowHand</span>();</span><br><span class="line">		sh.initPlayer(<span class="string">&quot;Mr.Douji&quot;</span>,<span class="string">&quot;Mr.Heizhu&quot;</span>,<span class="string">&quot;Mr.Chao&quot;</span>);</span><br><span class="line">		sh.initCodes();</span><br><span class="line">		sh.initPlayerCards();</span><br><span class="line"><span class="comment">//		下面测试所有扑克牌，没有实际意义</span></span><br><span class="line">		sh.showAllCards();</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"><span class="comment">//		下面从Mr.Heizhu开始发牌</span></span><br><span class="line">		sh.dellvarCard(<span class="string">&quot;Mr.Heizhu&quot;</span>);</span><br><span class="line">		sh.showPlayerCards();</span><br><span class="line">		sh.dellvarCard(<span class="string">&quot;Mr.Douji&quot;</span>);</span><br><span class="line">		sh.showPlayerCards();</span><br><span class="line">		sh.dellvarCard(<span class="string">&quot;Mr.Chao&quot;</span>);</span><br><span class="line">		sh.showPlayerCards();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="8-8-2-查找、替换操作"   >
          <a href="#8-8-2-查找、替换操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-2-查找、替换操作" class="headerlink" title="8.8.2 查找、替换操作"></a>8.8.2 查找、替换操作</h3>
      <p>Collections还提供了常用的用于查找、替换集合元素的类方法。</p>
<ul>
<li>int binarySeach(List list , Object key)：使用二分搜索法搜索指定的List集合，以获取指定对象在List集合中的索引，如果要使该方法可以正常工作，则必须保证List集合已经处于有序状态。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeachTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		nums.add(<span class="number">2</span>);</span><br><span class="line">		nums.add(-<span class="number">5</span>);</span><br><span class="line">		nums.add(<span class="number">3</span>);</span><br><span class="line">		nums.add(<span class="number">0</span>);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		System.out.println(Collections.max(nums));</span><br><span class="line">		System.out.println(Collections.min(nums));</span><br><span class="line">		Collections.replaceAll(nums, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//0用1换</span></span><br><span class="line">		System.out.println(nums);</span><br><span class="line">		<span class="comment">//-5在集合中出现的次数</span></span><br><span class="line">		System.out.println(Collections.frequency(nums, -<span class="number">5</span>));</span><br><span class="line">		Collections.sort(nums);</span><br><span class="line">		System.out.println(nums);</span><br><span class="line"><span class="comment">//		只有排序后的List集合才能用二分法查询</span></span><br><span class="line">		System.out.println(Collections.binarySearch(nums, -<span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="8-8-3-同步控制"   >
          <a href="#8-8-3-同步控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-3-同步控制" class="headerlink" title="8.8.3 同步控制"></a>8.8.3 同步控制</h3>
      <p>Collections类中提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</p>
<p>Java中常用的集合框架中的实现类HashSet、TreeSet、ArrayList、LinkedList、HashMap和TreeMap都是线程不安全的。如果有个多线程访问他们，而且有炒一个的线程试图修改他们，则存在线程安全问题。Collections提供了多个类方法可以把它们包装成线程同步的集合。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		下面程序创建了4个线程安全的集合对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> Collections.synchronizedCollection(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">		<span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">		<span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>());</span><br><span class="line">		<span class="type">var</span> <span class="variable">m</span> <span class="operator">=</span> Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>直接将新创建的集合传给Collections的synchronizedXxx()方法，这样做可以直接获取Set和Map的线程安全实现版本。</p>

        <h3 id="8-8-4-设置不可变集合"   >
          <a href="#8-8-4-设置不可变集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-4-设置不可变集合" class="headerlink" title="8.8.4 设置不可变集合"></a>8.8.4 设置不可变集合</h3>
      <p>Collection 提供了三个类方法返回一个不可变类的集合。</p>
<p>三个类方法的参数是原有的集合对象，返回值是该集合的“只读版本”通过Collections提供的三个类方法，可以生成“只读”的Collections或Map。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个空的、不可变的List对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">unmodifiableList</span> <span class="operator">=</span> Collections.emptyList();</span><br><span class="line"><span class="comment">//		创建一个只有一个元素、且不可变的Set对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">unmodifiableSet</span> <span class="operator">=</span> Collections.singleton(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		创建一个普通的Map对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">scores</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		scores.put(<span class="string">&quot;语文&quot;</span>, <span class="number">90</span>);</span><br><span class="line">		scores.put(<span class="string">&quot;数学&quot;</span>, <span class="number">70</span>);</span><br><span class="line"><span class="comment">//		返回普通的Map对象对应的不可变版本</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">unmodifiableMap</span> <span class="operator">=</span> Collections.unmodifiableMap(scores);</span><br><span class="line"><span class="comment">//		下面任意一行都会引起异常</span></span><br><span class="line">		unmodifiableList.add(<span class="string">&quot;测试元素&quot;</span>);</span><br><span class="line">		unmodifiableSet.add(<span class="string">&quot;测试元素&quot;</span>);</span><br><span class="line">		unmodifiableMap.put(<span class="string">&quot;测试元素&quot;</span>,<span class="number">90</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>不可变的集合对象只能访问集合元素，不可修改集合元素。</p>

        <h3 id="8-8-5-Java-9-新增的不可变集合"   >
          <a href="#8-8-5-Java-9-新增的不可变集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-8-5-Java-9-新增的不可变集合" class="headerlink" title="8.8.5 Java 9 新增的不可变集合"></a>8.8.5 Java 9 新增的不可变集合</h3>
      <p>以前假设要创建一个包含6个元素的Set集合，程序需要先创建Set集合，然后调用6次add方法向Set集合中添加元素。Java 9对此进行了简化，程序直接调用Set、List、Map的of()方法集合创建包含N个元素不可变集合，这样一行代码就可以创建包含N个元素的集合。</p>
<p>不可变意味着程序不能向集合中添加元素，也不能从集合中删除元素。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java9Collection</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建包含四个元素的Set集合</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">set</span> <span class="operator">=</span> Set.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Kitlin&quot;</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Swift&quot;</span>);</span><br><span class="line">		System.out.println(set);</span><br><span class="line"><span class="comment">//		不可变集合，下面代码导致错误</span></span><br><span class="line"><span class="comment">//		set.add(&quot;Ruby&quot;);</span></span><br><span class="line"><span class="comment">//		System.out.println(set);</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> List.of(<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">98</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line"><span class="comment">//		list.add(78);</span></span><br><span class="line"><span class="comment">//		System.out.println(list);</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> Map.of(<span class="string">&quot;语文&quot;</span>,<span class="number">89</span>,<span class="string">&quot;数学&quot;</span>,<span class="number">56</span>,<span class="string">&quot;Java&quot;</span>,<span class="number">100</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line"><span class="comment">//		map.put(&quot;c&quot;, 80);</span></span><br><span class="line"><span class="comment">//		System.out.println(map);</span></span><br><span class="line"><span class="comment">//		使用Map.entry()方法显示构造键值对</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">map2</span> <span class="operator">=</span> Map.ofEntries(Map.entry(<span class="string">&quot;语文&quot;</span>, <span class="number">100</span>),</span><br><span class="line">				Map.entry(<span class="string">&quot;数学&quot;</span>, <span class="number">78</span>)</span><br><span class="line">				,Map.entry(<span class="string">&quot;英语&quot;</span>, <span class="number">65</span>));</span><br><span class="line">		System.out.println(map2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面示范了如何使用集合元素创建不可变集合，其中Set、List比较简单，程序只需要为他们的of方法传入N个集合元素集合创建对应的集合。</p>
<p>创建不可变的Map集合有两个方法：使用of方法时只需要一次传入多个键值对即可；还可以用ofEntries()方法，该方法接受多个Entry对象，因此程序显式使用Map.entry()方法来创建Map.Entry对象。</p>

        <h2 id="8-9-繁琐的接口Enumeration"   >
          <a href="#8-9-繁琐的接口Enumeration" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-9-繁琐的接口Enumeration" class="headerlink" title="8.9 繁琐的接口Enumeration"></a>8.9 繁琐的接口Enumeration</h2>
      <p>现在不用Enumeration，使用Itreator迭代器。</p>
<p>在计算机行业有一条规则：加入任何规则都需要慎之又慎，因为使用后无法删除规则。</p>

        <h2 id="8-10-本章小结"   >
          <a href="#8-10-本章小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-10-本章小结" class="headerlink" title="8.10 本章小结"></a>8.10 本章小结</h2>
      <p>本章详细介绍了Java集合框架的相关知识。本章从Java的集合框架体系开始讲起，概述了Java集合框架的4个主要体系：Set、List、Quere和Map，并简述了集合在编程中的重要性。本章详细介绍了Java 8对集合框架的改进，包括使用Lambda表达式简化集合编程，一节集合的Stream编程等。详细介绍了四个主要体系的接口及其实现类的详细用法，并升入分析了各种实现类实现机制的差异，并给出了选择集合实现类时的原则。本章从原理上刨铣了Map结构特征，以及Map结构和Set、List之间的区别和联系。最后通过梭哈游戏示范了Collections工具类的基本用法。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://example.com">Xiao Zhang</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://example.com/2023/02/14/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E5%90%88/">http://example.com/2023/02/14/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%9B%86%E5%90%88/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/02/14/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E6%B3%9B%E5%9E%8B/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">《疯狂Java讲义——泛型》</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/02/14/c%E8%AF%AD%E8%A8%80/"><span class="paginator-prev__text">C语言</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">
          第8章 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">
          8.1 Java集合概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Java-11%E6%96%B0%E5%A2%9E%E7%9A%84-Collection-%E5%92%8C-Iterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">
          8.2 Java 11新增的 Collection 和 Iterator接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          8.2.1 使用Lambda表达式遍历集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E4%BD%BF%E7%94%A8-Iterator-%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          8.2.2 使用 Iterator 遍历集合元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%81%8D%E5%8E%86Iterator"><span class="toc-number">1.2.3.</span> <span class="toc-text">
          8.2.3 使用Lambda表达式遍历Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-%E4%BD%BF%E7%94%A8foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.4.</span> <span class="toc-text">
          8.2.4 使用foreach循环遍历集合元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-%E4%BD%BF%E7%94%A8Predicate%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88"><span class="toc-number">1.2.5.</span> <span class="toc-text">
          8.2.5 使用Predicate操作集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-6-%E4%BD%BF%E7%94%A8Stream%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88"><span class="toc-number">1.2.6.</span> <span class="toc-text">
          8.2.6 使用Stream操作集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-Set%E9%9B%86%E5%90%88"><span class="toc-number">1.3.</span> <span class="toc-text">
          8.3 Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-HashSet%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          8.3.1 HashSet类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-LinkedHashSet-%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          8.3.2 LinkedHashSet 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-TreeSet%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          8.3.3 TreeSet类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">
          1.自然排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">
          2.定制排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-EnumSet%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          8.3.4 EnumSet类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5-%E5%90%84Set%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.3.5.</span> <span class="toc-text">
          8.3.5 各Set实现类的性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4List%E9%9B%86%E5%90%88"><span class="toc-number">1.4.</span> <span class="toc-text">
          8.4List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1%E6%94%B9%E8%BF%9B%E7%9A%84List%E6%8E%A5%E5%8F%A3%E5%92%8C-Listlterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          8.4.1改进的List接口和 Listlterator接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-ArrayLISt%E5%92%8CVector%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          8.4.2 ArrayLISt和Vector实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3-%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84List"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          8.4.3 固定长度的List</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-Queue%E9%9B%86%E5%90%88"><span class="toc-number">1.5.</span> <span class="toc-text">
          8.5 Queue集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1-PriorityQueue%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">
          8.5.1 PriorityQueue实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-2-Deque%E6%8E%A5%E5%8F%A3%E4%B8%8E-ArrayDeque%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">
          8.5.2 Deque接口与 ArrayDeque实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-3-LinkedList-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.5.3.</span> <span class="toc-text">
          8.5.3 LinkedList 实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-4%E5%90%84%E7%A7%8D%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">
          8.5.4各种线性表的性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6%E5%A2%9E%E5%BC%BA%E7%9A%84Map%E9%9B%86%E5%90%88"><span class="toc-number">1.6.</span> <span class="toc-text">
          8.6增强的Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-1-Java-8%E4%B8%BAMap%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">
          8.6.1 Java 8为Map新增的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-2-%E6%94%B9%E8%BF%9B%E7%9A%84-HashMap-%E5%92%8C-Hashtable-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">
          8.6.2 改进的 HashMap 和 Hashtable 实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-3-LinkedHashMap-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">
          8.6.3 LinkedHashMap 实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-4-%E4%BD%BF%E7%94%A8Properties%E8%AF%BB%E5%86%99%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">
          8.6.4 使用Properties读写属性文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-5-SortedMap%E6%8E%A5%E5%8F%A3%E5%92%8CTreeMap%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.6.4.</span> <span class="toc-text">
          8.6.5 SortedMap接口和TreeMap实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-6-WeakHashMap-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.6.5.</span> <span class="toc-text">
          8.6.6 WeakHashMap 实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-7-IdentityHashMap%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.6.6.</span> <span class="toc-text">
          8.6.7 IdentityHashMap实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-8-EnumMap%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.6.7.</span> <span class="toc-text">
          8.6.8 EnumMap实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-9-%E5%90%84Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.6.8.</span> <span class="toc-text">
          8.6.9 各Map实现类的性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections"><span class="toc-number">1.7.</span> <span class="toc-text">
          8.8 操作集合的工具类：Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-1-%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.1.</span> <span class="toc-text">
          8.8.1 排序操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-2-%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.2.</span> <span class="toc-text">
          8.8.2 查找、替换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-3-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">
          8.8.3 同步控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-4-%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="toc-number">1.7.4.</span> <span class="toc-text">
          8.8.4 设置不可变集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-5-Java-9-%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="toc-number">1.7.5.</span> <span class="toc-text">
          8.8.5 Java 9 新增的不可变集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E7%B9%81%E7%90%90%E7%9A%84%E6%8E%A5%E5%8F%A3Enumeration"><span class="toc-number">1.8.</span> <span class="toc-text">
          8.9 繁琐的接口Enumeration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">
          8.10 本章小结</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Make great efforts</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://blog.csdn.net/weixin_45708609?spm=1000.2115.3001.5343/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="2215071022@qq.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="2215071022" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="http://2215071022@qq.com" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email Subscribe</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>zhang</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v6.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>