<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="第七章 Java基础类库        Oracle为java提供了丰富的基础类库，java8提供了4000多个基础类(包括下一章将要介绍的集合框架),通过这些基础类库可以提高开发效率，降低开发难度。对于合格的Java程序员而言，至少要熟悉 Java SE中70%以上的类(当然本书并不是让读者去背诵 Java API文档),但在反复查阅API文档  的过程中">
<meta property="og:type" content="article">
<meta property="og:title" content="《疯狂Java讲义——Java基础类库》">
<meta property="og:url" content="http://example.com/2023/02/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%20Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/index.html">
<meta property="og:site_name" content="Xiao Zhang&#39;blog">
<meta property="og:description" content="第七章 Java基础类库        Oracle为java提供了丰富的基础类库，java8提供了4000多个基础类(包括下一章将要介绍的集合框架),通过这些基础类库可以提高开发效率，降低开发难度。对于合格的Java程序员而言，至少要熟悉 Java SE中70%以上的类(当然本书并不是让读者去背诵 Java API文档),但在反复查阅API文档  的过程中">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\MingyangLiu\Desktop\%E5%BC%A0%E6%99%BA%E8%B6%85\image\Snipaste_2021-03-19_16-17-33.png">
<meta property="og:image" content="c:\Users\MingyangLiu\Desktop\%E5%BC%A0%E6%99%BA%E8%B6%85\image\P10319-162517(1)(1).jpg">
<meta property="article:published_time" content="2023-02-14T13:40:17.514Z">
<meta property="article:modified_time" content="2023-02-14T13:43:28.338Z">
<meta property="article:author" content="Xiao Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\MingyangLiu\Desktop\%E5%BC%A0%E6%99%BA%E8%B6%85\image\Snipaste_2021-03-19_16-17-33.png"><title>《疯狂Java讲义——Java基础类库》 | Xiao Zhang'blog</title><link ref="canonical" href="http://example.com/2023/02/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%20Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">menu.Blog</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/software/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">menu.software</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Xiao Zhang's Blod</div><div class="header-banner-info__subtitle">Blod for Xiao Zhang</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">《疯狂Java讲义——Java基础类库》</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body">
        <h1 id="第七章-Java基础类库"   >
          <a href="#第七章-Java基础类库" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七章-Java基础类库" class="headerlink" title="第七章 Java基础类库"></a>第七章 Java基础类库</h1>
      <p> Oracle为java提供了丰富的基础类库，java8提供了4000多个基础类(包括下一章将要介绍的集合框架),通过这些基础类库可以提高开发效率，降低开发难度。对于合格的Java程序员而言，至少要熟悉 Java SE中70%以上的类(当然本书并不是让读者去背诵 Java API文档),但在反复查阅API文档  的过程中，会自动记住大部分类的功能、方法，因此程序员一定要多练，多敲代码。</p>
<p>Java提供了 String、 StringBuffer和 StringBuilder来理字符串，它们之间存在少许差别，本章会详细介绍它们之间的差别，以及如何选择合适的字符串类。Java还提供了Date和 Calendar来处理日期、  时间，其中Date是一个已经过时的API,通常推荐使用 Calendar来处理日期、时间。 </p>
<p> 正则表达式是一个强大的文本处理工具，通过正则表达式可以对文本内容进行查找、替换、分割等  操作。从K1.4以后，Java也增加了对正则表达式的支持，包括新增的 Pattem和 Matcher两个类，并  改写了 String类，让 String类增加了正则表达式支，增加了正则表达式功能后的 String类更加强大。  </p>
<p>Java还提供了非常简单的国际化支持， Java使用 Locale对象封装一个国家、语言环境，再使用   ResourceBundle根据 Locale加载语言资源包，当 ResourceBundle加载了指定 Locale对应的语言资源文件后， ResourceBundle对象就可调用 getString()方法来取出指定key所对应的消息字符串。</p>

        <h2 id="7-1-与用户交互"   >
          <a href="#7-1-与用户交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-与用户交互" class="headerlink" title="7.1 与用户交互"></a>7.1 与用户交互</h2>
      <p>本节主要介绍如何获得用户的键盘输入</p>

        <h3 id="7-1-1-运行Java程序的参数"   >
          <a href="#7-1-1-运行Java程序的参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-1-运行Java程序的参数" class="headerlink" title="7.1.1 运行Java程序的参数"></a>7.1.1 运行Java程序的参数</h3>
      <p>main()方法的方法签名</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java程序入口:main()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>public 修饰符：Java类由JVM调用，为了让JVM可以自由调用这个main()方法，所以用public修饰符把这个方法暴露出来。</li>
<li>static 修饰符：JVM调用这个主方法时，会创建该主类的对象，然后通过对象来调用该主方法。JVM直接通过该类来调用主方法，因此使用static修饰该方法。</li>
<li>void 返回值：因为主方法被JVM调用，该方法的返回值将返回给JVM,这没有任何意义，因此main()方法没有返回值。</li>
</ul>
<p>根据方法调用规则：谁调用方法，谁负责为形参赋值。也就是说main()方法由JVM调用，即args形参应该由JVM负责赋值，但JVM怎么知道如何为args赋值呢，看如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgsTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		输出args数组的长度</span></span><br><span class="line">		System.out.println(args.length);</span><br><span class="line"><span class="comment">//		遍历args数组的每个元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> arg : args)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(arg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序输出0，表明args数组是一个长度为0的数组——这是合理的。因为计算机是没有思考能力的，他只能忠实地执行用户交给它的任务，既然程序没有给args数组设定参数值，那么JVM就不知道args数组的元素，所以JVM将args数组设置成一个长度为0的数组。</p>
<p>改为一下命令运行此程序：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ArgsTest.java Java Spring</span><br></pre></td></tr></table></div></figure>

<p>即可看到如下结果</p>
<p><img src="C:\Users\MingyangLiu\Desktop\张智超\image\Snipaste_2021-03-19_16-17-33.png"></p>
<p>如果在类名后紧跟一个或多个字符串（多个字符串之间以空格隔开），JVM就会把这些字符串依次赋给args数组元素。运行Java程序时的参数与args数组之间的对应关系：</p>
<p><img src="C:\Users\MingyangLiu\Desktop\张智超\image\P10319-162517(1)(1).jpg"></p>
<p>如果某参数本身包含了空格，则应该将该参数用双引用引用，否则JVM会把这个空格当成参数分隔符，而不是参数本身。</p>

        <h3 id="7-1-2-使用Scanner获取键盘输入"   >
          <a href="#7-1-2-使用Scanner获取键盘输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-2-使用Scanner获取键盘输入" class="headerlink" title="7.1.2 使用Scanner获取键盘输入"></a>7.1.2 使用Scanner获取键盘输入</h3>
      <ol>
<li>创建Scannner对象，接收从控制台输入	<strong>Scanner input&#x3D;new Scanner(System.in);</strong></li>
<li>接收语句由接收类型决定     <strong>int n&#x3D;input.nextInt();</strong></li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo59</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建Scanner对象，接受从控制台输入</span></span><br><span class="line">		Scanner input=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="comment">//接受String类型</span></span><br><span class="line">		String str=input.next();</span><br><span class="line">		<span class="comment">//输出结果</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用Scanner类可以很方便地获取用户键盘输入，Scanner是一个基于正则表达式的文本扫描器，他可以用文件，输入流，字符串作为数据源，用于文件、输入流、字符串中解析数据。</p>
<p>Scanner主要看以下两个方法进行扫描输入：</p>
<ol>
<li>hasNextXxx()：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串。则直接用hasNext()。</li>
<li>nextXxx():获取下一个输入项。Xxx的含义与前一个方法中的Xxx相同。</li>
</ol>
<p>在默认情况下，Scanner使用空白（空格，tab，回车）作为多个输入项之间的分隔符。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerKeyBoardTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span>(sc.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span>+sc.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的程序可以不断地输入输出。</p>
<p>如果希望改变Scanner的分隔符（不使用空白作为分隔符），例如，程序需要每次读取一行，不管这一行中是否包含空格，Scanner都把它当成一个输入项。在这种需求下，可以把Scanner的分隔符设置为回车符，不在使用默认的空白作为分隔符。</p>
<p>Scanner的读取操作可能被阻塞（当前执行顺序流暂停）来等待信息的输入，如果输入源没有结束，Scanner有读取不到更多输入项时（尤其在键盘输入时比较常见），Scanner的hasNext()和next()方法都有可能阻塞，hasNext()方法是否阻塞与其相关的next()方法是否阻塞无关。</p>
<p>为Scanner设置分隔符使用useDelimiter(String pattern)方法即可，该方法的参数应该是一个正则表达式，，只要把上面程序中粗体字代码行的注释去掉，该程序就会把键盘的每行输入当成一个输入项，不会以空格、TAB空白等作为分隔符。事实上，Scanner提供了两个简单的方法来逐行读取。</p>
<ul>
<li>boolean hasNextLine()：返回输入源中是否还有下一行。</li>
<li>String nextLine()：返回输入源中下一行的字符串。</li>
</ul>
<p>Scanner不仅可以获取字符串输入项，也可以获取任何基本类型的输入项：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerLongTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">var</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in) ;</span><br><span class="line">    <span class="comment">//控制输入的格式</span></span><br><span class="line"><span class="keyword">while</span>(sc.hasNextLong())<span class="comment">//粗</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;键盘输入的是：&quot;</span></span><br><span class="line">                           +sc.nextLong());		<span class="comment">//粗</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>注意粗，正如通过hasNextLong()和nextLong()两个方法，Scanner可以直接从输入流中获得long型证书输入项。与此类似，如果需要输入其他基本类型的输入项，则可以使用相应的方法。</p>
<p>&#x3D;&#x3D;上面的程序不如ScannerKeyBoardTest程序适应性强，因为这个程序要求必须输入的格式，否则退出。</p>
<p>Scanner不仅能读取用户的键盘键入，还可以读取文件输入。只要在创建Scanner对象时传入了一个File对象作为参数，就可以让Scanner读取该文件的内容。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerFileTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将一个File对象作为Scanner的构造器参数，Scanner读取文件内容</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;ScannerFileTest.java&quot;</span>));<span class="comment">//粗体字</span></span><br><span class="line">			System.out.println(<span class="string">&quot;ScannerFileTest.java文件内容如下&quot;</span>);</span><br><span class="line">			<span class="comment">//判断是否还有下一行</span></span><br><span class="line">			<span class="keyword">while</span>(sc.hasNextLine())<span class="comment">//粗体字</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//输出文件中的下一行</span></span><br><span class="line">				System.out.println(sc.nextLine());<span class="comment">//粗体字</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>上面程序创建Scanner对象时传入一个File对象作为参数，这表明该程序将会读取ScannerFileTest.java文件中的内容。上面程序使用了hasNextLine()和nextLine()两个方法来读取文件内容。这表明该程序将逐行读取ScannerFileTest.java文件的内容。</p>
<p>因为上面程序涉及文件输入，可能引发文件IO相关异常，故主程序声明throws Exception表明main方法不处理任何异常。</p>

        <h2 id="7-2-系统相关"   >
          <a href="#7-2-系统相关" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-系统相关" class="headerlink" title="7.2 系统相关"></a>7.2 系统相关</h2>
      <p>Java提供了System类和Runtime类来与程序的运行平台进行交互。</p>

        <h3 id="7-2-1-System类"   >
          <a href="#7-2-1-System类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-1-System类" class="headerlink" title="7.2.1 System类"></a>7.2.1 System类</h3>
      <p>System类代表当前Java程序的运行平台，程序不能创建System类的对象，System提供了一些类变量和类方法，允许直接通过System类来条用这些类变量和类方法。</p>
<p> System类提供了代表标准输入、标准输出和错误输出类变量，并提供了一些静态方法用  环境变量、系统属性的方法，还提供了加载文件和动态链接库的方法。下面程序通过 System类  操作的环境变量和系统属性。</p>
<p>注意：   加载文件和动态链接库主要对 native方法有用，对于一些特殊的功能(如访问操作系统底层硬件设备等)Java程序无法实现，必须借助C语言来完成，此时需要使用C语言为Java方法提供实现。其实现步骤如下：  ①Java程序中声明 native修饰的方法，类似于abstract方法，只有方法签名，没有实现。使用带h选项的 Javac命令编译该Java程序，将生成一个class文件和一个h头文件  ②写一个.cpp文件实现 native方法，这一步需要包含1步产生的.h文件(这个h  文件中又包含了JDK带的jni.h文件)  ③将第2步的.cpp文件编译成动态链接库文件  ④在Java中用 System类的loadLibrary..()方法加载第3步产生的动态链接库文件，Java程序中就可以调用这个 natIve方法了。</p>
<p>注  在Java9以前， Javac命令没有-h选项，因此JDK提供了 javah命令来为. class文件生.成h头文件。Java10彻底删除了 javah命令  , Javac的-h选项代替了 javah。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取系统所有的环境变量</span></span><br><span class="line">		Map &lt; String, String &gt; env = System.getenv();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> name : env.keySet())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(name + <span class="string">&quot;---&gt;&quot;</span> + env.get(name));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取指定环境变量的值</span></span><br><span class="line">		System.out.println(System.getenv(<span class="string">&quot;JAVA_HOME&quot;</span>));</span><br><span class="line">		<span class="comment">//获取所有的系统属性</span></span><br><span class="line">		<span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">		props.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;props.txt&quot;</span>), <span class="string">&quot;System Properties&quot;</span>);</span><br><span class="line">		<span class="comment">//输出特定的系统属性</span></span><br><span class="line">		System.out.println(System.getProperty(<span class="string">&quot;os.name&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该程序运行结束之后还会在当前路径下生产一个Props.txt文件，该文件中记录了当前平台所有系统属性。</p>
<p> System类提供了通知系统进行垃圾回收的gc()方法，以及通知系统进行资源清理的   runFinalization(方法。关于这两个方法的用法请参考本书6.10节的内容</p>
<p>System类还有两个获取系统当前时间的方法  : currentTimeMillis()和nanoTime(),它们都返回一个long型整数。实际上它们都返回当前时间与UTC1970年1月1日午夜的时间差，前者以毫秒作为单位，  后者以纳秒作为单位。必须指出的是，这两个方法返回的间粒度取决于底层操作系统，可能所在的操作系统根本不支持以毫秒、纳秒作为计时单位。例如，许多操作系统以几十毫秒为单位测量时间，currentTimeMillis()方法不可能返回精确的毫秒数，而nanoTime()方法很少用，因为大部分操作系统都不支持使用纳秒作为计时单位。</p>
<p>除此之外， System类的in、out和err分别代表系统的标准输入(通常是键盘)、标准输出(通常是  显示器)和错误输出流，并提供了 setIn(),setout()和setErr()方法来改变系统的标准输入、标准输出和标准错误输出流。关于如何改变系统的标准输入、输出的方法，可以参考本书第15章的内容。</p>
<p>System类还提供了一个 identityHashCode( Object X)方法，该方法返回指定对象的精确 hashCode值  也就是根据该对象的地址计算得到的 hashCode值。当某个类的 hashCode方法被重写后，该类实例的   hashCode()方法就不能唯一地标识该对象；但通过 identityHashCode()方法返回的 hash Code值，依然是根据该对象的地址计算得到的 hash Code值。所以如果两个对象的 identityHashCode值相同，则两个对象绝对是同一个对象。如下程序所示:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityHashCodeTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		下面程序中的s1和s2是两个不同的对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//		String重写了hasCode()方法——改为根据字符序列计算hashCode值</span></span><br><span class="line"><span class="comment">//		因为S1和S2的字符序列相同，所以他们的hasCode()方法返回值相同</span></span><br><span class="line">		System.out.println(s1.hashCode()+<span class="string">&quot;-----&quot;</span>+s2.hashCode());</span><br><span class="line"><span class="comment">//		s1和s2的不同的字符串对象，所以他们的identityHashCode值不同</span></span><br><span class="line">		System.out.println(System.identityHashCode(s1) + <span class="string">&quot;----&quot;</span>+System.identityHashCode(s2));</span><br><span class="line">		<span class="type">var</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">//		s3和s4是相同的字符串对象，所以他们的identityHashCode值相同。</span></span><br><span class="line">		System.out.println(System.identityHashCode(s3)+<span class="string">&quot;---&quot;</span>+System.identityHashCode(s4));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过 identityHashCode(Object x)方法可以获得对象的 identityHashCode值，这个特殊的identityHashCode值可以唯一地标识该对象。因为identityHashCode值是根据对象的地址计算得到的，  所以任何两个对象的 identityHashCode值总是不相等。</p>

        <h3 id="7-2-2-Runtime类与java9的-ProcessHandle"   >
          <a href="#7-2-2-Runtime类与java9的-ProcessHandle" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-2-Runtime类与java9的-ProcessHandle" class="headerlink" title="7.2.2 Runtime类与java9的 ProcessHandle"></a>7.2.2 Runtime类与java9的 ProcessHandle</h3>
      <p> Runtime类代表Java程序的运行时环境，每个Java程序都有一个与之对应的 Runtime实例，应用程序通过该对象与其运行时环境相连。应用程序不能创建自己的 Runtime实例，但可以通过 getRuntime()  方法获取与之关联的 Runtime对象。</p>
<p>与System类似的是， Runtime类也提供了 gc() 方法和 runFinalization() 方法来通知系统进行垃圾回收清理系统资源，并提供了 load(String filename) 和 loadLibrary( String libname)方法来加载文件和动态链接库。</p>
<p>Runtime类代表Java程序的运行时环境，可以访问JM的相关信息，如处理器数量、内存信息等。  如下程序所示：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		获取Java程序关联的运行时的环境</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">		System.out.println(<span class="string">&quot;处理器数量：&quot;</span>+rt.availableProcessors());</span><br><span class="line">		System.out.println(<span class="string">&quot;空闲内存数：&quot;</span>+rt.freeMemory());</span><br><span class="line">		System.out.println(<span class="string">&quot;总内存数：&quot;</span>+rt.totalMemory());</span><br><span class="line">		System.out.println(<span class="string">&quot;可用最大内存数：&quot;</span>+rt.maxMemory());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Runtime类还有一个功能——他可以直接启动一个进程来运行操作系统的命令：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//		运行记事本</span></span><br><span class="line">		rt.exec(<span class="string">&quot;notepad.exe&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字代码将启动 Windows系统里的“记事本”程序。 Runtime提供了一系列 exec() 来运行操作系统命令，关于它们之间的细微差别，请读者自行查阅API文档。  </p>
<p>通过exec启动平台上的命令之后，它就变成了一个进程，Java使用 Process来代表进程java9还新增了一个ProcessHandle接口，通过该接口可获取进程的ID、父进程和后代进程：通过该接口的onExit() 方法可在进程结束时完成某些行为。   </p>
<p>ProcessHandle还提供了一个 ProcessHandle.Info类，用于获取进程的命令、参数、启动时间、累计运行时间、用户等信息。下面程序示范了通过 ProcessHandle获取进程的相关信息。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessHandleTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="comment">//		运行记事本程序</span></span><br><span class="line">		<span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> rt.exec(<span class="string">&quot;notepad.exe&quot;</span>);</span><br><span class="line">		<span class="type">ProcessHandle</span> <span class="variable">ph</span> <span class="operator">=</span> p.toHandle();</span><br><span class="line">		System.out.println(<span class="string">&quot;进程是否运行：&quot;</span>+ph.isAlive());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程ID：&quot;</span>+ph.pid());</span><br><span class="line">		System.out.println(<span class="string">&quot;父进程：&quot;</span>+ph.parent());</span><br><span class="line"><span class="comment">//		获取ProcessHandle.Info信息</span></span><br><span class="line">		ProcessHandle.<span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> ph.info();</span><br><span class="line"><span class="comment">//		通过ProcessHandle.Info信息获取进程相关信息</span></span><br><span class="line">		System.out.println(<span class="string">&quot;进程命令：&quot;</span>+info.command());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程参数：&quot;</span>+info.arguments());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程启动时间：&quot;</span>+info.startInstant());</span><br><span class="line">		System.out.println(<span class="string">&quot;进程累计运行时间：&quot;</span>+info.totalCpuDuration());</span><br><span class="line"><span class="comment">//		通过CompletableFuture在进程结束后运行某个任务</span></span><br><span class="line">		CompletableFuture&lt;ProcessHandle&gt;cf = ph.onExit();</span><br><span class="line">		cf.thenRunAsync(()-&gt;&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;程序退出&quot;</span>);&#125;);</span><br><span class="line">		Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过粗体字获取Process对象的ProcessHandle对象，接下来即可通过ProcessHandle对象来获取进程相关信息。</p>

        <h2 id="7-3-常用类"   >
          <a href="#7-3-常用类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-常用类" class="headerlink" title="7.3 常用类"></a>7.3 常用类</h2>
      
        <h3 id="7-3-1-Object类"   >
          <a href="#7-3-1-Object类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-1-Object类" class="headerlink" title="7.3.1 Object类"></a>7.3.1 Object类</h3>
      <p> Object类是所有类、数组、枚举类的父类，也就是说，java允许把任何类型的对象赋给 Object类型的变量。当定义一个类时没有使用 extends关键字为它显式指定父类，则该类默认继承 Object父类。  因为所有的Java类都是 Object类的子类，所以任何对象都可以调用 Object类的方法。 Object  类提供了如下几个常用方法。</p>
<ul>
<li>boolean equals( Object obj)：判断指定对象该对象是否相等。此处相等的标准是，两个对象是  同一个对象，因此该 equals方法通常没有太大的实用价值。   </li>
<li>protected void finalize()：当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。</li>
<li>Class&lt;?&gt;getClass()：返回该对象的运行时类，该方法在本书第18章还有更详细的介绍。</li>
<li>int hashCode():返回该对象的 hashCode()值。在默认情况下， Object类的hashCode()方法根据该对象的地址来计算(即与 System.identityHashCode( Object x)方法的计算结果相同)。但很多类都重写了 Object 类的 hashCode()方法，不再根据地址计算其 hashCode()方法值。   </li>
<li>String toString()返回该对象的字符串表示，当程序使用System.out.printlm()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的 toString()方法返回该对象的字符串表示。Object类的toString()方法返回”运行时类名@十六进制 hash Code值”格式的字符串，但很多类都重写了Object类的 toString()方法，用于返回可以表述该对象信息的字符串。</li>
</ul>
<p>除此之外， Object类还提供了 wait()、 notify()、notifyAll()几个方法，通过这几个方法可以控制线程的暂停和运行。</p>
<p>Java还提供了一个 protected修饰的 clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于Object类提供的clone()方法使用了protected修饰，因此该方法只能被子类重写或调用。</p>
<p>自定义类实现“克隆”的步骤如下： </p>
<p>​	①自定义类实现 Cloneable接口。这是一个标记性的接口，实现该接口的对象可以实现“自我克隆”,接口里没有定义任何方法。  </p>
<p>​	②自定义类实现自己的 clone()方法。  </p>
<p>​	③实现 clone()方法时通过super.clone()；调用 Object实现的clone()方法来得到该对象的副本，并返回该对象的副本。如下程序示范了如何实现“自我克隆”。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span></span><br><span class="line">&#123;</span><br><span class="line">	String detail;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String detail)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.detail = detail;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现Cloneable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	Address address;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		address = <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;广州天河&quot;</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过调用supre.clone()来实现clone()方法</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line">			<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">return</span>(User) <span class="built_in">super</span>.clone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">		<span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">29</span>);</span><br><span class="line"><span class="comment">//		clone得到u1对象的副本</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">u2</span> <span class="operator">=</span> u1.clone();</span><br><span class="line"><span class="comment">//		判断u1和u2是否相等</span></span><br><span class="line">		System.out.println(u1 == u2);  <span class="comment">//①</span></span><br><span class="line"><span class="comment">//		判断u1和u2的address是否相等</span></span><br><span class="line">		System.out.println(u1.address = u2.address); <span class="comment">//②</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序让User类实现了Cloneable接口，而且实现clone()方法，因此User对象就可实现“自我克隆”——克隆出来的对象只是原有对象的副本。程序在①号粗体字代码处判断原有的User对象与克隆出来的User对象是否想到，程序返回false。</p>
<p>Object类提供的Clone机制只对对象里各类变量进行“简单复制”，如果实例变量的类型是引用类型，Object的clone机制也只是简单地复制这个引用变量，这样原有类型的引用类型的实例变量与克隆对象的引用类型的实例变量依然指向内存中的同一实例，所以上面程序在②时输出true。上面克隆出来的u1，u2所指向的独享在内存中的存储示意图：</p>
<p>![](C:\Program Files\Typora\image\de3267f363f41df5b666c846be80dfd.jpg)</p>
<p>Object类提供的clone()方法不仅能简单地处理“复制”对象的问题，而且这之前“自我克隆”的机制十分高效。比如clone一个包含100个元素的int[]数组，用系统默认的clone方法比静态copy方法快近2倍。</p>
<p>需要指出的是，Object类的clone()方法虽然简单、易用，但它只是一种“浅克隆”——他只克隆该对象的所有成员变量值，不会对引用类型的成员变量值所引用的对象进行克隆。如果开发者需要对对象进行“深克隆”，那么开发者需要自己进行“递归克隆”，保证所有引用类型的成员变量值所引用的对象都被复制了。</p>

        <h3 id="7-3-2-操作对象的Object工具类"   >
          <a href="#7-3-2-操作对象的Object工具类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-2-操作对象的Object工具类" class="headerlink" title="7.3.2 操作对象的Object工具类"></a>7.3.2 操作对象的Object工具类</h3>
      <p>Java 7 提供了一个Object工具类，他提供了一些工具来操作对象，这些工具方法大多是“空指针”安全的。比如不能确定一个引用变量是否为null，如果贸然的调用该对象的toString()方法，则有可能引发异常：如果使用Object使用的toString(Object o)方法，则不会引发空指针异常，当o为null时，程序将返回一个null字符串。</p>
<p>提示：Java为工具类的命名习惯是提供一个字母s，比如操作系统的工具类是Arrays，操作集合的工具类是Collections。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectsTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义一个obj变量，它的默认值为null</span></span><br><span class="line">	<span class="keyword">static</span> ObjectsTest obj;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		输出一个null对象的hashCode值，输出0</span></span><br><span class="line">		System.out.println(Objects.hash(obj));</span><br><span class="line"><span class="comment">//		输出一个null对象的toString，输出null</span></span><br><span class="line">		System.out.println(Objects.toString(obj));</span><br><span class="line"><span class="comment">//		要求obj不能为null，如果obj为null则引发异常</span></span><br><span class="line">		System.out.println(Objects.requireNonNull(obj,<span class="string">&quot;obj参数不能是null!&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序还示范了Objects提供的requireNonNull()方法，当传入的参数不为null时，该方法返回参数本身；否则会引发NullPointerException异常。该方法主要是对方法形参输入校验，例如如下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Foo</span><span class="params">(Bar bar)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//校验bar参数，如果bar参数为null将引发异常；否则this.bar被赋值为bar参数</span></span><br><span class="line">	<span class="built_in">this</span>.bar = Objects.requireNull(bar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-3-3-Java-9改进的String、StringBuffer和StringBuilder类"   >
          <a href="#7-3-3-Java-9改进的String、StringBuffer和StringBuilder类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-3-Java-9改进的String、StringBuffer和StringBuilder类" class="headerlink" title="7.3.3 Java 9改进的String、StringBuffer和StringBuilder类"></a>7.3.3 Java 9改进的String、StringBuffer和StringBuilder类</h3>
      <p>字符串就是一连串的字符序列，Java提供了 String, StringBuffer和 StringBuilder三个类来封装字符串，并提供了一系列方法来操作字符串对象。 </p>
<p>String类是不可变类，即一旦一个对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p>
<p>StringBuffer对象则代表一个字符序列可变的字符串，当一个 StringBuffer被创建以后，通过StringBuffer提供的 append()、insert()、 reverse()、 setCharAt()、 setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个 String对象。</p>
<p>StringBuilder类是JDK1.5新增的类，它也代表可变字符对象。实际上， StringBuilder和StringBuffer  基本相似，两个类的构造器和方法也基本相同。不同的是， StringBuffer是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用 StringBuilder类。</p>
<p> 提示：String、StringBuilder、StringBuffer 都实现了 CharSequence接口，因此CharSequence可认为是一个字符串的协议接口。</p>
<p>Java 9改进了字符串(包括 String、StringBulider,、StringBuilder)  的实现。在Java 9以前字符串采用  char[ ]数组来保存字符，因此字符串的每个字符占2字节；而Java 9及更新版本的JDK的字符串采用byte[ ] 数组再加一个 encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。所以Java 9及更新版本的JDK的字符串更加节省空间，但字符串的功能方法没有受到任何影响。</p>
<p>char charAt(int index)：获取字符串中指定位置的字符，其中index指的是字符串的序数，字符串的序数从0开始到length()-1。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;fkit..org&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s.charAt(5):&quot;</span>+s.charAt(<span class="number">5</span>));</span><br></pre></td></tr></table></div></figure>

<p>int compareTo(String anotherString)：比较两个字符串的大小。如果两个字符串的字符串序列相等，则返回0,；不相等时，从两个字符串的第0个字符开始比较，返回第一个不相等的字符差。另一种情况，较长的字符串的前面部分刚好是较短的字符串，返回长度差。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcdefghigklmnopq&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abcdefghig&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abcdefghigrstuvw&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s1.compareTo(s2)：&quot;</span>+s1.compareTo(s2)); <span class="comment">//返回长度差</span></span><br><span class="line">System.out.println(<span class="string">&quot;s1.compareTo(s3)：&quot;</span>+s1.compareTo(s3)); <span class="comment">//返回&#x27;k&#x27;-&#x27;r&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>​	boolean ends With(String suffix)：返回String是否一suffix结尾。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;fkit.org&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;.org&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s4.endsWith(s5)：&quot;</span>+s4.endsWith(s5));</span><br></pre></td></tr></table></div></figure>

<p>void getChar(int scrBegin,int scrEnd,char [ ] dst,int dstBegin)：该方法将字符串中从scrBegin开始，到scrEnd结束的字符串复制到dst字符串数组中，其中dstBegin为目标字符数组的起始复制位置。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> [] s6 = &#123;<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;ejb&quot;</span>;</span><br><span class="line">s7.getChars(<span class="number">0</span>, <span class="number">3</span>, s6, <span class="number">7</span>);  <span class="comment">//s6 = I love ejba</span></span><br><span class="line">System.out.println(s6);</span><br></pre></td></tr></table></div></figure>

<p>int indexOf(String str,int fromIndex)：找出str子字符串在该字符串中从fromIndex开始后第一次出现的位置。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="string">&quot;www.fkit.org&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">s9</span> <span class="operator">=</span> <span class="string">&quot;it&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s8.indexOf(&#x27;r&#x27;)：&quot;</span>+s8.indexOf(<span class="string">&#x27;r&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;s8.indexOf(&#x27;r&#x27;,2)：&quot;</span>+s8.indexOf(<span class="string">&#x27;r&#x27;</span>,<span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;s8.indexOf(s9)：&quot;</span>+s8.indexOf(s9));</span><br></pre></td></tr></table></div></figure>

<p>剩下的读者可以查阅API自己学习。</p>
<p>因为String是不可变的，多以会额外产生很多零食变量，使用StringBuffer或StringBulider就可以避免这个问题。</p>
<p>StringBulider提供了一系列的插入、追加、改变该字符串里包含的字符序列的方法。而StringBuffer与其用法完全相同，只是StringBuffer是线程安全的。</p>
<p>StringBulider、StringBuffer有两个属性：length和capaity，其中lengith，其中length属性表示其包含的字符序列的长度。与String对象的length对象的length不同的是，StringBulider、StringBuffer的length是可以改变的，可以通过length()、setLength(int len)方法来访问和修改其字符序列的长度。capaity属性表示StringBuilder类的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		通过StringBuilder类，创建一个内容可变的字符串变量</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="comment">//		追加字符串</span></span><br><span class="line">		sb.append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">//		插入</span></span><br><span class="line">		sb.insert(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//		替换</span></span><br><span class="line">		sb.replace(<span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//		删除</span></span><br><span class="line">		sb.delete(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">		System.out.println(sb);</span><br><span class="line"><span class="comment">//		反转</span></span><br><span class="line">		sb.reverse();</span><br><span class="line">		System.out.println(sb);</span><br><span class="line">		System.out.println(sb.length());</span><br><span class="line">		System.out.println(sb.capacity());<span class="comment">//输出16</span></span><br><span class="line"><span class="comment">//		改变StringBuilder的长度，将只保留前面部分</span></span><br><span class="line">		sb.setLength(<span class="number">5</span>);</span><br><span class="line">		System.out.println(sb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字部分师范看StringBulider类的追加、插入、替换、删除等操作，这些操作改变了StringBulider里的字符序列，这就是StringBulider与String之间最大的区别：StringBulider的字符序列是可变的。从程序可看到StringBulider的Length()方法返回其字符序列的长度，而capacity()返回值则比length()返回值大。</p>

        <h3 id="7-3-4-Math类"   >
          <a href="#7-3-4-Math类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-4-Math类" class="headerlink" title="7.3.4 Math类"></a>7.3.4 Math类</h3>
      <p>Java提供了的基本的+、-、*、&#x2F;、%等基本算术运算的运算符，但对于更复杂的数学运算，例如，三角函数、对数运算、指数运算等无能为力。Java提供了Math工具类来完成这些复杂的运算，Math类是一个工具类、它的构造器被定义成private的，因此无法创建Math类的对象：Math类中的所有方法都是类方法，可以直接通过类名来调用他们。Math类提供了大量静态方法之外，还提供了两个类变量：PI和E，指π和e。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*----------下面是三角运算-----------*/</span></span><br><span class="line">		<span class="comment">// 将弧度转换成角度</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Math.toDegrees(1.57)：&quot;</span> + Math.toDegrees(<span class="number">1.57</span>));</span><br><span class="line">		<span class="comment">// 将角度转换为弧度</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Math.toRadians(90)：&quot;</span> + Math.toRadians(<span class="number">90</span>));</span><br><span class="line"><span class="comment">//		计算反余弦，返回的角度范围在0.0到pi之间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Math.acos(1.2)&quot;</span> + Math.acos(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		计算反正弦，返回的角度范围在-pi/2到pi/2之间</span></span><br><span class="line">		System.out.println(Math.asin(<span class="number">0.8</span>));</span><br><span class="line"><span class="comment">//		计算反正切，返回角度范围在-pi/2到pi/2之间</span></span><br><span class="line">		System.out.println(Math.atan(<span class="number">2.3</span>));</span><br><span class="line"><span class="comment">//		计算三角余弦</span></span><br><span class="line">		System.out.println(Math.cos(<span class="number">1.57</span>));</span><br><span class="line"><span class="comment">//		计算双曲余弦</span></span><br><span class="line">		System.out.println(Math.cosh(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		计算正弦</span></span><br><span class="line">		System.out.println(Math.sin(<span class="number">1.57</span>));</span><br><span class="line"><span class="comment">//		计算双曲正弦</span></span><br><span class="line">		System.out.println(Math.sin(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		计算三角正切</span></span><br><span class="line">		System.out.println(Math.tan(<span class="number">0.8</span>));</span><br><span class="line"><span class="comment">//		计算双曲正切</span></span><br><span class="line">		System.out.println(Math.tanh(<span class="number">2.1</span>));</span><br><span class="line"><span class="comment">//		将矩形坐标（x，y）转换成极坐标（r，thet）</span></span><br><span class="line">		System.out.println(Math.atan2(<span class="number">0.1</span>,<span class="number">0.2</span>));</span><br><span class="line">		<span class="comment">/*----------下面是取整运算-----------*/</span></span><br><span class="line"><span class="comment">//		取整，返回小于目标数的最大整数</span></span><br><span class="line">		System.out.println(Math.floor(-<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		取整，返回大于目标数的最小整数</span></span><br><span class="line">		System.out.println(Math.ceil(<span class="number">1.2</span>));</span><br><span class="line"><span class="comment">//		四舍五入取整</span></span><br><span class="line">		System.out.println(Math.round(<span class="number">2.3</span>));</span><br><span class="line">		<span class="comment">/*----------下面是乘方、开方、指数运算-----------*/</span></span><br><span class="line"><span class="comment">//		计算平方根</span></span><br><span class="line">		System.out.println(Math.sqrt(<span class="number">2.3</span>));</span><br><span class="line"><span class="comment">//		其余Math功能省略，读者可查阅Math API自行学习</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-3-5-ThreadLocalRandom与Random"   >
          <a href="#7-3-5-ThreadLocalRandom与Random" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-5-ThreadLocalRandom与Random" class="headerlink" title="7.3.5 ThreadLocalRandom与Random"></a>7.3.5 ThreadLocalRandom与Random</h3>
      <p>Rondom类专门用于生成一个伪随机数，他有两个构造器：一个构造器舒勇默认的种子（以当前时间为种子），另一个构造器需要程序员显式传入一个long整数的种子。</p>
<p>ThreadLocalRandom类是Java 7新增的一个类，是Random的增强版。在并发访问的环境下，使用ThreadLocalRandom来代替Random可以减少多线程资源竞争，最终保证系统具有更好的线程安全性。</p>
<p>ThreadLocalRandom类的用法与Random类的用法基本相同，他提供了一个静态的current()方法来获取ThreadLocalRandom对象，获取该对象之后即可调用各种nextXxx()方法来获取伪随机数了。</p>
<p>可以生成浮点类型的伪随机数，也可以生成整数类型的伪随机数，也可以指定生成随机数的范围。下面关于Random类的用法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="comment">//		从这个随机数生成器的序列中返回下一个伪随机、均匀分布的布尔值。</span></span><br><span class="line"><span class="comment">//		nextBoolean的一般约定是，伪随机生成并返回一个布尔值。</span></span><br><span class="line"><span class="comment">//		值true和false产生的概率(大约)相等。</span></span><br><span class="line">		System.out.println(rand.nextBoolean());</span><br><span class="line">		<span class="type">var</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//		生成随机字节并将它们放入用户提供的字节数组中。</span></span><br><span class="line"><span class="comment">//		产生的随机字节数等于字节数组的长度。</span></span><br><span class="line">		rand.nextBytes(buffer);</span><br><span class="line">		System.out.println(Arrays.toString(buffer));</span><br><span class="line"><span class="comment">//		生成0.0~1.0之间的伪随机double数</span></span><br><span class="line">		System.out.println(rand.nextDouble());</span><br><span class="line"><span class="comment">//		生成0.0~1.0之间的伪随机float数</span></span><br><span class="line">		System.out.println(rand.nextFloat());</span><br><span class="line"><span class="comment">//		生成平均值是0.0，标准差是1.0的伪高斯数</span></span><br><span class="line">		System.out.println(rand.nextGaussian());</span><br><span class="line"><span class="comment">//		生成一个处于int整数取值范围的伪随机数</span></span><br><span class="line">		System.out.println(rand.nextInt());</span><br><span class="line"><span class="comment">//		生成0~26之间的伪随机数</span></span><br><span class="line">		System.out.println(rand.nextInt(<span class="number">26</span>));</span><br><span class="line"><span class="comment">//		生成一个处于long整数须知范围的伪随机整数</span></span><br><span class="line">		System.out.println(rand.nextLong());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Random使用一个48位的种子，如果这个类的两个实例使用同一个种子创建的，对他们以同样的顺序调用方法，则他们会产生相同的数字序列。</p>
<p>下面做了一个实验，可以看到当两个Random对象种子相同时，他们会产生相同的数字序列。值得指出的是，当使用默认的种子构造Random对象时，他们属于同一个种子。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeedTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">50</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;第一个种子为50的Random对象&quot;</span>);</span><br><span class="line">		System.out.println(r1.nextBoolean());</span><br><span class="line">		System.out.println(r1.nextDouble());</span><br><span class="line">		System.out.println(r1.nextFloat());</span><br><span class="line">		System.out.println(r1.nextGaussian());</span><br><span class="line">		<span class="type">var</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">50</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;第二个种子为50的Random对象&quot;</span>);</span><br><span class="line">		System.out.println(r2.nextBoolean());</span><br><span class="line">		System.out.println(r2.nextDouble());</span><br><span class="line">		System.out.println(r2.nextFloat());</span><br><span class="line">		System.out.println(r2.nextGaussian());</span><br><span class="line">		<span class="type">var</span> <span class="variable">r3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;种子为100的Random对象&quot;</span>);</span><br><span class="line">		System.out.println(r3.nextBoolean());</span><br><span class="line">		System.out.println(r3.nextDouble());</span><br><span class="line">		System.out.println(r3.nextFloat());</span><br><span class="line">		System.out.println(r3.nextGaussian());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上面的运行结果可以看出，只要两个Random对象的种子相同，而且&#x3D;&#x3D;方法的调用顺序也相同&#x3D;&#x3D;，他们就会产生相同的数字序列。也就是说，Random产生的数字并不是随机的，而是伪随机。</p>
<p>为了避免两个Random对象产生相同的数字序列，通常建议使用当前时间作为Random对象的种子：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br></pre></td></tr></table></div></figure>

<p>在多线程环境下使用ThreadLocalRandom的方式使用Random基本类似，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadLocalRandom</span> <span class="variable">rand</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line"><span class="comment">//生成一个4~20之间的随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">vall</span> <span class="operator">=</span> rand.nextInt(<span class="number">4</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//生成一个2.0~10.0之间的伪随机浮点数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> rand.nextDouble(<span class="number">2.0</span>~<span class="number">10.0</span>);</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-3-6-BigDecimal类"   >
          <a href="#7-3-6-BigDecimal类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-6-BigDecimal类" class="headerlink" title="7.3.6 BigDecimal类"></a>7.3.6 BigDecimal类</h3>
      <p>前面介绍double、fioat两种基本浮点类型时已经指出，这两个基本类型的浮点数容易丢失精度。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 + 0.01 = &quot;</span>+(<span class="number">0.05</span>+<span class="number">0.01</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;1.0 - 0.42 = &quot;</span>+(<span class="number">1.0</span>-<span class="number">0.42</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;123.3/100 = &quot;</span>+(<span class="number">123.3</span>/<span class="number">100</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;4.015*100 = &quot;</span> + (<span class="number">4.015</span>*<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序运行结果表明，Java的 double类型会发生精度丢失，尤其在进行算术运算时更容易发生这种情况。不仅是Java,很多编程语言也存在这样的问题。</p>
<p>为了能精确表示、计算浮点数，Java提供了BigDecimal类，该类提供了大量的构造器用于创建BigDecimal对象，包括把所有的基本数值类型变量转换成一个BigDecimal对象，也包括利用数字字符串、数字字符数组来创建BigDecimal对象。  </p>
<p>查看 BigDecimal 类的 BigDecimal( double val)构造器的详细说明时，可以看到不推荐使用该构造器的说明，主要是因为使用该构造器时有一定的不可预知性。当程序使用 new BigDecimal(0.1)来创建一个 BigDecimal 对象时，它的值并不是0.1,它实际上等于一个近似0.1的数。这是因为0.1无法准确地表示为double浮点数，所以传入 BigDecimal构造器的不会正好等于0.1(虽然表面上等于该值)。  </p>
<p>如果使用 BigDecimal( String val)构造器的结果是可预知的——写入 new BigDecimall(0.1)将创建  个 BigDecimal,它正好等于预期的0.1。因此通常建议优先使用基于 String的构造器。</p>
<p>如果必须使用 double 浮点数作为 BigDecimal构造器的参数时，不要直接将该 double浮点数作为构造器参数创建 BigDecimal对象，而是应该通过 BigDecimal.valueOf(double value)静态方法来创建 BigDecimal对象。</p>
<p>BigDecimal类提供了add()、 subtract()、 multiply()、dvide()、pow()等方法对精确浮点数进行常规算术的基本运算：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.05&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">f2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.01</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.05</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;使用String作为BigDecimal构造器参数：&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 + 0.01 = &quot;</span> + f1.add(f2));</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 - 0.01 = &quot;</span> + f1.subtract(f2));</span><br><span class="line">		System.out.println(<span class="string">&quot;...............&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;使用double作为BigDecimal构造器参数：&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 + 0.01 = &quot;</span> + f3.add(f2));</span><br><span class="line">		System.out.println(<span class="string">&quot;0.05 - 0.01 = &quot;</span> + f3.subtract(f2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![image-20210328100130103](C:\Program Files\Typora\image\image-20210328100130103.png)</p>
<p>上面程序中f1和f3都是基于0.05创建的BigDecimal对象，其中f1是基于“0.05”字符串，但是f3是基于0.05的double浮点数。所以创建BigDecimal对象时，一定要使用String对象作为参数构造器，而不是直接使用double数字。</p>
<p>如果程序要求对double浮点数进行加减乘除，则需要现将double类型数值包装厂BigDecimal对象，调用BigDecimal对象的方法执行运算后再将结果转换成double型,比较繁琐，可以使用BigDecimal为基础定义一个Arith工具类：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arith</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	默认除法运算精度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEF_DIV_SCALE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//	构造器私有，让这个类不能实例化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Arith</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">//	提供精确的加法运算</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		使用double . tostring (double)方法提供的规范的double字符串表示形式，将double转换为BigDecimal。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(d1);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(d2);</span><br><span class="line"><span class="comment">//		将此BigDecimal转换为double。</span></span><br><span class="line">		<span class="keyword">return</span> b1.add(b2).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	提供精确的减法运算</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sub</span><span class="params">(<span class="type">double</span> d3,<span class="type">double</span> d4)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">b3</span> <span class="operator">=</span> BigDecimal.valueOf(d3);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b4</span> <span class="operator">=</span> BigDecimal.valueOf(d4);</span><br><span class="line">		<span class="keyword">return</span> b3.subtract(b4).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	提供精确的乘法运算</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">mul</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(d1);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(d2);</span><br><span class="line"><span class="comment">//		将此BigDecimal转换为double。</span></span><br><span class="line">		<span class="keyword">return</span> b1.multiply(b2).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	提供（相对）精确的除法运算，当发生除不尽时</span></span><br><span class="line"><span class="comment">//	精确到小数点后10位数字后四舍五入</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">div</span><span class="params">(<span class="type">double</span> d3,<span class="type">double</span> d4)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">b3</span> <span class="operator">=</span> BigDecimal.valueOf(d3);</span><br><span class="line">		<span class="type">var</span> <span class="variable">b4</span> <span class="operator">=</span> BigDecimal.valueOf(d4);</span><br><span class="line"><span class="comment">/*		四舍五入模式向“最近的邻居”舍入，除非两个邻居的距离相等，这种情况下取四舍五入。</span></span><br><span class="line"><span class="comment">		表现为舍入模式。</span></span><br><span class="line"><span class="comment">		discardedfraction≥0.5则为UP;</span></span><br><span class="line"><span class="comment">		否则，表现为舍入模式。down。</span></span><br><span class="line"><span class="comment">		注意，这是学校里常用的舍入模式。</span></span><br><span class="line"><span class="comment">		该模式对应于IEEE 754-2019 round - dingattribute roundTiesToAway。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="keyword">return</span> b3.divide(b4,DEF_DIV_SCALE,RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(Arith.add(<span class="number">0.05</span>, <span class="number">0.01</span>));</span><br><span class="line">		System.out.println(Arith.sub(<span class="number">1.0</span>, <span class="number">0.42</span>));</span><br><span class="line">		System.out.println(Arith.mul(<span class="number">4.015</span>, <span class="number">100</span>));</span><br><span class="line">		System.out.println(Arith.div(<span class="number">123.4</span>, <span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>上面运行的结果才是期望的记过，这也正是使用BigDecimal类的作用。</p>

        <h2 id="7-4-Java-8的日期、时间类"   >
          <a href="#7-4-Java-8的日期、时间类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-Java-8的日期、时间类" class="headerlink" title="7.4 Java 8的日期、时间类"></a>7.4 Java 8的日期、时间类</h2>
      <p>Java原本提供了Date和 Calendar用于处理日期、时间的类，包括创建日期、时间对象，获取系统当前日期、时间等操作。但Date不仅无法实现国际化，而且它对不同属性也使用了前后矛盾的偏移量，  比如月份与小时都是从0开始的，月份中的天数则是从1开始的，年又是从1900开始的，而 java.util.Calendar则显得过于复杂，从下面介绍中会看到传统Java对日期、时间处理的不足。ava8吸取了 Joda-Time库(一个被广泛使用的日期、时间库)的经验，提供了一套全新的日期时间库。</p>

        <h3 id="7-4-1Date类"   >
          <a href="#7-4-1Date类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-1Date类" class="headerlink" title="7.4.1Date类"></a>7.4.1Date类</h3>
      <p>Java提供了Date类来处理日期、时间(此处的Date是指java.util包下的Date类，而不是java.sql 包下的Date类),Date对象既包含日期，也包含时间。Date类从JDK1.0起就开始存在了，但正因为它历史悠久，所以它的大部分构造器、方法都已经过时，不再推荐使用了。  </p>
<p>Date类提供了6个构造器，其中4个已经 Deprecated(java不再推荐使用，使用不再推荐的构造器时编译器会提出警告信息，并导致程序性能、安全性方面的问题),剩下的两个构造器如下 :</p>
<ul>
<li>Date():生成一个代表当前日期时间的date对象。该构造器在底层调用 System. currentTimeMillis()  获得long整数作为日期参数。</li>
<li>Date(long date):根据指定的long型整数来生成一个Date对象。该构造器的参数表示创建的Date  对象和GMT1970年1月1日00:00:00之间的时差，以毫秒作为计时单位与Date构造器相同的是，Date对象的大部分方法也 Deprecated了，剩下为数不多的几个方法。   </li>
<li>boolean after(Date when):测试该日期是否在指定日期when之后。   </li>
<li>boolean before( Date when):测试该日期是否在指定日期when之前。  </li>
<li>long getTime():返回该时间对应的long型整数，即从GMT1970-01-01 00:00:00到该Date对象之间的时间差，以毫秒作为计时单位   </li>
<li>void setTime( (long time):设置该Date对象的时间。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//		获取当前时间之后100ms的时间</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+<span class="number">100</span>);</span><br><span class="line">		System.out.println(d2);</span><br><span class="line">		System.out.println(d1.compareTo(d2));</span><br><span class="line">		System.out.println(d1.before(d2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>总体来说，Date是一个设计相当糟糕的类，因此Java官方推荐尽量少用Date的构造器和方法。如果需要对日期、时间进行加减运算，或者获取指定时间的年、月、日、时、分、秒信息，可使用Calendar工具类。</p>

        <h3 id="7-4-2-Calendar类"   >
          <a href="#7-4-2-Calendar类" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-2-Calendar类" class="headerlink" title="7.4.2 Calendar类"></a>7.4.2 Calendar类</h3>
      <p>因为Date类在设计上存在一些缺陷，所以Java提供了Calendar来更好的处理日期和时间。Calendar是一个抽象类，他用来表示日历。</p>
<p>全世界通常选择最普及、最通用的日历：Gregorian Calendar，也就是日常介绍年份时常用的“公元几几年”  。</p>
<p>Calendar类本身是一个抽象类，它是所有日历类的板，并提供了一些所有日历通用的方法；但它本身不能直接实例化，程序只能创建 Calendar子类的实例，Java本身提供了一个 GregorianCalendar类，一个代表格里高利日历的子类，它代表了通常所说的公历。</p>
<p>当然，也可以创建自己的 Calendar子类，然后将它作为 Calendar对象使用(这就是多态)。因为篇幅关系，本章不会详细介绍如何扩展 Calendar子类，读者可通过互联网查看 Calendar各子类的源码来学习。</p>
<p>Calendar类是一个抽象类，所以不能使用构造器来创建 Calendar对象。但它提供了几个静态   getlnstance()方法来获取 Calendar对象，这些方法根据 TImeZone, Locale类来获取特定的 Calendar,如  果不指定TimeZone、 Locale,则使用默认的 TimeZone、 Locale来创建 Calendar.</p>
<p>Calendar与Date都是表示日期的工具类，他们直接可以自由转换：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个默认的Calendar对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//从Calendar中取出Date对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">date</span> <span class="operator">=</span> .getTime();</span><br><span class="line"><span class="comment">//通过Date对象获取对应的Calendar对象</span></span><br><span class="line"><span class="comment">//因为Calendar/GregorianCalendar没有构造函数可以接收Date对象</span></span><br><span class="line"><span class="comment">//所以必须创建一个Calendar实例，然后调用其setTime()方法。</span></span><br><span class="line"><span class="type">var</span> <span class="variable">calendar2</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar2.setTime(date);</span><br></pre></td></tr></table></div></figure>

<p> Calender类提供了大量修改日期时间的方法，常用方如下：</p>
<ul>
<li>void add(int field,int amount ):  根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li>Int get(int field): 返回指定日历字段的值。</li>
<li>int getActualMaximum(int field):返回指定日历字段可能拥有的最大值。例如月，最大值为11</li>
<li>int getActualMinimum(int field):返回指定日历字段可能拥有的最小值。例如月，最小值为0  </li>
<li>void roll(int field, Int amount):与add()方法类似，区别在于加上 amount后超过了该字段所能表示的最大范围时，也不会向上一个字段进位。</li>
<li>void set(int field, int value):将给定的日历字段设置为给定值 。</li>
<li>void set(int year,, int month, int date):设置 Calendar对象的年、月、日三个字段的值。</li>
<li>void set(int year, int month, int date, int hourOfDay, int minute, Int second):设置 Calendar对象的年、  月、日、时  分、秒6个字段的值。</li>
</ul>
<p>上面的很多方法都需要一个int类型的field参数，field是 Calendar类的类变量，如Calendar.YEAR、Calendar. MONTH等分别代表了年、月、日、小时分钟、秒等时间字段。需要指出的是， Calendar. MONTH  字段代表月份，<strong>月份的起始值不是1,而是0</strong>,所以要设置8月时，用7而不是8，如下程序示范了 Calendar  类的常规用法。 </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">YEAR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MONTH</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//		取出年</span></span><br><span class="line">		System.out.println(c.get(YEAR));<span class="comment">//粗</span></span><br><span class="line">		System.out.println(c.get(MONTH));<span class="comment">//粗</span></span><br><span class="line">		System.out.println(c.get(DATE));<span class="comment">//粗</span></span><br><span class="line">		c.set(<span class="number">2003</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">32</span>,<span class="number">23</span>);<span class="comment">//粗//2003-11-23 12.32.23</span></span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">		c.add(YEAR, -<span class="number">1</span>);<span class="comment">//粗//2002-11-23 12.32.23</span></span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">		c.roll(MONTH, -<span class="number">8</span>);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中粗体字代码示范了Calendar类的用法，Calendar可以很灵活的改变它对应的日期。</p>
<p>上面程序中使用了静态导入，它导入了Calendar类里的所有类变量，所以上面程序可以直接使用Calendar类的YEAR、MONTH、DATE等类变量。</p>
<p>Calendar类还有如下几个注意点。</p>

        <h4 id="1-add与roll的区别"   >
          <a href="#1-add与roll的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-add与roll的区别" class="headerlink" title="1.add与roll的区别"></a>1.add与roll的区别</h4>
      <p>add(int field,int amount)的功能非常强大，add主要用于改变Calendar的特定字段的值。如果需要增加某字段的值，则让amount为整数；如果需要减少某字段的值，则让amout为负数即可。</p>
<p>add(int field,int amount)有如下两条规则。</p>
<ul>
<li>当被修改的字段超出它允许的范围的时候，会发生进位，即上一级字段也会增大：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">call</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">call.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//2003-8-23</span></span><br><span class="line">call.add(MONTH,<span class="number">6</span>);<span class="comment">//2004-2-23</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>如果下一级字段也需要改变，那么该字段会修正到变化最小的值：</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cal2</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">cal2.set(<span class="number">1003</span>,<span class="number">7</span>,<span class="number">31</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//因为进位后月份改为2月，2月没有31日，自动变成29日</span></span><br><span class="line">val2.add(MONTH,<span class="number">6</span>);<span class="comment">//2003-8-31 → 2004-2-29</span></span><br></pre></td></tr></table></div></figure>

<p>对于上面的例子，8-31就会变成2-29.因为MOUTH的下一级字段是DATE，从31到29改变最小，所以上面2003-8-31的MOUTH字段增加6后，不是变成2004-3-2，而是变成2004-2-29。</p>
<p>roll()的规则与add()的处理规则不同：当贝修改的字段超出它允许的范围时，上一级字段不会增大。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cal3</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">cal3.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//MOUTH字段“进位”，但是YEAR并不增加</span></span><br><span class="line">val3.roll(MOUTH,<span class="number">6</span>);<span class="comment">//2003-8-23 → 2003-2-23</span></span><br></pre></td></tr></table></div></figure>

<p>下一级字段的处理规则用户add()相似;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cal4</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">cal3.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">31</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//MOUTH字段“进位”，但是YEAR并不增加</span></span><br><span class="line">val3.roll(MOUTH,<span class="number">6</span>);<span class="comment">//2003-8-23 → 2003-2-28</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="2-设置Calendar的容错率"   >
          <a href="#2-设置Calendar的容错率" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-设置Calendar的容错率" class="headerlink" title="2.设置Calendar的容错率"></a>2.设置Calendar的容错率</h4>
      <p>调用Calendar对象的set()方法来改变指定字符串的值时，有可能传入一个不合法的参数，例如为MOUTH字段设置13，这将会导致如下后果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LenientTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOUTH</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Calendar</span> <span class="variable">ca1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//		如果是字段YEAR字段加一，MOUTH字段为1（2月）</span></span><br><span class="line">		ca1.set(MOUTH,<span class="number">13</span>);<span class="comment">//①</span></span><br><span class="line">		System.out.println(ca1.getTime());</span><br><span class="line"><span class="comment">//		关闭容错性</span></span><br><span class="line">		ca1.setLenient(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//		导致运行时异常</span></span><br><span class="line">		ca1.set(MOUTH, <span class="number">13</span>);<span class="comment">//②</span></span><br><span class="line">		System.out.println(ca1.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>①和②完全相似，但他们的结果不同：①处代码可以正常运行，因为设置MOUTH字段的值为13，将导致YEAR字段加一；②处代码将会导致运行时异常，因为设置的MOUTH字段的值超出了MOUTH字段允许的范围。关键在于程序粗体字的运行，Calendar设置了一个setLenient()用于设置它的容错率，Calendar默认支持好的容错性，通过setLenient(false)可以关闭它的容错率，让他进行严格的参数检查。</p>
<p>Calendar有两种日历模式：</p>
<p>​	lenient模式：每个字段可接受超出它允许范围的值</p>
<p>​	non-lenient模式时，如果某个时间字段设置超出了它允许的取值范围，程序将抛出异常。</p>

        <h4 id="3-set-方法延迟修改"   >
          <a href="#3-set-方法延迟修改" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-set-方法延迟修改" class="headerlink" title="3.set()方法延迟修改"></a>3.set()方法延迟修改</h4>
      <p>set(f,value)方法将日历字段f修改为value，此外它还设置了一个内部成员变量，以指示日历字段f已经被更改。尽管日历字段f是立即更改的，但该Calendar所代表的的时间却不会立即修改，直到下次调用get()，set()，getTimeInMillis()，add()，或roll()时才会重新计算日历的时间。这被称为set()方法延迟修改，采用延迟修改的优势是多次调用set()不会触发多次不必要的计算（需要计算出一个代表实际时间的long型整数）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">		cal.set(<span class="number">2003</span>,<span class="number">7</span>,<span class="number">31</span>);</span><br><span class="line"><span class="comment">//		将月份设置为9月，但是9月没有31日</span></span><br><span class="line"><span class="comment">//		如果立即修改，系统将会把cal自动调整到10月1日</span></span><br><span class="line">		cal.set(Calendar.MONTH, <span class="number">8</span>);</span><br><span class="line"><span class="comment">//		System.out.println(cal.getTime());//①</span></span><br><span class="line"><span class="comment">//		设置DATE字段为5</span></span><br><span class="line">		cal.set(Calendar.DATE,<span class="number">5</span>);<span class="comment">//②</span></span><br><span class="line">		System.out.println(cal.getTime());<span class="comment">//③</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>程序将①注释了，因为Calendar的set()方法具有延迟修改的特性，即调用set()方法后Calendar实际上并未计算真实的日期，他只是使用内部成员变量表记录MOUTH字段被修改为8，接着程序设置DATE字段值为5，程序内部在此记录DATE——就是9月5日，因此③输出2003-9-5。</p>

        <h3 id="7-4-3新的日期、时间包"   >
          <a href="#7-4-3新的日期、时间包" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-3新的日期、时间包" class="headerlink" title="7.4.3新的日期、时间包"></a>7.4.3新的日期、时间包</h3>
      <p>Jva8专门新增了一个java.time包，该包下包含了如下常用的类。   </p>
<ul>
<li><p>Clock:该类用于获取指定时区的当前日期、时间。该类可取代 System类的currentTimeMillis()  方法，而且提供了更多方法来获取当前日期、时间。该类提供了大量静态方法来获取 Clock对象。</p>
</li>
<li><p>Duration:该类代表持续时间。该类可以非常方便地获取一段时间。  </p>
</li>
<li><p>Instant:代表一个具体的时刻，可以精确到纳秒。该类供了静态的now()方法来获取当前时刻，  也提供了静态的 now(Clock clock)方法来获取 clock对应的时刻。除此之外，它还提供了一系列   minusXXX() 方法在当前时刻基础上减去一段时间，也提供了 plusXxx()方法在当前时刻基础上加上一段时间。</p>
</li>
<li><p>LocalDate:该类代表不带时区的日期，例如2007-12-03。该类提供了静态的now方法来获取  当前日期，也提供了静态的now( Clock cloc)方法来获取 clock对应的日期。除此之外，它还提  供了 minusXxx()方法在当前年份基础上减去几年、几月、几周或几日等，也提供了 plusXxx()  方法在当前年份基础上加上几年、几月、几周或几日等</p>
</li>
<li><p>LocalTime:该类代表不带时区的时间，例如10:15:30。该类提供了静态的now方法来获取当  前时间，也提供了静态的now( (Clock clock)方法来获取 clock对应的时间。除此之外，它还提供  了 minus Xxx()方法在当前年份基础上减去几小时、几分、几秒等，也提供了 plusXxx()方法在当  前年份基础上加上几小时、几分、几秒等。</p>
</li>
<li><p>LocaIDate Time:该类代表不带时区的日期、时间，例如2007-12-07T10:15:30。该类提供了静态的now方法来获取当前日期、时间，也提供了静态的now( Clock clock)方法来获取 clock对应的日期、时间。除此之外，它还提供了 minusXxx()方法在当前年份基础上减去几年、几月、几  日、几小时、几分、几秒等，也提供了 plusXxx()方法在当前年份基础上加上几年、几月、几日、  几小时、几分、几秒等。</p>
</li>
<li><p>MonthDay:该类仅代表月日，例如-04-12。该类提供了静态的now方法来获取当前月日，也提供了静态的     now(Clock clock)方法来获取 clock对应的月日  </p>
</li>
<li><p>Year:该类仅代表年，例如2014。该类提供了静态的now方法来获取当前年份，也提供了静态的now (Clock clock)方法来获取 clock对应的年份。除此之外，它还提供了 minusYears()方法  在当前年份基础上减去几年，也提供了 plusYears()方法在当前年份基础上加上几年。</p>
</li>
<li><p>Year Month:该类仅代表年月，例如2014-04。该类提供了静态的now方法来获取当前年月，  也提供了静态的 now(Clock clock)方法来获取clok对应的年月。除此之外，它还提供了minusXxx()方法在当前年月基础上减去几年、几月，也提供了 plusXxx()方法在当前年月基础上  加上几年、几月。</p>
</li>
<li><p>ZonedDateTime:该类代表一个时区化的日期、时间。  </p>
</li>
<li><p>Zoneld:该类代表一个时区。</p>
</li>
<li><p>DayOfWeek：这是一个枚举类，定义了周日到周六的枚举值   </p>
</li>
<li><p>Month:这也是一个枚举类，定义了一月到十二月的枚举值。</p>
</li>
</ul>
<p>下面通过一个简单的程序来示范这些类的用法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Clock;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"><span class="keyword">import</span> java.time.MonthDay;</span><br><span class="line"><span class="keyword">import</span> java.time.Year;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewDatePackageTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		-------下面关于Clock的用法---------</span></span><br><span class="line"><span class="comment">//		获取当前的Clock</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line"><span class="comment">//		通过Clock获取当前时刻</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前时刻为&quot;</span>+clock.instant());</span><br><span class="line"><span class="comment">//		获取Clock对应的毫秒数，与System.currentTimeMills()输出相同</span></span><br><span class="line">		System.out.println(clock.millis());</span><br><span class="line">		System.out.println(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//		--------下面关于Duration用法--------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> Duration.ofSeconds(<span class="number">6000</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;6000秒相当于&quot;</span>+d.toMinutes()+<span class="string">&quot;分&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;6000秒相当于&quot;</span>+d.toHours()+<span class="string">&quot;小时&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;6000秒相当于&quot;</span>+d.toDays()+<span class="string">&quot;天&quot;</span>);</span><br><span class="line"><span class="comment">//		在clock基础上增加6000秒，返回新的clock</span></span><br><span class="line"><span class="comment">//		offset:获取一个时钟，从添加了指定持续时间的指定时钟返回瞬时值</span></span><br><span class="line">		<span class="type">var</span>  <span class="variable">clock2</span> <span class="operator">=</span> Clock.offset(clock, d);</span><br><span class="line"><span class="comment">//		可以看出clock与clock2相差的时间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前时刻加6000秒为：&quot;</span>+clock2.instant());</span><br><span class="line"><span class="comment">//		-------下面关于Instant的用法---------</span></span><br><span class="line"><span class="comment">//		获取当前时间</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">		System.out.println(instant);</span><br><span class="line">		<span class="type">var</span> <span class="variable">instant2</span> <span class="operator">=</span> instant.plusSeconds(<span class="number">6000</span>);</span><br><span class="line">		System.out.println(instant2);</span><br><span class="line"><span class="comment">//		根据字符串解析instant对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">instant3</span> <span class="operator">=</span> Instant.parse(<span class="string">&quot;2014-02-03T20:18:09Z&quot;</span>);</span><br><span class="line">		System.out.println(instant3);</span><br><span class="line">		<span class="type">var</span> <span class="variable">instant4</span> <span class="operator">=</span> instant3.plus(Duration.ofHours(<span class="number">1</span>).plusMinutes(<span class="number">4</span>));</span><br><span class="line">		System.out.println(instant4);</span><br><span class="line"><span class="comment">//		获取Instant4 5天前的时刻</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">instant5</span> <span class="operator">=</span> instant4.minus(Duration.ofDays(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//		-------下面关于LoaclDate的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">localdate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">		System.out.println(localdate);</span><br><span class="line"><span class="comment">//		获取2021年的第219天</span></span><br><span class="line">		localdate = LocalDate.ofYearDay(<span class="number">2021</span>, <span class="number">219</span>);</span><br><span class="line">		System.out.println(localdate);</span><br><span class="line"><span class="comment">//		设置为2021年5月21日</span></span><br><span class="line">		localdate = LocalDate.of(<span class="number">2021</span>, Month.MAY, <span class="number">21</span>);</span><br><span class="line">		System.out.println(localdate);</span><br><span class="line"><span class="comment">//		-------下面关于LocalTime的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">localtime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">		System.out.println(localtime)</span><br><span class="line">		localtime = LocalTime.of(<span class="number">22</span>, <span class="number">01</span>);</span><br><span class="line">		System.out.println(localtime);</span><br><span class="line"><span class="comment">//		返回一天中的5503秒</span></span><br><span class="line">		localtime = LocalTime.ofSecondOfDay(<span class="number">5503</span>);</span><br><span class="line">		System.out.println(localtime);</span><br><span class="line"><span class="comment">//		-------下面关于LocalDateTime的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">localdatetime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">		System.out.println(localdatetime);</span><br><span class="line">		<span class="type">var</span> <span class="variable">future</span> <span class="operator">=</span> localdatetime.plusHours(<span class="number">25</span>).plusMinutes(<span class="number">3</span>);</span><br><span class="line">		System.out.println(future);</span><br><span class="line"><span class="comment">//		-------下面关于Year,YearMonth,MonthDay的用法---------</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">year</span> <span class="operator">=</span> Year.now();</span><br><span class="line">		System.out.println(year);</span><br><span class="line">		<span class="type">var</span> <span class="variable">futureyear</span> <span class="operator">=</span> year.plusYears(<span class="number">5</span>);</span><br><span class="line">		System.out.println(futureyear);</span><br><span class="line"><span class="comment">//		根据指定月份获取YearMonth</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ym</span> <span class="operator">=</span> year.atMonth(<span class="number">10</span>);</span><br><span class="line">		System.out.println(ym);</span><br><span class="line">		ym = ym.plusYears(<span class="number">5</span>).minusYears(<span class="number">3</span>);</span><br><span class="line">		System.out.println(ym);</span><br><span class="line">		<span class="type">var</span> <span class="variable">md</span> <span class="operator">=</span> MonthDay.now();</span><br><span class="line">		System.out.println(md);</span><br><span class="line">		<span class="type">var</span> <span class="variable">md2</span> <span class="operator">=</span> MonthDay.of(<span class="number">5</span>, <span class="number">22</span>);</span><br><span class="line">		System.out.println(md2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该程序就是这些常用类的用法示例，这些API和他们的方法都非常简单。</p>

        <h2 id="7-5-正则表达式"   >
          <a href="#7-5-正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-5-正则表达式" class="headerlink" title="7.5 正则表达式"></a>7.5 正则表达式</h2>
      <p>正则表达式是一个强大的字符串处理工具，可以对字符串进行查找、提取、分割、替换等操作。String类里也提供了几个特殊的方法：</p>
<ul>
<li>boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。</li>
<li>String replaceAll(String regex,String replacement)：将该字符串中所匹配regex的子串替换成replacement。</li>
<li>String replaceFirst(String regex,String replacement)：将该字符串中第一个匹配regex的子串替换成replacement。</li>
<li>String[ ] split(String regex)：以regex作为分隔符，把该字符串分割成多个子串。</li>
</ul>
<p>Java还提供Pattern和Matcher两个类专门用于提供正则表达式支持。</p>
<p>Matcher类：一种引擎，通过解释模式对字符序列执行匹配操作。</p>
<p>匹配器是通过调用模式的匹配器方法来创建的。一旦创建，匹配器可用于执行三种不同的匹配操作:</p>
<p>•matcher():方法尝试将整个输入序列与模式匹配。</p>
<p>•lookingAt():方法尝试匹配输入序列，从开头开始，与模式匹配。</p>
<p>•find():方法扫描输入序列，寻找下一个匹配模式的子序列。</p>
<p>每个方法都返回一个指示成功或失败的布尔值。关于成功匹配的更多信息可以通过查询匹配器的状态来获得。</p>
<p>匹配器在称为region的输入子集中查找匹配项。默认情况下，该区域包含匹配器的所有输入。可以通过region方法修改region，通过regionStart和regionEnd方法查询region。区域边界与某些模式结构交互的方式可以改变。</p>
<p>这个类还定义了用新字符串替换匹配的子序列的方法，如果需要，可以从matchresult计算新字符串的内容。<br>可以同时使用appendReplacement和appendTail方法，以便将结果收集到现有的字符串缓冲区或字符串生成器中。<br>或者，可以使用更方便的replaceAll方法创建一个字符串，其中输入序列中的每个匹配子序列都被替换。</p>

        <h3 id="7-5-1-创建正则表达式"   >
          <a href="#7-5-1-创建正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-5-1-创建正则表达式" class="headerlink" title="7.5.1 创建正则表达式"></a>7.5.1 创建正则表达式</h3>
      <p>正则表达式所支持的合法字符</p>
<div class="table-container"><table>
<thead>
<tr>
<th>字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>字符x（x可代表任何合法字符）</td>
</tr>
<tr>
<td>\0mnn</td>
<td>八进制数0mnn所表示的字符</td>
</tr>
<tr>
<td>\xhh</td>
<td>十六进制xhh所表示的字符</td>
</tr>
<tr>
<td>\uhhhh</td>
<td>十六进制uhhhh所表示的字符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\a</td>
<td>报警符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape符</td>
</tr>
<tr>
<td>\cx</td>
<td>x对应的控制符。例如，\cM匹配ctrl+M。x必须为A~Z或a ~ z之一。</td>
</tr>
</tbody></table></div>
<p>正则表达式中的特殊字符</p>
<div class="table-container"><table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配一行的结尾。要匹配$字符本身，请使用\$</td>
</tr>
<tr>
<td>^</td>
<td>匹配一行的开头。要匹配^字符本身，请使用\ ^</td>
</tr>
<tr>
<td>()</td>
<td>标记子表达式的开始和结束位置。要匹配这些字符，请使用\(和\)</td>
</tr>
<tr>
<td>[ ]</td>
<td>用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\[和\]</td>
</tr>
<tr>
<td>{ }</td>
<td>用于标记前面子表达式的出现频度。要匹配这些字符，请使用\{和\}</td>
</tr>
<tr>
<td>*</td>
<td>指定前面子表达式可以出现零次或多次。要匹配*字符本身，请使用\ *</td>
</tr>
<tr>
<td>+</td>
<td>指定前面子表达式可以出现一次或多次。要匹配+字符本身，请使用\+</td>
</tr>
<tr>
<td>?</td>
<td>指定前面子表达式可以出现零次或一次。要匹?字符本身，请使用\?</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符n之外的任何单字符。要匹配.字符本身，请使用\.</td>
</tr>
<tr>
<td>\</td>
<td>用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符，请用\\</td>
</tr>
<tr>
<td>|</td>
<td>指定两项之间任选一项。如果要匹配|字符本身，请使用\</td>
</tr>
</tbody></table></div>
<p>将上面多个字符拼起来，就可以创建一个正则表达式。例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u0041\\\\&quot;</span><span class="comment">//匹配A\</span></span><br><span class="line"><span class="string">&quot;\u0061\t &quot;</span> <span class="comment">//匹配a&lt;制表符&gt;  </span></span><br><span class="line"><span class="string">&quot;\\?\\[&quot;</span><span class="comment">//匹配?[</span></span><br></pre></td></tr></table></div></figure>

<p>注意：可能有读者觉得第一个正则表达式中怎么有那么多反斜杠啊?这是由于Java字符串中反斜杠本身需要转义，因此两个反斜杠(\\)实际上相当于一个(前一个用于转义)。</p>
<p>上面的正则表达式依然只能匹配单个字符，这是因为还未在正则表达式中使用“通配符”,“通配符是可以匹配多个字符的特殊字符。正则表达式中的通配符”远远超出了普通通配符的功能，它被称  预定义字符，正则表达式支持如下表所示的预定义字符。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>预定义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>可以匹配任何字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配0~9的所有数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有的非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有的单词字符，包括0~9所有数字、26个英文字母和下画线(_)</td>
</tr>
<tr>
<td>\W</td>
<td>匹配所有的非单词字符</td>
</tr>
</tbody></table></div>
<p>提示：上面的7个预定义字符其实很容易记忆，d是dit的意思，代表数字；s是 space  的意思，代表空白；w是word的意思，代表单词。d、s、w的大写形式恰好匹配与之相反的字符。<br>有了上面的预定义字符后，接下来就可以创建更强大的正则表达式了。例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c\\wt  <span class="comment">//可以匹配cat、cbt、cct、cot、c9t等一批字符串</span></span><br><span class="line">\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d <span class="comment">//匹配如000-000-0000形式的电话号码</span></span><br></pre></td></tr></table></div></figure>

<p>在一些特殊情况下，例如，若只想匹配a~f的母，或者匹配除ab之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有如下表所示的几种形式。</p>
<p>方括号表达式</p>
<div class="table-container"><table>
<thead>
<tr>
<th>方括号表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>表示枚举</td>
<td>例如[abc],表示a、b、c其中任意一个字符；[gz]，表示g,z其中任意一个字符</td>
</tr>
<tr>
<td>表示范 围：-</td>
<td>例如[a-f],表示a<del>f范围内的任意字符；[\\u0041-\\u0056],表示十六进制字符\u0041到\u0056范围的字符。表示范围：  范围可以和枚举结合使用，如[a-cx-z],表示a</del>c、x ~z范围内的任意字符</td>
</tr>
<tr>
<td>表示求否：^</td>
<td>例如[^abc],表示非a、b、c的任意字符；[^a-f]表示不是a-f 范围内的任意字符</td>
</tr>
<tr>
<td>表示“与”运算，&amp;&amp;</td>
<td>例如[a-z&amp;&amp;[def]],求a<del>z和[def]的交集，表示d、e或f  <br /> [a-z&amp;&amp;[ ^bc]],a-z范围内的所有字符，除b和c之外，即[ad-z],<br />[a-z&amp;&amp;[ ^m-p]]范围内的所有字符，除m</del>p范围之外的字符，即[a-lq-z]</td>
</tr>
<tr>
<td>表示“并”运算</td>
<td>并运算与前面的枚举类似。例如[a-d[m-p]],表示[a-dm-p]即a~d,m ~p。</td>
</tr>
</tbody></table></div>
<p>提示：方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要  匹配所有的中文字符，就可以利用u0041-056形式因为所有中文字符的 Unicode  值是连续的，只要找出所有中文字符中最小、最大的 Unicode值，就可以利用上面形式来  匹配所有的中文字符。</p>
<p>正则表示还支持圆括号表达式，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符（|）。例如，正则表达式“( (public)|(protected)|(private))”用于匹配Java的三个访问控制符其中之一。</p>
<p>除此之外，Java正则表达式还支持如下表的几个边界匹配符。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>边界匹配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>行的开头</td>
</tr>
<tr>
<td>$</td>
<td>行的结尾</td>
</tr>
<tr>
<td>\b</td>
<td>单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词的边界</td>
</tr>
<tr>
<td>\A</td>
<td>输入的开头</td>
</tr>
<tr>
<td>\G</td>
<td>前一个匹配的结尾</td>
</tr>
<tr>
<td>\Z</td>
<td>输入的结尾，仅用于最后的结束符</td>
</tr>
<tr>
<td>\z</td>
<td>输入的结尾</td>
</tr>
</tbody></table></div>
<p>前面例子中需要建一个000-000-0000式的电话号码时，使用了\d\d\d-\d\d\d-\d\d\d\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。</p>
<ul>
<li><p>Greedy(贪婪模式):数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为——你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 </p>
</li>
<li><p>Reluctant(勉强模式):用问号后缀(?)表示，它只会匹配最少的字符。也称为最小匹配模式 。 </p>
</li>
<li><p>PossessIve(占有模式):用加号后缀(+)表示，目前只有Java支持占有模式，通常比较少用。</p>
<p>三种模式的数量表示符</p>
<div class="table-container"><table>
<thead>
<tr>
<th>贪婪模式</th>
<th>勉强模式</th>
<th>占用模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X??</td>
<td>X?+</td>
<td>X表达式出现零次或一次</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>X表达式出现零次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>X表达式出现一次或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>X表达式出现n次</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X{n,}?</td>
<td>X{n,}+</td>
<td>X表达式最少出现n次</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X{n,m}?</td>
<td>X{n,m}+</td>
<td>X表达式最少出现n次，最多出现m次</td>
</tr>
</tbody></table></div>
<p>贪婪模式与勉强模式的对比：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello ,world!&quot;</span>;</span><br><span class="line"><span class="comment">//贪婪模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">&quot;\\w*&quot;</span>,<span class="string">&quot;    &quot;</span>));<span class="comment">//输出    ，world!</span></span><br><span class="line"><span class="comment">//勉强模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">&quot;\\w*?&quot;</span>,<span class="string">&quot;    &quot;</span>));<span class="comment">//输出  helle,world!</span></span><br></pre></td></tr></table></div></figure>

<p>当从“Hello，world！”字符串中查找匹配”&#x2F;&#x2F;w*”子串时，因为“&#x2F;&#x2F;w *”使用了贪婪模式，数量表示符（ *）会一直匹配下去，所以该字符串前面的所有的单词字符都会被匹配到，直到遇到空格；如果使用勉强模式，数量表示符      （ *）会尽量匹配最少字符，即匹配0个字符。</p>

        <h3 id="7-5-2-使用正则表达式"   >
          <a href="#7-5-2-使用正则表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-5-2-使用正则表达式" class="headerlink" title="7.5.2 使用正则表达式"></a>7.5.2 使用正则表达式</h3>
      <p><strong>正则表达式字符串必须先被编译为Pattern对象，然后利用该Pattern对象创建对应的Matcher对象。</strong>执行匹配所涉及的状态保留在Matcher对象中，多个Matcher可共享一个Pattern对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个字符串编译成Pattern对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"><span class="comment">//使用Pattern对象创建Matcher()对象</span></span><br><span class="line"><span class="comment">//matcher()自动把指定字符串编译成匿名的Pattern对象，并执行匹配</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aaaab&quot;</span>);</span><br><span class="line"><span class="comment">/*matches():试图将整个区域与模式进行匹配。</span></span><br><span class="line"><span class="comment">如果匹配成功，则可以通过start、end和group方法获得更多信息。</span></span><br><span class="line"><span class="comment">当且仅当整个区域序列匹配此匹配器的模式时为真*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> m.matches(); <span class="comment">//返回true</span></span><br></pre></td></tr></table></div></figure>

<p>上面定义的Pattern对象可以多次重复使用。如果某个正则表达式只需要一次使用，则可以直接使用Pattern类的matcher方法，此方法可以自动把指定字符串编译成匿名的Pattern对象，并执行匹配</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Pattern.matcher(<span class="string">&quot;a*b&quot;</span>,<span class="string">&quot;aaaab&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>这句等效于以上三局，但采用这种语句都需要重新编译新的Pattern对象，不能重复利用以编译的Pattern对象，所以效率不高。</p>
<p>&#x3D;&#x3D;Matcher类中的几种方法：&#x3D;&#x3D;</p>
<ul>
<li>find():返回目标字符串中是否包含Pattern匹配的子串。</li>
<li>group():返回上一次与Pattern匹配的子串。</li>
<li>start():返回上一次与Pattern匹配的子串在目标字符串中的开始位置。</li>
<li>end():返回上一次与Pattern匹配的子串在目标字符串中的结束位置加1。</li>
<li>lookungAt():返回目标字符串前面部分与Pattern是否匹配。</li>
<li>matches():返回整个目标字符串与Pattern是否匹配。</li>
<li>reset():将现有的Matcher对象应用于一个新的字符串序列。</li>
</ul>
<p>使用Maycher类的find()和group()方法可以从目标字符串中依次取出特定子串（匹配这则表达式的子串），例如互联网的网络爬虫。他们可以自动从网页上识别出所有的电话号码。</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindGroup</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		使用字符串模拟从网络上得到网页的源码</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我想求购一本《疯狂Java讲义》，尽快联系我15333634564&quot;</span></span><br><span class="line">				+<span class="string">&quot;交朋友，电话号码是17333636698&quot;</span></span><br><span class="line">				+<span class="string">&quot;美女的微信是13165489874&quot;</span></span><br><span class="line">				+<span class="string">&quot;出售二手电脑，联系方式15633644562&quot;</span>;</span><br><span class="line"><span class="comment">//		创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line"><span class="comment">//		该正则表达式要抓取17x和15x段的手机号</span></span><br><span class="line"><span class="comment">//		实际要抓取哪些代码只需要修改正则表达式即可</span></span><br><span class="line"><span class="comment">//		compile：将给定的正则表达式编译成模式。</span></span><br><span class="line"><span class="comment">//		matcher():创建一个匹配器，它将根据这个模式匹配给定的输入。</span></span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;((13\\d)|(15\\d))\\d&#123;8&#125;&quot;</span>).matcher(str);</span><br><span class="line"><span class="comment">//		将所有符合正则表达式的子串全部输出</span></span><br><span class="line"><span class="comment">//		find()：尝试查找与模式匹配的输入序列的下一个子序列。</span></span><br><span class="line">		<span class="keyword">while</span>(m.find())</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			group()：返回与前一个匹配项匹配的输入子序列。</span></span><br><span class="line">			System.out.println(m.group());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>find()方法依次查找字符串中与Pattern匹配的子串，一旦找到对应的子串，下次调用find()方法时将接着向下查找。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartEnd</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个Pattern对象，并用它建立一个Matcher对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;Java is very easy!&quot;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;目标字符串是：&quot;</span> + regStr);</span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\w+&quot;</span>).matcher(regStr);</span><br><span class="line">		<span class="keyword">while</span>(m.find())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(m.group()+<span class="string">&quot;子串的起始位置：&quot;</span></span><br><span class="line">					+m.start()+<span class="string">&quot;其结束位置&quot;</span>+m.end());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>上面程序使用find()、group()方法逐项取出字符串与指定正则表达式匹配的子串，并使用start()、end()方法返回子串在目标字符串中的位置。</strong></p>
<p>matches()和lookingAt()方法有点相似，<strong>只是matches()方法要求整个字符串和Pattern完全匹配时，才返回true，而lookingAt()只要以Pattern开头就会返回true。reset()方法可将现有的Matcher对象应用于新的字符序列。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import java.util.regex.Pattern;</span></span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatchesTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] mails = </span><br><span class="line">			&#123;</span><br><span class="line">					<span class="string">&quot;kidhfkd@163.com&quot;</span>,</span><br><span class="line">					<span class="string">&quot;kidhfkd@gmail.com&quot;</span>,</span><br><span class="line">					<span class="string">&quot;sjndbbcdv.org&quot;</span>,</span><br><span class="line">					<span class="string">&quot;whfioavl.xx&quot;</span></span><br><span class="line">			&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">mailRegEx</span> <span class="operator">=</span> <span class="string">&quot;\\w(3,20)@\\w+\\.(com|org|cn|net|gov)&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">mailPattern</span> <span class="operator">=</span> Pattern.compile(mailRegEx);</span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> mail:mails)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(matcher == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				matcher = mailPattern.matcher(mail);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line"><span class="comment">//				reset:用一个新的输入序列重置这个匹配器。</span></span><br><span class="line">				matcher.reset(mail);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mail +(matcher.matches()?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;不是&quot;</span>)</span><br><span class="line">					+<span class="string">&quot;一个有效的邮件地址&quot;</span>;</span><br><span class="line">			System.out.println(result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序创建了一个邮件地址的Pattern，接着用这个Pattern与多个邮箱地址进行匹配。当程序的Matcher为null时，程序调用matcher()来创建一个Matcher对象，一旦Mathcer对象被创建，程序就调用reset()方法将Mathcer应用到新的字符序列。</p>
<p>对目标字符串进行分割、查找、替换等操作：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplaceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] msgs =</span><br><span class="line">		&#123; <span class="string">&quot;Java hsa regular expressions in 1.4&quot;</span>, <span class="string">&quot;regular expressions now expressing in Java&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Java represses oracular expressions&quot;</span> &#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;re\\w*&quot;</span>);</span><br><span class="line">		<span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; msgs.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(matcher == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				matcher = p.matcher(msgs[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				matcher.reset(msgs[i]);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			String replaceAll():将该字符串中所有匹配regex的子串退换成replacement</span></span><br><span class="line">			System.out.println(matcher.replaceAll(<span class="string">&quot;哈哈:)&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序使用了Matcher类提供的replaceAll()把字符串中所有与正则表达式匹配的子串替换成  哈哈：）“，实际上，Mathcer类还提供了一个replaceFirst()，把方法只替换第一个匹配的子串，运行上面程序，会看到字符串中所有以”re“开头的单词都会替换成  哈哈：）”。</p>
<p>String类中也提供了replaceAll()、replaceFirst()、split()等方法，下面的例子直接使用String类提供的正则表达式功能来进行替换和分割。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReg</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		String[] mags =</span><br><span class="line">		&#123; <span class="string">&quot;Java hsa regular expressions in 1.4&quot;</span>, <span class="string">&quot;regular expressions now expressing in Java&quot;</span>,</span><br><span class="line">				<span class="string">&quot;Java represses oracular expressions&quot;</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> mag : mags)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(mag.replaceFirst(<span class="string">&quot;re\\w*&quot;</span>, <span class="string">&quot;哈哈&quot;</span>));</span><br><span class="line">			System.out.println(Arrays.toString(mag.split(<span class="string">&quot; &quot;</span>)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序只使用String类的replaceFirst()和split()方法对目标对目标字符串进行了一次替换和分割。</p>

        <h2 id="7-6-变量处理和方法处理"   >
          <a href="#7-6-变量处理和方法处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-6-变量处理和方法处理" class="headerlink" title="7.6 变量处理和方法处理"></a>7.6 变量处理和方法处理</h2>
      <p>Java 9 引入了一个新的VarHandle类，并增强了原有的MethodHandle类。通过这两个类，允许Java像动态语言一样引用变量、引用方法，并调用它们。</p>

        <h3 id="7-6-1-Java-9-增强的MethodHandle"   >
          <a href="#7-6-1-Java-9-增强的MethodHandle" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-6-1-Java-9-增强的MethodHandle" class="headerlink" title="7.6.1 Java 9 增强的MethodHandle"></a>7.6.1 Java 9 增强的MethodHandle</h3>
      <p>这种方法引用是一种轻量级的引用方式，他不会检查方法的访问权限，也不会管方法所属的类、实例方法或静态方法，MethodHandle就是简单代表特定的方法，并可通过MethodHandle来调用方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodHandleTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个private类方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	定义一个private实例方法</span></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">hello</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行带参数的hello&quot;</span>+ name);</span><br><span class="line">		<span class="keyword">return</span> name +<span class="string">&quot;您好&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义一个返回值为void，不带形参的方法类型。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">type</span> <span class="operator">=</span> MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line"><span class="comment">//		使用MethodHandles.lookup的findStatic获取类方法。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">mtd</span> <span class="operator">=</span> MethodHandles.lookup()</span><br><span class="line">				.findStatic(MethodHandleTest.class,<span class="string">&quot;hello&quot;</span>,type);</span><br><span class="line"><span class="comment">//		通过MethodHandle执行方法</span></span><br><span class="line">		mtd.invoke();</span><br><span class="line"><span class="comment">//		使用MethodHandles.lookup()的findVirtual获取实例方法</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">mtd2</span> <span class="operator">=</span> MethodHandles.lookup()</span><br><span class="line">				.findVirtual(MethodHandleTest.class,<span class="string">&quot;hello&quot;</span>,</span><br><span class="line"><span class="comment">//						指定获取返回值为String、形参为String的方法类型</span></span><br><span class="line">						MethodType.methodType(String.class,String.class));</span><br><span class="line"><span class="comment">//		通过MethodType执行方法，传入主调对象和参数</span></span><br><span class="line">		System.out.println(mtd2.invoke(<span class="keyword">new</span> <span class="title class_">MethodHandleTest</span>(),<span class="string">&quot;孙悟空&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上面三行粗体字代码中可以看出，程序使用MethodHandles.lookup对象根据类、方法名，方法类型来获取MethodHandle对象。由于此处的方法名只是一个字符串，而该字符串可以来自变量、配置文件等，这意味着MethodHandle可以让Java动态的调用某个方法。</p>

        <h3 id="7-6-2-Java-9-新增的varHandle"   >
          <a href="#7-6-2-Java-9-新增的varHandle" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-6-2-Java-9-新增的varHandle" class="headerlink" title="7.6.2 Java 9 新增的varHandle"></a>7.6.2 Java 9 新增的varHandle</h3>
      <p>用于动态的操作数组或者对象的成员变量。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User7</span></span><br><span class="line">&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> MAX_AGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarHandleTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Kotlin&quot;</span>,<span class="string">&quot;Go&quot;</span>&#125;; </span><br><span class="line"><span class="comment">//		获取一个String[]数组的VarHandle对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">avh</span> <span class="operator">=</span> MethodHandles.arrayElementVarHandle(String[].class);<span class="comment">//粗体·</span></span><br><span class="line"><span class="comment">//		比较并设置：2表示第三个元素，如果第三个元素时Go，则被设置为Lua</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> avh.compareAndSet(sa,<span class="number">2</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Lua&quot;</span>);<span class="comment">//粗体·</span></span><br><span class="line">		System.out.println(r);</span><br><span class="line">		System.out.println(Arrays.toString(sa));</span><br><span class="line"><span class="comment">//		获取并设置：</span></span><br><span class="line">		System.out.println(avh.getAndSet(sa,<span class="number">2</span>,<span class="string">&quot;Swift&quot;</span>));</span><br><span class="line">		System.out.println(Arrays.toString(sa));</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		用findVarHandle方法获取uesr7类中名为name</span></span><br><span class="line"><span class="comment">//		类型为String的实例变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">vh1</span> <span class="operator">=</span> MethodHandles.lookup().findVarHandle(User7.class, </span><br><span class="line">				<span class="string">&quot;name&quot;</span>,String.class);  <span class="comment">//粗体·</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User7</span>();</span><br><span class="line"><span class="comment">//		通过varHandle获取实例变量的值，需要传入对象作为调用者</span></span><br><span class="line">		System.out.println(vh1.get(user));<span class="comment">//粗体·</span></span><br><span class="line"><span class="comment">//		通过varHandle获取实例变量的值，需要传入对象作为调用者</span></span><br><span class="line">		vh1.set(user,<span class="string">&quot;孙悟空&quot;</span>);<span class="comment">//粗体·</span></span><br><span class="line"><span class="comment">//		输出user的name实例的值</span></span><br><span class="line">		System.out.println(user.name);</span><br><span class="line"><span class="comment">//		用findVarHandle方法获取User类中名为MAX_AGE</span></span><br><span class="line"><span class="comment">//		类型为Integer的类变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">vh2</span> <span class="operator">=</span> MethodHandles.lookup().findStaticVarHandle(User7.class, </span><br><span class="line">				<span class="string">&quot;MAX_AGE&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">		System.out.println(vh2.get());</span><br><span class="line">		vh2.set(<span class="number">88</span>);</span><br><span class="line">		System.out.println(User7.MAX_AGE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>粗可以看出，程序调用MethodHandle类的静态方法可获取操作数组的VarHandle对象，接下来程序可以通过VarHandle对象来操作数组的方法，包括比较并设置数组元素、获取并这只数组元素等，VarHandle具体支持哪些方法则可参考API文档。</p>
<p>后三粗示范了使用VarHandle操作实例变量的情景，由于实例变量需要使用对象来访问，因此使用VarHandle操作实例变量时需要传入一个User对象。</p>
<p>操作类变量和实例变量差别不大，区别只是类变量不需要对象，而实例变量需要对象，因此VarHandle操作类变量是无须传入对象作为参数。</p>
<p>当程序通过MethodHandles.Lookup来获取成员变量时，可根据字符串名称来获取成员变量，这个字符串名称同样是可以动态改变的。</p>

        <h2 id="7-7-Java-11改进的国际化与格式化"   >
          <a href="#7-7-Java-11改进的国际化与格式化" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-Java-11改进的国际化与格式化" class="headerlink" title="7.7 Java 11改进的国际化与格式化"></a>7.7 Java 11改进的国际化与格式化</h2>
      <p>国际化（Internationaliaztion）简称I18N。</p>

        <h3 id="7-7-2-Java支持的国家或语言"   >
          <a href="#7-7-2-Java支持的国家或语言" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-2-Java支持的国家或语言" class="headerlink" title="7.7.2 Java支持的国家或语言"></a>7.7.2 Java支持的国家或语言</h3>
      <p>调用Locale类的getAvailableLocales()方法，该方法返回一个Locale数组，该数组中包含了Java所支持的国家和语言。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocaleList</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		返回Java所支持的全部国家和语言的数组</span></span><br><span class="line">		Locale[] localeList = Locale.getAvailableLocales();</span><br><span class="line"><span class="comment">//		遍历每个数组的元素，依次获取所支持的国家和语言</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;localeList.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(localeList[i].getDisplayCountry()</span><br><span class="line">					+<span class="string">&quot;=&quot;</span>+localeList[i].getCountry()+<span class="string">&quot; &quot;</span></span><br><span class="line">					+localeList[i].getDisplayLanguage()</span><br><span class="line">					+<span class="string">&quot;=&quot;</span>+localeList[i].getLanguage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-3-完成程序国际化"   >
          <a href="#7-7-3-完成程序国际化" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-3-完成程序国际化" class="headerlink" title="7.7.3 完成程序国际化"></a>7.7.3 完成程序国际化</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		获得系统默认的国家\语言环境</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">myLocale</span> <span class="operator">=</span> Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line"><span class="comment">//		根据指定的国家/语言环境加载资源文件</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;mess&quot;</span>,myLocale);</span><br><span class="line">		System.out.println(bundle.getString(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-4-使用MessageFormat处理包含占位符的字符串"   >
          <a href="#7-7-4-使用MessageFormat处理包含占位符的字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-4-使用MessageFormat处理包含占位符的字符串" class="headerlink" title="7.7.4 使用MessageFormat处理包含占位符的字符串"></a>7.7.4 使用MessageFormat处理包含占位符的字符串</h3>
      <p>myMess_en_US.properties</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg = Hello,&#123;0&#125;!Today is &#123;1&#125;.</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.MessageFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloArg</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义一个Locale变量</span></span><br><span class="line">		<span class="type">Locale</span> <span class="variable">currentLocale</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//		运行程序指定了两个参数</span></span><br><span class="line">		<span class="keyword">if</span>(args.length == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			使用运行时的两个参数构造Locale实例</span></span><br><span class="line">			currentLocale = <span class="keyword">new</span> <span class="title class_">Locale</span>(args[<span class="number">0</span>],args[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			否则直接用系统默认的Locale</span></span><br><span class="line">			currentLocale = Locale.getDefault(Locale.Category.FORMAT);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		根据Locale加载语言资源</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;myMess&quot;</span>,currentLocale);</span><br><span class="line"><span class="comment">//		取得已加载中的资源文件中的msg对应消息</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">msg</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line"><span class="comment">//		使用MessageFormat为带占位符的字符串传入参数</span></span><br><span class="line">		System.out.println(MessageFormat.format(msg, <span class="string">&quot;Mr.zhang&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对于占位符字符串，只需要使用MessageFormat类的format()方法为消息中的占位符指定参数即可。</p>

        <h3 id="7-7-5-使用类文件代替资源文件"   >
          <a href="#7-7-5-使用类文件代替资源文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-5-使用类文件代替资源文件" class="headerlink" title="7.7.5 使用类文件代替资源文件"></a>7.7.5 使用类文件代替资源文件</h3>
      <p>除使用属性文件为资源文件外，Java也允许使用类文件代替资源文件，即将所有的key-value对存入class文件，而不是属性文件。</p>
<p>使用类文件来代替资源文件必须满足如下条件。</p>
<ul>
<li>该类的类名必须是baseName_language_country，这与属性文件的命名相似。</li>
<li>该类必须继承ListResourceBundle,并重写getContents()方法，该方法返回Object数组，该数组的每一项都是键值对（key-value对）。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ListResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myMess_zh_CN</span> <span class="keyword">extends</span> <span class="title class_">ListResourceBundle</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object myData[] []=</span><br><span class="line">		&#123;</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;&#123;0&#125;,你好！今天的日期是&#123;1&#125;&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"><span class="comment">//	重写getContents()方法</span></span><br><span class="line">	<span class="keyword">public</span> Object[][]getContents()</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		该方法返回资源的key-value对</span></span><br><span class="line">		<span class="keyword">return</span> myData;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面文件是一个简体中文语言环境的资源文件，该文件可以代替myMess_zh_CN.properties 文件;如果需要代替美国英语语言环境的资源文件，则还应该提供一个myMess_en_US 类。</p>
<p>如果系统同时存在资源文件、类文件，系统将以类文件为主，而不会调用资源文件。对于简体中文的 Locale，ResourceBundle 搜索资源文件的顺序是:<br>(1)baseName_zh_CN.class<br>(2)baseName_zh_CN.properties(3)baseName_zh.class<br>(4)baseName_zh.properties<br>(5)baseName.class</p>
<p>系统按上面的顺序搜索资源文件，如果面的文件不存在,才会使用下一个文件，如果一直找不到对应的文件，系统将抛出异常。</p>

        <h3 id="7-7-6-Java-9新增的日志API"   >
          <a href="#7-7-6-Java-9新增的日志API" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-6-Java-9新增的日志API" class="headerlink" title="7.7.6 Java 9新增的日志API"></a>7.7.6 Java 9新增的日志API</h3>
      
        <h3 id="7-7-7-使用NumberFormat格式化数字"   >
          <a href="#7-7-7-使用NumberFormat格式化数字" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-7-使用NumberFormat格式化数字" class="headerlink" title="7.7.7 使用NumberFormat格式化数字"></a>7.7.7 使用NumberFormat格式化数字</h3>
      <p>MessageFormat是抽象类Format的子类，Format抽象类还有两个子类：NumberFormat和DateFormat，两个子类中提供了两个方法：format()和parse()方法，format()用于将数值、日期转换为字符串，parse()用于将字符串装换为数值和日期。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.NumberFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberFormatTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="number">11230000.76</span>;</span><br><span class="line">		Locale[] locales = &#123;</span><br><span class="line">				Locale.CHINA,Locale.JAPAN,Locale.GERMAN,Locale.US</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">nf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberFormat</span>[<span class="number">12</span>];</span><br><span class="line"><span class="comment">//		为上面的Locale创建12个NumberFormat对象</span></span><br><span class="line"><span class="comment">//		每个Locale分别有数值格式器、百分数格式器、货币格式器</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			nf[i*<span class="number">3</span>] = NumberFormat.getNumberInstance(locales[i]);</span><br><span class="line">			nf[i*<span class="number">3</span>+<span class="number">1</span>] = NumberFormat.getPercentInstance(locales[i]);</span><br><span class="line">			nf[i*<span class="number">3</span>+<span class="number">2</span>] = NumberFormat.getCurrencyInstance(locales[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">tip</span> <span class="operator">=</span> i == <span class="number">0</span> ? <span class="string">&quot;--------中国格式--------&quot;</span></span><br><span class="line">					:i==<span class="number">1</span>? <span class="string">&quot;--------日本格式--------&quot;</span>:</span><br><span class="line">						i==<span class="number">2</span>?<span class="string">&quot;--------德国格式--------&quot;</span>:<span class="string">&quot;--------美国格式--------&quot;</span>;</span><br><span class="line">			System.out.println(tip);</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的数值格式：&quot;</span></span><br><span class="line">					+nf[i*<span class="number">3</span>].format(bd));</span><br><span class="line">			System.out.println(<span class="string">&quot;百分比数值格式：&quot;</span></span><br><span class="line">					+nf[i*<span class="number">3</span>+<span class="number">1</span>].format(bd));</span><br><span class="line">			System.out.println(<span class="string">&quot;货币数值格式：&quot;</span></span><br><span class="line">					+nf[i*<span class="number">3</span>+<span class="number">2</span>].format(bd));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-8-使用DateFormat格式化日期、时间"   >
          <a href="#7-7-8-使用DateFormat格式化日期、时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-8-使用DateFormat格式化日期、时间" class="headerlink" title="7.7.8 使用DateFormat格式化日期、时间"></a>7.7.8 使用DateFormat格式化日期、时间</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormatTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		需要格式化的时间</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		Locale[] locales = &#123;Locale.CHINA,Locale.US&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateFormat</span>[<span class="number">16</span>];</span><br><span class="line"><span class="comment">//		为上面两个Locale创建16个DateFormat对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			df[i*<span class="number">8</span>] = DateFormat.getDateInstance(DateFormat.SHORT,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">1</span>] = DateFormat.getDateInstance(DateFormat.MEDIUM,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">2</span>] = DateFormat.getDateInstance(DateFormat.LONG,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">3</span>] = DateFormat.getDateInstance(DateFormat.FULL,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">4</span>] = DateFormat.getTimeInstance(DateFormat.SHORT,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">5</span>] = DateFormat.getTimeInstance(DateFormat.MEDIUM,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">6</span>] = DateFormat.getTimeInstance(DateFormat.LONG,locales[i]);</span><br><span class="line">			df[i*<span class="number">8</span>+<span class="number">7</span>] = DateFormat.getTimeInstance(DateFormat.FULL,locales[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;locales.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">tip</span> <span class="operator">=</span> i == <span class="number">0</span> ? <span class="string">&quot;--------中国格式日期--------&quot;</span></span><br><span class="line">					:<span class="string">&quot;--------美国日期格式--------&quot;</span>;</span><br><span class="line">			System.out.println(tip);</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的MEDIUM格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">1</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的LONG格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">2</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的FULL格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">3</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">4</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">5</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">6</span>].format(dt));</span><br><span class="line">			System.out.println(<span class="string">&quot;通用的SHORT格式：&quot;</span></span><br><span class="line">					+df[i*<span class="number">8</span>+<span class="number">7</span>].format(dt));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;---------------下面为测试是否采用严格语法---------------&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;2021/2/31&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;2021年2月31日&quot;</span>;</span><br><span class="line">		System.out.println(DateFormat.getDateInstance().parse(str2));</span><br><span class="line">		System.out.println(DateFormat.getDateInstance(DateFormat.SHORT).parse(str1));</span><br><span class="line">        <span class="comment">//引发异常，因为str1是一个SHORT字符串，必须使用SHORT样式的DateFormat实例解析</span></span><br><span class="line">		System.out.println(DateFormat.getDateInstance().parse(str1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-7-9-使用SimpleDateFormat格式化日期"   >
          <a href="#7-7-9-使用SimpleDateFormat格式化日期" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-7-9-使用SimpleDateFormat格式化日期" class="headerlink" title="7.7.9 使用SimpleDateFormat格式化日期"></a>7.7.9 使用SimpleDateFormat格式化日期</h3>
      <p>前面介绍的DateFormat的parse()方法可以把字符串解析成Date对象，但实际上DateFormat的parse()方法不够灵活——他被要求解析的字符串必须满足特定的格式！为了更好地格式化日期、解析日期字符串，Java提供了SimpleDateFormat类。</p>
<p>SimpleDateFormat是DateFormat的子类，正如它的名字所暗示的，他是简单的日期格式器。很多读者对“简单的”格式器不屑一顾，实际上SimpleDateFormat 比DateFormat更简单，功能更强大。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">var</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;Gyyyy年中的第D天&quot;</span>);</span><br><span class="line"><span class="comment">//		将D格式化为日期</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dateStr</span> <span class="operator">=</span> sdf1.format(d);</span><br><span class="line">		System.out.println(dateStr);</span><br><span class="line"><span class="comment">//		一个非常特殊的日期字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;14####3月##21&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;y####MMM##d&quot;</span>);</span><br><span class="line"><span class="comment">//		将日期字符串解析成日期，输出：Fri Mar 21 00:00..........</span></span><br><span class="line">		System.out.println(sdf2.parse(str));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这样的字符串解析成日期，功能非常强大。格式化怎么样的字符串完全取决于创建该对象是指定的pattern参数，oattern是一个使用日期字段占位符的日期模板。</p>

        <h2 id="7-8-Java-8新增的日期、时间格式器"   >
          <a href="#7-8-Java-8新增的日期、时间格式器" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-8-Java-8新增的日期、时间格式器" class="headerlink" title="7.8 Java 8新增的日期、时间格式器"></a>7.8 Java 8新增的日期、时间格式器</h2>
      <p>DateTimeFormatter类相当与前面介绍的DateFormat和SimpleDateFormatter的合体，功能十分强大。</p>
<p>使用DateTimeFormatter进行格式化或解析，必须进行格式化或解析，必须先获取DateTimeFormatter对象。</p>

        <h3 id="7-8-1-使用DateTimeFormatter完成格式化"   >
          <a href="#7-8-1-使用DateTimeFormatter完成格式化" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-8-1-使用DateTimeFormatter完成格式化" class="headerlink" title="7.8.1 使用DateTimeFormatter完成格式化"></a>7.8.1 使用DateTimeFormatter完成格式化</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.format.FormatStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewFormatterTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">formatters</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTimeFormatter</span>[] </span><br><span class="line">				&#123;</span><br><span class="line"><span class="comment">//						直接使用常量创建DateTimeFormatter格式器</span></span><br><span class="line">						DateTimeFormatter.ISO_LOCAL_DATE,</span><br><span class="line">						DateTimeFormatter.ISO_LOCAL_TIME,</span><br><span class="line">						DateTimeFormatter.ISO_LOCAL_DATE_TIME,</span><br><span class="line"><span class="comment">//						使用本地化的不同风格来创建DateTimeFormatter格式器</span></span><br><span class="line">						DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL,FormatStyle.MEDIUM),</span><br><span class="line">						DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG),</span><br><span class="line"><span class="comment">//						根据模式字符串来创建DateFormatter格式化</span></span><br><span class="line">						DateTimeFormatter.ofPattern(<span class="string">&quot;Gyyyy%%MMM%%dd HH:mm:ss&quot;</span>)</span><br><span class="line">				&#125;;</span><br><span class="line">		<span class="type">var</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//		依次使用不同的格式器对LocalDateTime进行格式化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; formatters.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(date.format(formatters[i]));<span class="comment">//粗</span></span><br><span class="line">			System.out.println(formatters[i].format(date));<span class="comment">//粗</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>粗从不同方式来格式化日期。</p>
<p>7.8.2 使用DateTimeFoematter解析字符串</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewFormatterParse</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义一个任意格式的日期、时间字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;2012==04==12 01时07分09秒&quot;</span>;</span><br><span class="line"><span class="comment">//		根据需要解析的日期、时间字符串定义解析所有的格式器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy==MM==dd HH时jj分pp秒&quot;</span>);</span><br><span class="line"><span class="comment">//		执行解析</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dt1</span> <span class="operator">=</span> LocalDateTime.parse(str1,formatter1);</span><br><span class="line">		System.out.println(dt1);</span><br><span class="line"><span class="comment">//省略第二个</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="小结："   >
          <a href="#小结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1>
      <p>本章介绍了运行Java程序时的参数，并详细解释了main方法签名的含义。为了实现字符界面程序与晕乎交互功能，介绍了两种读取键盘输入的方法（hasNext(),next()），还介绍了System、Runtime、String、StringBuffer、StringBuilder、Math、BigDecimal、Random、Date、Calendar和TimeZone等常用类的用法。</p>
<p>重点介绍了正则表达式，以及使用Pattern、Matcher、String等类来使用正则。还介绍了程序国际化等，还介绍了新增的日期、时间包，以及新增的日期时间格式符。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://example.com">Xiao Zhang</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://example.com/2023/02/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%20Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/">http://example.com/2023/02/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%20Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2023/02/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"><span class="paginator-prev__text">《疯狂Java讲义——面向对象（下）》</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">
          第七章 Java基础类库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92"><span class="toc-number">1.1.</span> <span class="toc-text">
          7.1 与用户交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E8%BF%90%E8%A1%8CJava%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          7.1.1 运行Java程序的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E4%BD%BF%E7%94%A8Scanner%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          7.1.2 使用Scanner获取键盘输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.</span> <span class="toc-text">
          7.2 系统相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-System%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          7.2.1 System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-Runtime%E7%B1%BB%E4%B8%8Ejava9%E7%9A%84-ProcessHandle"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          7.2.2 Runtime类与java9的 ProcessHandle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">
          7.3 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-Object%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          7.3.1 Object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E7%9A%84Object%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          7.3.2 操作对象的Object工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-Java-9%E6%94%B9%E8%BF%9B%E7%9A%84String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          7.3.3 Java 9改进的String、StringBuffer和StringBuilder类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-Math%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          7.3.4 Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-5-ThreadLocalRandom%E4%B8%8ERandom"><span class="toc-number">1.3.5.</span> <span class="toc-text">
          7.3.5 ThreadLocalRandom与Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-6-BigDecimal%E7%B1%BB"><span class="toc-number">1.3.6.</span> <span class="toc-text">
          7.3.6 BigDecimal类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Java-8%E7%9A%84%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">
          7.4 Java 8的日期、时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1Date%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          7.4.1Date类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-Calendar%E7%B1%BB"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          7.4.2 Calendar类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-add%E4%B8%8Eroll%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">
          1.add与roll的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AECalendar%E7%9A%84%E5%AE%B9%E9%94%99%E7%8E%87"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">
          2.设置Calendar的容错率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-set-%E6%96%B9%E6%B3%95%E5%BB%B6%E8%BF%9F%E4%BF%AE%E6%94%B9"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">
          3.set()方法延迟修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E5%8C%85"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          7.4.3新的日期、时间包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">
          7.5 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">
          7.5.1 创建正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">
          7.5.2 使用正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E5%8F%98%E9%87%8F%E5%A4%84%E7%90%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">
          7.6 变量处理和方法处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-Java-9-%E5%A2%9E%E5%BC%BA%E7%9A%84MethodHandle"><span class="toc-number">1.6.1.</span> <span class="toc-text">
          7.6.1 Java 9 增强的MethodHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-Java-9-%E6%96%B0%E5%A2%9E%E7%9A%84varHandle"><span class="toc-number">1.6.2.</span> <span class="toc-text">
          7.6.2 Java 9 新增的varHandle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-Java-11%E6%94%B9%E8%BF%9B%E7%9A%84%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">
          7.7 Java 11改进的国际化与格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-2-Java%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%BD%E5%AE%B6%E6%88%96%E8%AF%AD%E8%A8%80"><span class="toc-number">1.7.1.</span> <span class="toc-text">
          7.7.2 Java支持的国家或语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-3-%E5%AE%8C%E6%88%90%E7%A8%8B%E5%BA%8F%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">
          7.7.3 完成程序国际化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-4-%E4%BD%BF%E7%94%A8MessageFormat%E5%A4%84%E7%90%86%E5%8C%85%E5%90%AB%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.3.</span> <span class="toc-text">
          7.7.4 使用MessageFormat处理包含占位符的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-5-%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BF%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">
          7.7.5 使用类文件代替资源文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-6-Java-9%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%A5%E5%BF%97API"><span class="toc-number">1.7.5.</span> <span class="toc-text">
          7.7.6 Java 9新增的日志API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-7-%E4%BD%BF%E7%94%A8NumberFormat%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97"><span class="toc-number">1.7.6.</span> <span class="toc-text">
          7.7.7 使用NumberFormat格式化数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-8-%E4%BD%BF%E7%94%A8DateFormat%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4"><span class="toc-number">1.7.7.</span> <span class="toc-text">
          7.7.8 使用DateFormat格式化日期、时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-9-%E4%BD%BF%E7%94%A8SimpleDateFormat%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">1.7.8.</span> <span class="toc-text">
          7.7.9 使用SimpleDateFormat格式化日期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-Java-8%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">
          7.8 Java 8新增的日期、时间格式器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-1-%E4%BD%BF%E7%94%A8DateTimeFormatter%E5%AE%8C%E6%88%90%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.8.1.</span> <span class="toc-text">
          7.8.1 使用DateTimeFormatter完成格式化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">
          小结：</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Make great efforts</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://blog.csdn.net/weixin_45708609?spm=1000.2115.3001.5343/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="2215071022@qq.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="2215071022" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="http://2215071022@qq.com" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email Subscribe</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>zhang</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v6.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>