<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="第六章 面向对象（下）                           6.1包装类       以下八个基本类型都不能当做对象使用，也不能接受null值。 为了解决此问题java为8个基本类型提供了对应的包装类——可将他们包装成对象。    基本数据类型 包装类    byte Byte   short Short   int Integer   lo">
<meta property="og:type" content="article">
<meta property="og:title" content="《疯狂Java讲义——面向对象（下）》">
<meta property="og:url" content="http://example.com/2023/02/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/index.html">
<meta property="og:site_name" content="Xiao Zhang&#39;blog">
<meta property="og:description" content="第六章 面向对象（下）                           6.1包装类       以下八个基本类型都不能当做对象使用，也不能接受null值。 为了解决此问题java为8个基本类型提供了对应的包装类——可将他们包装成对象。    基本数据类型 包装类    byte Byte   short Short   int Integer   lo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\MingyangLiu\Desktop\%E5%BC%A0%E6%99%BA%E8%B6%85\image\Snipaste_2021-03-15_18-02-27.png">
<meta property="article:published_time" content="2023-02-14T13:40:17.504Z">
<meta property="article:modified_time" content="2023-02-14T13:43:17.372Z">
<meta property="article:author" content="Xiao Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\MingyangLiu\Desktop\%E5%BC%A0%E6%99%BA%E8%B6%85\image\Snipaste_2021-03-15_18-02-27.png"><title>《疯狂Java讲义——面向对象（下）》 | Xiao Zhang'blog</title><link ref="canonical" href="http://example.com/2023/02/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">menu.Blog</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/software/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">menu.software</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Xiao Zhang's Blod</div><div class="header-banner-info__subtitle">Blod for Xiao Zhang</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">《疯狂Java讲义——面向对象（下）》</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-14</span></span></div></header><div class="post-body">
        <h1 id="第六章-面向对象（下）"   >
          <a href="#第六章-面向对象（下）" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六章-面向对象（下）" class="headerlink" title="第六章 面向对象（下）"></a>第六章 面向对象（下）</h1>
      
        <h2 id="6-1包装类"   >
          <a href="#6-1包装类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1包装类" class="headerlink" title="6.1包装类"></a>6.1包装类</h2>
      <p>以下八个基本类型都不能当做对象使用，也不能接受null值。</p>
<p>为了解决此问题java为8个基本类型提供了对应的包装类——可将他们包装成对象。</p>
<div class="table-container"><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table></div>
<p>JDK1.5提供了自动装箱（Autoboxing）和自动拆箱（AutoUnboxing）功能，所谓自动装箱，<strong>就是可以把一个基本类型变量直接赋给对应的包装类变量，或者赋给Object变量（Object时所有类的父类，子类对象可以直接赋给父类变量）；自动拆箱则相反，允许把一个包装类对象直接赋值给一个对应的基本类型变量。</strong></p>
<p>自动装箱：基本类型的值可以自动当成包装类的实例使用。</p>
<p>自动拆箱：包装类的实例可以自动当成基本类型的值使用。</p>
<p>​	建议：以后做项目时，通常来说建议使用包装类来声明变量。</p>
<p>​				好处：基本类型能做的它都可以做，它还可以当做对象使用，还可以接受null。</p>
<p>能用钱解决的问题就不要用技术解决</p>
<p>进行自动装箱和自动拆箱时必须注意类型匹配，例如Integer只能自动拆箱成int类型变量，不要试图拆箱成boolean类型变量；与之类似，int类型变量也只能自动装箱成Integer对象（即使赋给Object类型变量，那也只是利用了Java的向上转型特性），不要试图装箱成为Boolean对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoBoxingUnboxing</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//直接把一个基本类型变量赋给Integer对象   自动装箱</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">inObj</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="comment">//直接把一个boolean类型变量赋给一个Object类型的变量</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">boolObj</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//直接把一个Integer对象赋给int类型的变量   自动拆箱</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> inObj;</span><br><span class="line">		<span class="keyword">if</span>(boolObj <span class="keyword">instanceof</span> Boolean)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//先把Object对象强制类型转换为Boolean类型，再赋给boolean变量</span></span><br><span class="line">			<span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> (Boolean) boolObj;   <span class="comment">//自动拆箱   Boolean转换为boolean</span></span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Integer.parseInt()是把()里的内容转换成整数。</p>
<p>Integer. valueOf()可以将基本类型int转换为包装类型Integer，或者将String转换成Integer，String如果为Null或“”都会报错。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Primitive2String</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">intStr</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">		<span class="comment">//把一个特定字符串转换成int变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it1</span> <span class="operator">=</span> Integer.parseInt(intStr);</span><br><span class="line">		<span class="type">var</span> <span class="variable">it2</span> <span class="operator">=</span> Integer.valueOf(intStr);</span><br><span class="line">		System.out.println(it2);</span><br><span class="line">		<span class="type">var</span> <span class="variable">floatStr</span> <span class="operator">=</span> <span class="string">&quot;4.56&quot;</span>;</span><br><span class="line">		<span class="comment">//把一个特定字符串转换成float变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ft1</span> <span class="operator">=</span> Float.parseFloat(floatStr);</span><br><span class="line">		<span class="type">var</span> <span class="variable">ft2</span> <span class="operator">=</span> Float.valueOf(floatStr);</span><br><span class="line">		System.out.println(ft2);</span><br><span class="line">		<span class="comment">//把一个float变量转换成String变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ftStr</span> <span class="operator">=</span> String.valueOf(<span class="number">2.345f</span>);</span><br><span class="line">		System.out.println(ftStr);</span><br><span class="line">		<span class="comment">//把一个double变量转换成String变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">dbStr</span> <span class="operator">=</span> String.valueOf(<span class="number">3.344</span>);</span><br><span class="line">		System.out.println(dbStr);</span><br><span class="line">		<span class="comment">//把一个boolean变量转换成String变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">fdStr</span> <span class="operator">=</span> String.valueOf(<span class="literal">false</span>);</span><br><span class="line">		System.out.println(fdStr.toUpperCase());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>系统把一个-128<del>127之间的整数自动装箱成Integer实例，并放入一个名为cache的数组中缓存起来。如果以后把一个-128</del>127之间的整数自动装箱成一个Integer实例时，实际上是直接指向对应的数组元素，因此-128<del>127之间的同一个整数自动装箱成Integer实例时，永远都是引用cache数组的同一个数组元素，所以它们全部相等；但每次把一个不在-128</del>127范围之内的整数自动装箱成Integer实例时，系统总会重新创建一个Integer实例，所以系统会判断不相等。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperClassCompare</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">6</span>);</span><br><span class="line">		<span class="comment">//输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;6的包装类实例是否大于5.0&quot;</span>+(a&gt;<span class="number">5.0</span>));</span><br><span class="line">		<span class="comment">//两个包装实例进行比较，只有两个包装类引用指向同一个对象时才会返回turn</span></span><br><span class="line">		System.out.println(<span class="string">&quot;比较2个包装类的实例是否相等：&quot;</span></span><br><span class="line">				+ (Double.valueOf(<span class="number">2.0</span>) == Double.valueOf(<span class="number">2.0</span>)));</span><br><span class="line">		<span class="comment">//通过自动装箱，允许把基本类型值赋给包装类实例</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">ina</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">inb</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;两个2自动装箱后是否相等：&quot;</span> + (ina == inb));</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">biga</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">bigb</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;两个128自动装箱后是否相等：&quot;</span></span><br><span class="line">				+ (biga == bigb));</span><br><span class="line">		System.out.println(Boolean.compare(<span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="包装类的方法"   >
          <a href="#包装类的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#包装类的方法" class="headerlink" title="包装类的方法"></a>包装类的方法</h4>
      <p>parseXxx()：可将字符串转成对应的基本类型值。</p>
<p>NumberFormatException异常：要转的字符串不符合数值格式，将会引发异常。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pares</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Integer op = new Integer();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ui</span> <span class="operator">=</span> <span class="string">&quot;456&quot;</span>;</span><br><span class="line">        System.out.println(Integer.parseInt(ui));</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">u</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">        System.out.println(Boolean.parseBoolean(u));</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="string">&quot;4a56&quot;</span>;</span><br><span class="line">        System.out.println(Integer.parseInt(u1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Java 7为所有包装类都提供了一个静态的compare(xxx val1 , xxx val2)方法，来比较两个基本类型值的大小，包括两个Boolean类型值也可以，且ture&gt;false。</p>
<p>Java 8 再次增强包装类的功能。</p>
<p>![](D:\Program Files\Typora\Images\729c9218e91e590474c60c4f122ab6c.jpg)</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsignedTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">		<span class="comment">//将byte类型的-3转换为无符号整数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;byte类型的-3对应的无符号整数：&quot;</span></span><br><span class="line">				+ Byte.toUnsignedInt(b));</span><br><span class="line">		<span class="comment">//指定使用十六进制解析无符号整数</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">va1</span> <span class="operator">=</span> Integer.parseUnsignedInt(<span class="string">&quot;ab&quot;</span>, <span class="number">16</span>);</span><br><span class="line">		System.out.println(va1);</span><br><span class="line">		<span class="comment">//将-16转换成无符号int型，然后转换为十六进制的字符串</span></span><br><span class="line">		System.out.println(Integer.toUnsignedString(-<span class="number">12</span>,<span class="number">16</span>));</span><br><span class="line">		<span class="comment">//将两个数转换成两个无符号整数后相除</span></span><br><span class="line">		System.out.println(Integer.divideUnsigned(-<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">		<span class="comment">//将两个数转换为无符号整数相除后求余</span></span><br><span class="line">		System.out.println(Integer.remainderUnsigned(-<span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>无符号整数最大的特点是最高位不在被当成符号位，以-3为例，其源码是10000011，其反码是11111100，补码为11111101，如果将此数当成无符号整数处理，那么最高位的1就不再是符号位，也是数值位。</p>

        <h4 id="缓存机制"   >
          <a href="#缓存机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4>
      <p>当程序对Integer使用自动装箱时，他有一个缓存机制，他会缓存值在-128~127之间的数值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(p == p1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">p15</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(p5 == p15);<span class="comment">//falue</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="6-2处理对象"   >
          <a href="#6-2处理对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2处理对象" class="headerlink" title="6.2处理对象"></a>6.2处理对象</h2>
      <p>两个要被重写的方法</p>

        <h3 id="6-2-1打印对象和toString方法"   >
          <a href="#6-2-1打印对象和toString方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-1打印对象和toString方法" class="headerlink" title="6.2.1打印对象和toString方法"></a>6.2.1打印对象和toString方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>	</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="comment">//System.out.println(name);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintObject</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建一个Person对象，将值赋给p变量</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">		<span class="comment">//打印p所引用的Person对象</span></span><br><span class="line">		System.out.println(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>System.out的println()方法只能在控制台输出字符串，而Person实例时一个内存中的对象，怎么能直接转换为字符串输出呢？当使用该方法输出Person对象时，实际上输出的是Person对象的toString()方法的返回值，也就是说下面两行代码效果完全相同。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(p);</span><br><span class="line">	System.out.println(p.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>toString()方法是一个“自我描述”方法，该方法通常用于实现这样一个功能：当程序员直接打印该对象时，<strong>系统将会输出该对象的“自我描述”信息，默认输出为“类名+@+hashCode”值，如果用户需要自定义类能实现“自我描述”的功能，就必需重写Object类的toString()方法。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;  &#125;</span><br><span class="line">	<span class="comment">//提供有参数的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(String color,<span class="type">double</span> weight)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="comment">//重写toString()方法，用于实现Apple对象的“自我描述”</span></span><br><span class="line">​	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">​	&#123;</span><br><span class="line">​		<span class="keyword">return</span><span class="string">&quot;一个苹果，颜色是：&quot;</span>+color+<span class="string">&quot;,重量是：&quot;</span>+weight;</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="string">&quot;红色&quot;</span>,<span class="number">5.68</span>);</span><br><span class="line">		<span class="comment">//打印Apple对象</span></span><br><span class="line">        System.out.println(a);  <span class="comment">//实际输出的为a.toString()方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//任何东西加&quot;&quot;都会变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a + <span class="string">&quot;&quot;</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

<p>重写toString()的固定的格式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">​	&#123;</span><br><span class="line">​		<span class="keyword">return</span><span class="string">&quot;一个苹果，颜色是：&quot;</span>+color+<span class="string">&quot;,重量是：&quot;</span>+weight;</span><br><span class="line">​	&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="6-2-2-x3D-x3D-和equals方法"   >
          <a href="#6-2-2-x3D-x3D-和equals方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-2-x3D-x3D-和equals方法" class="headerlink" title="6.2.2  &#x3D;&#x3D;和equals方法"></a>6.2.2  &#x3D;&#x3D;和equals方法</h3>
      
        <h3 id="测试两个变量是否相等的两种方式："   >
          <a href="#测试两个变量是否相等的两种方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#测试两个变量是否相等的两种方式：" class="headerlink" title="测试两个变量是否相等的两种方式："></a>测试两个变量是否相等的两种方式：</h3>
      <p>  &#x3D;&#x3D; ：如果两个变量是基本类型变量，且都是数值类型(不一定要求数据类型严格相同)，则是要两个变量的值相等，就将返回ture。但对于两个引用类型变量。只有它们指向同一对象时，才会返回ture，它不可用于比较类型上没有父子关系的两个对象。&#x3D;&#x3D;比较符也是比较指向的对象是否相同的也就是对象在对内存中的的首地址</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">fl</span> <span class="operator">=</span> <span class="number">65.0f</span>;</span><br><span class="line">		<span class="comment">//将输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;65和65.0f是否相等？&quot;</span>+(it == fl));</span><br><span class="line">		<span class="type">var</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="comment">//将输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;65和&#x27;A&#x27;是否相等？&quot;</span>+(it == ch));</span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="comment">//将输出false</span></span><br><span class="line">		System.out.println(<span class="string">&quot;str1和str2是否相等？&quot;</span></span><br><span class="line">				+ (str1 == str2));</span><br><span class="line">		<span class="comment">//输出true</span></span><br><span class="line">		System.out.println(<span class="string">&quot;str1是否equals str2？&quot;</span></span><br><span class="line">				+ (str1.equals(str2)));</span><br><span class="line">		<span class="comment">//由于java.lang.String与EqualTest类没有继承关系</span></span><br><span class="line">		<span class="comment">//所以下面语句导致编译错误</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;hello&quot; == new EqualTest());</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>new String(“hello”)时，JVM会先使用常量池来管理“hello”直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。换句话说，new String(“hello”)一共产生了两个字符串对象。</p>
<p>&#x2F;<em>常量池（constant pool）专门用于管理在编译时被确定并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口中的常量，还包括字符串常量。JVM常量池表保证相同的字符串直接量只有一个，不会产生多个副本。</em>&#x2F;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringCompareTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//s1直接引用常量池中的“疯狂Java”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//s4后面的字符串值可以在编译时就确定下来</span></span><br><span class="line">		<span class="comment">//s4直接引用常量池中的“疯狂Java”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span> + <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//s5后面的字符串值可以在编译时就确定下来</span></span><br><span class="line">		<span class="comment">//s5直接引用常量池中的“疯狂Java”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;疯&quot;</span>+<span class="string">&quot;狂&quot;</span>+<span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//s6后面的字符串值不能在编译时就确定下来</span></span><br><span class="line">		<span class="comment">//不能引用常量池中的字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s6</span> <span class="operator">=</span> s2 + s3;</span><br><span class="line">		<span class="comment">//使用new调用构造器将会创建一个新的String对象</span></span><br><span class="line">		<span class="comment">//s7引用堆内存中新建的String对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">s8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java&quot;</span>);</span><br><span class="line">		System.out.println(s1 == s4);</span><br><span class="line">		System.out.println(s1 == s5);</span><br><span class="line">		System.out.println(s1 == s6);</span><br><span class="line">		System.out.println(s1 == s7);</span><br><span class="line">		System.out.println(s8 == s7);</span><br><span class="line">		System.out.println(s8.equals(s7));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>s1,s4,s5所引用的字符串可以再编译期就确定下来，因此他们都将引用的字符串可以在编译器就确定下来，因此他们都将引用引用池中的同一个字符串对象。</p>
<p>使用new String()常见的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存）内，不会放入常量池。</p>
<p>equals()方法是Object类提供的一个实例方法，因此所有引用变量都可调用该方法来判断是否与其他引用变量变量相等，使用这个方法判断两个对象相等的标准与使用&#x3D;&#x3D;没有什么区别，同样要求两个引用变量指向用一个对象才会返回ture。因此这个方法无太大意义，如果希望采用自定义的相等标准，则可采用重写equals方法实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">c</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>+<span class="string">&quot;World&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;s1&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(s1 == s2)</span><br><span class="line">			System.out.println(<span class="string">&quot;= = succeed&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">		<span class="keyword">if</span>(s1.equals(s2))</span><br><span class="line">			System.out.println(<span class="string">&quot;.equals() succed&quot;</span>);<span class="comment">//不执行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h6 id="equals-重写应该满足一下条件"   >
          <a href="#equals-重写应该满足一下条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#equals-重写应该满足一下条件" class="headerlink" title="equals()重写应该满足一下条件"></a>equals()重写应该满足一下条件</h6>
      <ul>
<li>自反性：对任意x，x.equals(x)一定返回true。</li>
<li>对称性：对任意x和y，如果y.equals(x)返回true，则x.equals(y)也返回true。</li>
<li>传递性：对任意x,y,z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)一定返回true。</li>
<li>一致性：对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是ture，要么一直是false。</li>
<li>对任何不是null的x，x.equals(null)一定返回false。</li>
</ul>
<p>String已经重写了Object的equals()方法，String的equals()方法判断两个字符串是否相等的标准是：只要两个字符串所包含的字符串序列相同则可。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person8</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String idStr;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person8</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person8</span><span class="params">(String name,String idStr)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.idStr = idStr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此处省略name和idStr的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getIdStr</span><span class="params">(String idStr)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.idStr = idStr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getIdStr</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.idStr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重写equals</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果两个对象同一个对象</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//只有当obj是Person对象</span></span><br><span class="line">		<span class="comment">//getClass() 返回此 Object 的运行时类</span></span><br><span class="line">		<span class="comment">//类名.class表示语法，表示Person这个类的类型信息</span></span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Person8.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">personObj</span> <span class="operator">=</span> (Person8) obj;</span><br><span class="line">			<span class="comment">//并且当前对象的idStr与obj对象的idStr相等时才可以判断两个对象相等</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.getIdStr().equals(personObj.getIdStr()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideEqualsRight</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person8</span>(<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;123456789987&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person8</span>(<span class="string">&quot;孙大圣&quot;</span>,<span class="string">&quot;123456789987&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person8</span>(<span class="string">&quot;齐天大圣&quot;</span>,<span class="string">&quot;123654&quot;</span>);</span><br><span class="line">		<span class="comment">//p1和p2的idStr相等，所以输出ture</span></span><br><span class="line">		System.out.println(<span class="string">&quot;p1和p2是否相等？&quot;</span></span><br><span class="line">				+ p1.equals(p2));</span><br><span class="line">		<span class="comment">//p2和p3的idStr不相等，所以输出flase</span></span><br><span class="line">		System.out.println(<span class="string">&quot;p2和p3是否相等？&quot;</span></span><br><span class="line">				+ p2.equals(p3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>类名.class表示语法，表示Person这个类的类型信息</p>
<p>instanceof 是Java的一个二元操作符（运算符）,也是Java的保留关键字。它的作用是判断其左边对象是否为其右边类的实例，返回的是boolean类型的数据。用它来判断某个对象是否是某个Class类的实例。（左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。）</p>
<p>重写equals()的固定的格式</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果两个对象同一个对象</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//只有当obj是Person对象</span></span><br><span class="line">		<span class="comment">//getClass() 返回此 Object 的运行时类</span></span><br><span class="line">		<span class="comment">//类名.class表示语法，表示Person这个类的类型信息</span></span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Person8.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">personObj</span> <span class="operator">=</span> (Person8) obj;</span><br><span class="line">			<span class="comment">//并且当前对象的idStr与obj对象的idStr相等时才可以判断两个对象相等</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.getIdStr().equals(personObj.getIdStr()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="6-3类成员"   >
          <a href="#6-3类成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-3类成员" class="headerlink" title="6.3类成员"></a>6.3类成员</h2>
      
        <h3 id="static"   >
          <a href="#static" class="heading-link"><i class="fas fa-link"></i></a><a href="#static" class="headerlink" title="static"></a>static</h3>
      <p>static并不是静态的意思，而是类的意思！有static的成员属于类成员，没有static的成员属于实例成员。</p>
<p>static可以修饰的成员：成员变量，方法，内部类，初始化块。</p>

        <h4 id="static成员（成员变量，方法，内部类，初始化块）-属于类成员"   >
          <a href="#static成员（成员变量，方法，内部类，初始化块）-属于类成员" class="heading-link"><i class="fas fa-link"></i></a><a href="#static成员（成员变量，方法，内部类，初始化块）-属于类成员" class="headerlink" title="static成员（成员变量，方法，内部类，初始化块）-属于类成员"></a>static成员（成员变量，方法，内部类，初始化块）-属于类成员</h4>
      <p>所有的类成员只能用类名来调用。</p>
<p>面试的时候遇到使用对象调用类成员的时候，只需要把对象换成类，题目将一目了然。</p>

        <h4 id="static考点（笔试很常见）"   >
          <a href="#static考点（笔试很常见）" class="heading-link"><i class="fas fa-link"></i></a><a href="#static考点（笔试很常见）" class="headerlink" title="static考点（笔试很常见）"></a>static考点（笔试很常见）</h4>
      <p>static成员不可以访问非static成员；</p>
<p>非static成员可以访问static成员！</p>
<p>static成员4种不能访问非static成员5种。</p>

        <h4 id="单例模式"   >
          <a href="#单例模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4>
      <p>设计模式：对于一批经常出现设计场景，前人总结出来的比较成功的设计——设计模式。</p>
<p>​	学习并模仿，从而提高我们的代码质量。</p>
<p>单例模式：在某些场景下，某些类只需（只能）要创建一个实例。比如系统的窗口管理器，数据库引擎访问点，Java程序所在的JRE环境·····都只需要创建一个实例。此时就应该采用单例模式。</p>

        <h5 id="如何创建单例模式"   >
          <a href="#如何创建单例模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何创建单例模式" class="headerlink" title="如何创建单例模式"></a>如何创建单例模式</h5>
      <ol>
<li>隐藏构造器。这样就可以避免被创建实例。</li>
<li>暴露一个static的方法，该方法用于创建实例。该方法还必须要保证，该类只会产生一个实例。</li>
</ol>
<p>在Java类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员，其中static可以修饰成员变量，方法、初始化块、内部类（接口、枚举），以static修饰的成员就是类成员。类成员属于整个类。而不属于单个对象。</p>
<p>类变量的生存范围从系统第一次使用该类时开始，直到该类被卸载。几乎等同于该类的生存范围。当类初始化完成后，类变量也被初始化完成。</p>
<p>当通过对象来访问类变量时，系统会在底层转换为通过该类访问类变量。</p>
<p><strong>类成员不能访问实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）。</strong>因此类成员时属于类的，类成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还没初始化的情况，如果允许类成员访问实例变量将会引起大量错误。  </p>

        <h3 id="6-3-2单例（Singleton）类"   >
          <a href="#6-3-2单例（Singleton）类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-3-2单例（Singleton）类" class="headerlink" title="6.3.2单例（Singleton）类"></a>6.3.2单例（Singleton）类</h3>
      <p>如果一个类始终只能创建一个实例，则这个类被称为单例类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//使用一个类变量来缓存曾经创建的实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="comment">//隐藏构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="comment">//提供一个静态方法，用于返回Singleton实例</span></span><br><span class="line">	<span class="comment">//该方法可以加入自定义控制，保证值产生一个Singleton对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>)<span class="comment">//判断是否已经创建了实例 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//创建一个对象，并将其缓存起来。</span></span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">		<span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">		<span class="comment">//输出ture</span></span><br><span class="line">		System.out.println(s1 ==s2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过getInstance方法提供的自定义控制（这也是封装的又是；不允许自由访问类成员变量和实现细节，而正式通过方法来控制合适的暴露），保证类只能产生一个实例，所以在类的main方法种，看到两次产生的对象实际是同一对象.</p>

        <h2 id="6-4-final修饰符"   >
          <a href="#6-4-final修饰符" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-final修饰符" class="headerlink" title="6.4   final修饰符"></a>6.4   final修饰符</h2>
      <p>final关键字可用于修饰类、变量和方法，用于表示他修饰的类、方法和变量不可改变。final与abstract互斥：永远不能同时出现。</p>
<p>final修饰的变量不可被改变，一旦获得了初始值，该final变量的值就不能被重新赋值。（必须赋值而且只能且只能赋值一次）</p>

        <h3 id="6-4-1-final成员变量"   >
          <a href="#6-4-1-final成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-1-final成员变量" class="headerlink" title="6.4.1 final成员变量"></a>6.4.1 final成员变量</h3>
      <p>普通的成员变量：程序员可以不显式的指定初始值，系统会为之分配初始值。初始值分配规则与数组与数组元素的分配规则完全相同。</p>
<p><strong>final修饰的成员变量必须由程序员显式地指定初始值。</strong></p>
<p>final修饰地类变量、实例变量能指定初始值的地方如下：</p>
<ul>
<li>类变量：必须在静态初始化块中指定初始值或声明该类变量是指定的初始值，而且只能在两个地方的其中之一指定。</li>
<li>实例变量：必须在非静态初始化块、声明该实例变量或每个构造器中指定初始值，而且只能在三个地方的其中之一指定（三个位置的本质都是构造器）。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVariableTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义成员变量时指定默认值，合法</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//	下面变量将在构造器或初始化块中指定初始值</span></span><br><span class="line">	<span class="keyword">final</span> String str;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> d;</span><br><span class="line"><span class="comment">//	final char ch;</span></span><br><span class="line"><span class="comment">//	初始化块，可对没有指定默认值的实例变量指定初始值</span></span><br><span class="line">	&#123;</span><br><span class="line">		str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		a = 9;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	静态初始化块，可对没有指定默认值的类变量指定初始值</span></span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		d = <span class="number">5.6</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	构造器，可对既没有指定默认值，又没有在初始化块中指定初始值的实例变量指定初始值</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FinalVariableTest</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		如果初始化块中已经对str指定了初始值</span></span><br><span class="line"><span class="comment">//		那么在构造器中不能对final变量重新赋值，下面赋值语句非法</span></span><br><span class="line"><span class="comment">//		str = &quot;World&quot;;</span></span><br><span class="line">		c = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//		ch = &#x27;A&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeFinal</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		普通方法不能为final修饰的成员变量赋值</span></span><br><span class="line"><span class="comment">//		d = 5.1;</span></span><br><span class="line"><span class="comment">//		不能在普通方法中为final成员变量指定初始值</span></span><br><span class="line"><span class="comment">//		ch = &#x27;S&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	public void shuchu()</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		System.out.println(ch);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">FinalVariableTest</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalVariableTest</span>();</span><br><span class="line"><span class="comment">//		v.shuchu();</span></span><br><span class="line">		System.out.println(v.a);</span><br><span class="line">		System.out.println(v.c);</span><br><span class="line">		System.out.println(v.d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>与普通成员变量不同的是，final成员变量（包括实例变量和类变量）必须由程序员显式初始化。 </p>
<p>如果打算在构造器或初始化块中对final成员变量进行初始化，则不要在初始化之前访问final成员变量；否则由于Java允许通过方法访问final成员变量，此时将看到系统将final成员变量默认初始化为0（或’\u0000’、false或null）的情况。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalErrorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		系统不会对final成员变量进行默认初始化</span></span><br><span class="line">        <span class="comment">//java不允许在final成员变量显式初始化之前直接调用该成员变量，所以代码错误。</span></span><br><span class="line"><span class="comment">//		System.out.println(age);</span></span><br><span class="line"><span class="comment">//		因为Java允许方法来访问final修饰的成员变量，</span></span><br><span class="line"><span class="comment">//		此时系统将默认初始化，将输出0</span></span><br><span class="line">		printAge();</span><br><span class="line">		age = <span class="number">6</span>;</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">FinalErrorTest</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="final局部变量"   >
          <a href="#final局部变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#final局部变量" class="headerlink" title="final局部变量"></a>final局部变量</h3>
      <p>&#x3D;&#x3D;系统不会对局部变量进行初始化，局部变量必须由程序员显式初始化。&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalLocalVariableTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		不能对final修饰的形参赋值</span></span><br><span class="line"><span class="comment">//		a = 3;</span></span><br><span class="line">		System.out.println(<span class="string">&quot;成功对a进行了初始化，且a的值为：&quot;</span></span><br><span class="line">				+ a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FinalLocalVariableTest</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">//		str = &quot;Java&quot;;</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">double</span> d;</span><br><span class="line">		d = <span class="number">5.6</span>;</span><br><span class="line"><span class="comment">//		d = 3.4;</span></span><br><span class="line">		<span class="type">FinalLocalVariableTest</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalLocalVariableTest</span>();</span><br><span class="line">		s.test(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因为形参在调用方法时，由系统根据传入的参数进行初始化，所以使用final修饰的形参不能被赋值。</p>

        <h3 id="6-4-3-final修饰基本类型变量和引用类型变量的区别"   >
          <a href="#6-4-3-final修饰基本类型变量和引用类型变量的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-3-final修饰基本类型变量和引用类型变量的区别" class="headerlink" title="6.4.3 final修饰基本类型变量和引用类型变量的区别"></a>6.4.3 final修饰基本类型变量和引用类型变量的区别</h3>
      <p>当使用final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变，<strong>但对于引用类型变量而言，他保存的仅仅是一个引用，final只保证这个引用类型所引用的地址不变，即一直引用同一个对象，但这个对象完全可以发生改变。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Personq</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Personq</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="comment">//有参数的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Personq</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReferenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		final修饰数组变量，iArr时一个引用变量</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span>[] iArr = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">9</span>&#125;;</span><br><span class="line">		System.out.println(Arrays.toString(iArr));</span><br><span class="line"><span class="comment">//		对数组元素进行排序，合法</span></span><br><span class="line">		Arrays.sort(iArr);</span><br><span class="line">		System.out.println(Arrays.toString(iArr));</span><br><span class="line"><span class="comment">//		对数组元素进行赋值，合法</span></span><br><span class="line">		iArr[<span class="number">2</span>] = -<span class="number">8</span>;</span><br><span class="line">         iArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		System.out.println(Arrays.toString(iArr));</span><br><span class="line"><span class="comment">//		下面语句对iArr重新赋值，非法</span></span><br><span class="line"><span class="comment">//		iArr = &#123;2,6,4,8&#125;;</span></span><br><span class="line"><span class="comment">//		final 修饰Person变量，p时一个引用变量</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Personq</span>(<span class="number">45</span>);</span><br><span class="line"><span class="comment">//		改变Person对象的age实例变量，合法</span></span><br><span class="line">		p.setAge(<span class="number">23</span>);</span><br><span class="line">		System.out.println(p.getAge());</span><br><span class="line"><span class="comment">//		下面语句对p重新赋值，非法</span></span><br><span class="line"><span class="comment">//		p = null;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上可得，使用final修饰的引用类型变量不能被重新赋值，但可以改变引用类型变量所引用对象的内容。例如iArr变量所引用的数组对象，final修饰后的iArr变量不能被重新赋值，但是iArr所引用的数组元素可以被改变。相似的有，p变量不能被重新赋值，但是p变量所引用Person对象的成员变量的值可以被改变。</p>

        <h3 id="6-44-可执行“宏替换”的final变量"   >
          <a href="#6-44-可执行“宏替换”的final变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-44-可执行“宏替换”的final变量" class="headerlink" title="6.44 可执行“宏替换”的final变量"></a>6.44 可执行“宏替换”的final变量</h3>
      <p>对于final变量来说，不管他是类变量、实例变量，还是局部变量，只要该变量满足三个条件，这个final变量就不再是一个变量，而是相当于一个直接量。</p>
<ul>
<li>使用final修饰符修饰。</li>
<li>在定义该final变量时指定了初始值。</li>
<li>该初始值可以在编译时就被确定下来。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalLocalTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对于此程序，当程序执行System.out.println(a);，实际转换为执行System.out.println(5);这就是final修饰符的一个重要用途–<strong>宏定义</strong>，编译器会在程序中所有用到该变量的地方直接替换成该变量的值。</p>
<p>被赋值的可以是直接量，可以时算数表达式或字符串连接运算，没有访问普通变量，调用方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReplaceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span> + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.2</span> / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//字符串连接运算</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>+<span class="string">&quot;Java&quot;</span>;<span class="comment">//编译阶段就会计算结果</span></span><br><span class="line">        <span class="comment">//字符串连接运算，隐式类型（将数值转字符串）</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java讲义：&quot;</span>+<span class="number">99.0</span>;</span><br><span class="line">		<span class="comment">//调用了方法，无法在编译时被确定下来，无法当作宏变量处理</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java讲义：&quot;</span>+String.valueOf(<span class="number">99.0</span>);</span><br><span class="line">		System.out.println(d == <span class="string">&quot;疯狂Java讲义：99.0&quot;</span>);<span class="comment">//因为java常量池，所以返true。</span></span><br><span class="line">		System.out.println(d2 == <span class="string">&quot;疯狂Java讲义：99.0&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringJoinTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;疯狂Java&quot;</span>;</span><br><span class="line">		<span class="comment">//两个字符串直接量连接，编译时即可确定类型</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span> + <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		System.out.println(s1 == s2);<span class="comment">//ture</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>;</span><br><span class="line">		<span class="type">var</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">		<span class="comment">//两个普通变量的运算，编译器不会执行“宏替换”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str3</span> <span class="operator">=</span> str1 + str2;<span class="comment">// str1 /str2是变量，要等到运算的时候才能结算结果，无法使用池中的字符串</span></span><br><span class="line">		System.out.println(s1 == str3);<span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">var</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;疯狂&quot;</span>;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">var</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="type">var</span> <span class="variable">str5</span> <span class="operator">=</span> str3 + str4;	<span class="comment">// str3 /str4会消失，相当于System.out.println(str3 + str4)</span></span><br><span class="line">        System.out.println(str5 == str2)</span><br><span class="line">        <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>str1和str2只是两个普通变量，编译器不会执行“宏替换”，因此编译器无法在编译时确定s3的值，这是可以让编译器对两个变量执行“宏替换”（使用final修饰）。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myself</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;张智超&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1+<span class="string">&quot;为&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2+<span class="string">&quot;卡宴&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3+<span class="string">&quot;拼搏的&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4+<span class="string">&quot;第一天&quot;</span>;</span><br><span class="line">    System.out.println(s5);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;张智超为卡宴拼搏的第一天&quot;</span>);<span class="comment">//与上面的输出结果完全相同，上面的更加简单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="6-4-5-final方法"   >
          <a href="#6-4-5-final方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-5-final方法" class="headerlink" title="6.4.5 final方法"></a>6.4.5 final方法</h3>
      <p>final修饰的方法不可被重写，如果出于某些原因不希望子类重写父类的某个方法，则可以使用final修饰该方法。——该方法可以被重载，也可以被子类调用！</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sub</span> <span class="keyword">extends</span> <span class="title class_">FinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//编译会出错，不允许重写test方法</span></span><br><span class="line">	<span class="comment">//public  void test() &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>private修饰的final方法时，因为它仅在当前类可见，其子类无法访问该方法，所以子类无法重写该方法，如果子类出现同名函数，不是重写只是定义了一个新方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateFinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//private已经被隐藏在方法内部</span></span><br><span class="line">    <span class="comment">//子类无法访问该方法，因此也无法重写</span></span><br><span class="line">    <span class="comment">//此处的final无意义</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">PrivateFinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>【备注】：private已经被隐藏在方法，内部子类无法访问该方法，因此也无法重写。<br>                            final修饰的private方法纯属多余！但Java允许。</p>
<p>final修饰的方法仅仅时不能被重写，并不是不能被重载。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalOverload</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//final修饰的方法不可以重写，但可以重载哦！</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String arg)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-4-6-final类"   >
          <a href="#6-4-6-final类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-6-final类" class="headerlink" title="6.4.6 final类"></a>6.4.6 final类</h3>
      <p>final修饰的类不可以派生子类。例如java.lang.Math类String、System。</p>
<p>当子类继承父类时，将可以访问到父类内部的内部数据，并可以通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素，可以用final修饰这个类，使该类无法继承。</p>

        <h3 id="6-4-7-不可变类"   >
          <a href="#6-4-7-不可变类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-7-不可变类" class="headerlink" title="6.4.7 不可变类"></a>6.4.7 不可变类</h3>
      <p>不可变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。Java提供的8个包装类和java.lang.String类都是不可变类，当创建他们的实例后，其实例的实例变量不可改变。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> Double.valueOf(<span class="number">6.5</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>如果需要创建自定义的不可变类，可遵守如下规则：</p>
<ul>
<li>使用private和final修饰符来修饰该类的成员变量。</li>
<li>提供带参数的构造器（或返回该实例的类方法），用于根据传入参数来初始化类里的成员变量。</li>
<li>仅为该类的成员变量提供getter方法，不要为该类的成员提供setter方法，因为普通方法无法修改final修饰的成员变量。</li>
<li>如果有必要，重写Object类的hashCode()和equal()方法。equal()方法根据关键成员变量来作为两个对象是否相等的标准，除此之外，还应该保证两个用equal()方法判断为相等对象的hashCode()也相等。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String detail;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String postCode;</span><br><span class="line"><span class="comment">//	定义带参数的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String datail,String postCode)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.detail = datail;</span><br><span class="line">		<span class="built_in">this</span>.postCode = postCode;</span><br><span class="line">	&#125;  </span><br><span class="line"><span class="comment">//	定义两个成员变量的getter方法</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getDetail</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> detail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPostCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> postCode;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写equals方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equlas</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == Address.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">ad</span> <span class="operator">=</span> (Address)obj;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.getDetail().equals(ad.getDetail())</span><br><span class="line">					&amp;&amp; <span class="built_in">this</span>.getPostCode().equals(ad.getPostCode()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> detail.hashCode() + postCode.hashCode() * <span class="number">31</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的Address类，当程序创建了Address对象后，同意无法修改该Address对象的detail和postCode实例变量的值。</p>
<p>当使用final修饰引用类型变量时，仅代表这个引用类型变量不可被重新赋值，但引用类型变量所指向的对象依然是可变的。这就产生了一个问题：当创建不可变类时，如果它包含成员变量的类型是可变的，那么其对象的成员变量的值依然是可改变的——这个不可变类其实是失败的。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String firstName;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Name</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Name</span><span class="params">(String firstName,String lastName)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">		<span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> firstName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> lastName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Name name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Name name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Name <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&quot;悟空&quot;</span>,<span class="string">&quot;孙&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Persom</span>(n);</span><br><span class="line">		System.out.println(p.getName().getFirstName());</span><br><span class="line">        <span class="comment">//改变Persom对象的name的firstName值。</span></span><br><span class="line">		n.setFirstName(<span class="string">&quot;八戒&quot;</span>);</span><br><span class="line">		System.out.println(p.getName().getFirstName());</span><br><span class="line">		System.out.println(n.getLastName()+n.getFirstName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>当不可变类的实例变量引用了可变类的对象时，会被破坏设计不可变类的初衷。</p>
<p>因此对Persom类进行部分修改：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Persom</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Name name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Persom</span><span class="params">(Name name)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		设置name实例变量为临时创建的Name对象，该对象的getFirstName和gerLastName</span></span><br><span class="line"><span class="comment">//		与传入的name参数的firstName和lastName相同</span></span><br><span class="line">		<span class="built_in">this</span>.name = <span class="keyword">new</span> <span class="title class_">Name</span>(name.getFirstName(),name.getLastName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Name <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		返回一个匿名对象，该对象的firstName和lastName</span></span><br><span class="line"><span class="comment">//		与该对象里的name的firstName和lastName相同</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Name</span>(name.getFirstName(),name.getLastName());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

<p>Persom类改写了设置name实例变量的方法，也改写了name的getter方法。当程序向Persom构造器里传入一个Name对象时，该构造器创建Persom对象时并不是直接利用已有的Name对象（利用已有的Name对象有风险，因为这个已有的Name对象是可变的，如果程序改变了这个Name对象，将会导致Persom对象也发生变化），而是重新创建了一个Name对象来赋给Persom对象的name实例变量。当Persom对象返回name变量时，他并没有直接把name实例变量返回，直接返回name实例变量的值也可能导致它所引用的Name对象被修改。</p>
<p>所以，创建不可变类要注意其引用类型的成员变量的类是否可变。</p>

        <h3 id="6-4-8-缓存实例的不可变类"   >
          <a href="#6-4-8-缓存实例的不可变类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4-8-缓存实例的不可变类" class="headerlink" title="6.4.8 缓存实例的不可变类"></a>6.4.8 缓存实例的不可变类</h3>
      <p>如果程序经常使用相同的不可变类实例，则应该考虑缓存这种不可变类实例。</p>

        <h4 id="使用一个数组来作为缓存池，看不懂"   >
          <a href="#使用一个数组来作为缓存池，看不懂" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用一个数组来作为缓存池，看不懂" class="headerlink" title="使用一个数组来作为缓存池，看不懂"></a>使用一个数组来作为缓存池，看不懂</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheImmutale</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//使用数组来缓存已有的实例</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CacheImmutale[] cache = <span class="keyword">new</span> <span class="title class_">CacheImmutale</span>[MAX_SIZE];</span><br><span class="line"><span class="comment">//	记录缓存实例在缓存中的位置，cache[pos - 1]是最新缓存实例。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">CacheImmutale</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> CacheImmutale <span class="title function_">valueOf</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//遍历已缓存的对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; MAX_SIZE;i++)</span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			如果已有相同实例，则直接返回该缓存的实例</span></span><br><span class="line">			<span class="keyword">if</span>(cache[i] != <span class="literal">null</span></span><br><span class="line">					&amp;&amp; cache[i].getName().equals(name))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> cache[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果缓存池已满</span></span><br><span class="line">		<span class="keyword">if</span>(pos == MAX_SIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把缓存的第一个对象覆盖，即把刚刚生成的对象放在缓存池的最开始位置</span></span><br><span class="line">				cache[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">CacheImmutale</span>(name);</span><br><span class="line">				<span class="comment">//把pos设为1</span></span><br><span class="line">				pos = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把新创建的对象缓存起来，pos加1</span></span><br><span class="line">			cache[pos++] = <span class="keyword">new</span> <span class="title class_">CacheImmutale</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cache[pos - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(obj != <span class="literal">null</span> &amp;&amp; obj.getClass() == CacheImmutale.class)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">ci</span> <span class="operator">=</span> (CacheImmutale)obj;</span><br><span class="line">			<span class="keyword">return</span> name.equals(ci.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheImmutaleTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c1</span> <span class="operator">=</span> CacheImmutale.valueOf(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">c2</span> <span class="operator">=</span> CacheImmutale.valueOf(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		System.out.println(c1 == c2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>CacheImmutale类使用一个数组来缓存该类的对象，这个数组长度为MAX_SIZE，即该类共可以缓存MAX_SIZE个CacheImmutale对象。当缓存池已满时，采用“先进先出（FIFO）”规则来决定哪个对象将被移出缓存池。</p>
<p>CacheImmutale类能控制系统生成CacheImmutale对象的个数，需要程序使用该类的valueOf()方法来得到其对象，而且程序使用private修饰符来隐藏该类的构造器，因此程序只能通过该类提供的valueOf()方法来获得实例。</p>
<p>Integer类构造器和valueOf方法存在的差异：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerCacheTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		生成新的Integer对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">6</span>);</span><br><span class="line">		<span class="comment">//生成新的并缓存该对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//		直接从缓存池中取出 </span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in3</span> <span class="operator">=</span> Integer.valueOf(<span class="number">6</span>);</span><br><span class="line">		System.out.println(in1 == in2);</span><br><span class="line">		System.out.println(in2 == in3);</span><br><span class="line"><span class="comment">//		由于Integer只缓存-128~127之间的值因此200对应的Integer对象没有缓存</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">in4</span> <span class="operator">=</span> Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		<span class="type">var</span> <span class="variable">in5</span> <span class="operator">=</span> Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">		System.out.println(in4 == in5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="6-5抽象类"   >
          <a href="#6-5抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-5抽象类" class="headerlink" title="6.5抽象类"></a>6.5抽象类</h2>
      <p>抽象类（有得有失）：抽象类可以有抽象方法，但不可以创建对象</p>
<p>抽象类的主要作用：派生子类！	子类构造器一定要调用构造器一次，因此抽象类必须有构造器。这就是final和abstract互斥的原因。</p>
<p>抽象方法：只有方法签名，没有方法体的方法</p>
<p>子类要么重写父类中的抽象方法，要么子类也只能是抽象的（如果子类没有重写父类的抽象方法，那么就说明子类继承得到了父类）</p>

        <h3 id="6-5-1抽象方法和抽象类"   >
          <a href="#6-5-1抽象方法和抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-5-1抽象方法和抽象类" class="headerlink" title="6.5.1抽象方法和抽象类"></a>6.5.1抽象方法和抽象类</h3>
      <p>有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。</p>
<ul>
<li><p>抽象方法和抽象类必须使用abstract修饰符修饰，抽象方法不能有方法体。</p>
</li>
<li><p>抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。</p>
</li>
<li><p>抽象类可以包含成员变量，方法，构造器，初始化块，内部类。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</p>
</li>
<li><p>含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含）只能被定义成抽象类。</p>
</li>
</ul>
<p>总而言之，抽象类有得有失，抽象类可以包含抽象方法；抽象类不能创建实例。</p>
<p>定义抽象方法的方法：在普通方法上加上abstract修饰，并把方法体去掉。</p>
<p>定义抽象类的方法：在普通类上加上abstract修饰。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行Shape的初始化块·····&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	<span class="comment">//定义一个计算周长的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calPerimeter</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//定义一个返回形状的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getType</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">//定义Shape的构造器，该构造器并不是用于创建Shape对象</span></span><br><span class="line"><span class="comment">//	而是用于子类调用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行Shape的构造器·····&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span></span><br><span class="line">	&#123;</span><br><span class="line">			<span class="built_in">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Shape类里包含了两个抽象方法：calPerimeter()和getType()，所以Shape类只能被定义成抽象类，Shape类里既包含了初始化块，也包含了构造器，这些都不是在创建Shape对象时被调用的，而是在创建其子类的实例时被调用的。</p>
<p>&#x3D;&#x3D;抽象类不能用于创建实例，只能当作父类被其他子类继承。&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> a;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> b;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Triangle</span><span class="params">(String color, <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">super</span>(color);</span><br><span class="line">		<span class="built_in">this</span>.setSides(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSides</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a &gt;= b + c || b &gt;= a + c || c &gt;= a + b)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;三角形两边之和必须大于第三边&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.a = a;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">		<span class="built_in">this</span>.c = c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	重写Shape类的计算周长的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calPerimeter</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b + c;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写Shape类的返回形状的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;三角形&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>普通类继承抽象类，普通类中必须实现抽象类中的抽象方法。</strong></p>
<p>上面的Triangle类继承了Shape抽象类，并实现了Shape的两个抽象方法，是一个普通类，因此可以创建Triangle类的实例，可以让Shape类型的引用变量指向Triangle对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(String color,<span class="type">double</span> radius)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">super</span>(color);</span><br><span class="line">		<span class="built_in">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	重写Shape类的计算周长的抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calPerimeter</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>*Math.PI*radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> getColor() + <span class="string">&quot;圆形&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Shape</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="string">&quot;黑色&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">		<span class="type">Shape</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="string">&quot;黄色&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//		输出形状和周长。</span></span><br><span class="line">		System.out.println(s1.getType());</span><br><span class="line">		System.out.println(s1.calPerimeter());</span><br><span class="line">		System.out.println(s2.getType());</span><br><span class="line">		System.out.println(s2.calPerimeter());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">执行Shape的初始化块·····         //参考5.9.3类初始化块。p163</span></span><br><span class="line"><span class="comment">执行Shape的构造器·····</span></span><br><span class="line"><span class="comment">执行Shape的初始化块·····</span></span><br><span class="line"><span class="comment">执行Shape的构造器·····</span></span><br><span class="line"><span class="comment">三角形</span></span><br><span class="line"><span class="comment">12.0</span></span><br><span class="line"><span class="comment">黄色圆形</span></span><br><span class="line"><span class="comment">18.84955592153876</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure>

<p>上面main()方法中定义了两个Shape类型的引用变量，它们分别指向Triangle对象和Circle对象，由于在Shape类中定义了calPerimeter()方法和getType()方法，所以程序可以直接调用s1变量和s2变量的calPerimeter()方法和getType()方法，无需强制转换为子类类型。</p>
<p>利用抽象类和抽象方法的优势，可以更好地发挥多态的优势，使得程序更加灵活。</p>
<p>当使用abstract修饰类时，表明这个类智能被继承；当使用abstract需要事故方法时，表明这个方法须由自雷实现（即重写）。而fianl修饰的类不能被继承，final修饰的方法不能被重写，因此final和abstract永远不能同时使用。</p>
<p>abstract只能修饰类和方法，不能修饰成员变量、局部变量和构造器，抽象类里定义的构造器只能是普通构造器。</p>

        <h3 id="6-5-2抽象类的作用"   >
          <a href="#6-5-2抽象类的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-5-2抽象类的作用" class="headerlink" title="6.5.2抽象类的作用"></a>6.5.2抽象类的作用</h3>
      <p>&#x3D;&#x3D;抽象类的体现就是一种模板模式的设计&#x3D;&#x3D;，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展，改造，但子类总体上会大致保留抽象类的行为方式，例如上节提到三个类。下面在介绍一个模板模式的范例，这个范例的抽象父类中，父类的普通方法依赖于一个普通方法，而子类方法则推迟到子类中提供实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SpeedMeter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	转速</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> turnRate;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SpeedMeter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="comment">//	把计算车轮周长的方法定义成抽象方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calGirth</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTurnRate</span><span class="params">(<span class="type">double</span> turnRate)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.turnRate = turnRate;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义计算速度的通用方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> calGirth()*turnRate;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>定义了一个SpeedMeter类（车速表）,该表中定义了一个getSpeed()方法，该方法用于返回当前车速，getSpeed()方法依赖与calGirth()方法的返回值，对于一个抽象的SpeedMeter类而言，它无法确定车轮的周长，因此calGirth()方法必须推迟到其子类中实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarSpeedMeter</span> <span class="keyword">extends</span> <span class="title class_">SpeedMeter</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CarSpeedMeter</span><span class="params">(<span class="type">double</span> radius)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calGirth</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> radius * <span class="number">2</span> * Math.PI;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">csm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarSpeedMeter</span>(<span class="number">0.34</span>);</span><br><span class="line">		csm.setTurnRate(<span class="number">15</span>);</span><br><span class="line">		System.out.println(csm.getSpeed());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>SpeedMeter类里提供了速度表的通用算法，但一些具体的实现细节则推迟到其子类CarSpeedMeter类中实现。这也是一种典型的模板模式。</p>

        <h2 id="6-6-Java-9改进的接口"   >
          <a href="#6-6-Java-9改进的接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-Java-9改进的接口" class="headerlink" title="6.6  Java 9改进的接口"></a>6.6  Java 9改进的接口</h2>
      <p>抽象类是从多个类中抽象出来的模板，如果将这种抽象进行得更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（interface）。Java 9对接口进行了改进，允许在接口中定义默认方法和类方法，默认方法和类方法都可以提供方法实现，Java 9为接口增加了一种私有方法，私有方法也可以提供方法实现。</p>

        <h3 id="6-6-1-接口的概念"   >
          <a href="#6-6-1-接口的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-1-接口的概念" class="headerlink" title="6.6.1 接口的概念"></a>6.6.1 接口的概念</h3>
      <p>![](C:\Program Files\Typora\image\P10319-124747.jpg)</p>
<p>同一个类的内部状态数据、各种方法的实现细节完全相同，类是一种具体实现体，而接口定义了一种规范，接口定义了某一批类所需要遵守的规范，接口u不关心内部状态数据，也不关心这些类里方法的实现细节，他只规定这批类里必须提供某些方法，提供这些方法的类就课满足满足实际需求。</p>
<p>可见，接口是从多个相似类中抽象出来的规范，接口不提供任何实现，接口体现的是规范和实现分离的设计学。</p>
<p>让规范和实现风力正是接口的好处，让软件系统的各组件之间面向对象接口耦合，是一种松耦合的设计，软件系统的各模块之间之间也应该采用这种面向接口的耦合，从而尽量降低各模块之间的耦合，为系统提供更好的可拓展性和维护性。</p>

        <h3 id="6-6-2Java-9中接口的定义"   >
          <a href="#6-6-2Java-9中接口的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-2Java-9中接口的定义" class="headerlink" title="6.6.2	Java 9中接口的定义"></a>6.6.2	Java 9中接口的定义</h3>
      <p>与定义类不同，定义接口不再使用class关键字，而是使用<strong>interface关键字</strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 externds 父接口<span class="number">1</span>,父接口<span class="number">2</span>,···</span><br><span class="line">&#123;</span><br><span class="line">	零到多个常量定义；</span><br><span class="line">	零到多个抽象方法定义；</span><br><span class="line">	零到多个内部类、接口、枚举定义；</span><br><span class="line">	零到多个私有方法、默认方法或类方法定义；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>修饰符可以是public，也可以省略，省略后则默认为采用包权限访问控制符，即默认采用包权限访问控制符，即只有在相同结构下才可以访问该接口。</li>
<li>从语法角度来看，接口名为合法的标识符即可，从可读性来看，可加形容词，每个单词的首字母大写。</li>
<li>一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</li>
</ul>
<p>接口中包含<strong>成员变量</strong>（只能是静态常量），<strong>方法</strong>（只能是抽象实例方法、类方法、默认方法或私有方法），<strong>内部类</strong>（包含内部接口、枚举）。不包含构造器和初始化块。权限全部为public。</p>
<p>Java 9为接口增加了一种新的<strong>私有方法</strong>，其实私有方法的主要作用就是做为工具方法，为接口中的默认方法或类方法提供支持。私有方法可以拥有方法体，私有方法既可以是类方法（用static修饰），也可以是实例方法。</p>
<p>对于定义静态常量而言，系统会自动添加public static final修饰符，而且接口里没有构造器和初始化块，所以静态常量需要在定义时就指定默认值。</p>
<p>接口中定义的方法只能是抽象方法，类方法、默认方法（实例方法）或私有方法；因此如果不是定义默认方法、类方法或私有方法，系统将自动为普通方法增加abstract修饰符；定义接口里的普通方法时，不管是否使用public abstract修饰符，接口里的普通方法总是使用public abstract来修饰。接口里的普通方法不能有方法实现（方法体），但类方法，私有方法、默认方法都必须有方法体。（<strong>也就是说，无普通方法，系统会自动转换为抽象方法，而且抽象方法本身就不可定义方法体。</strong>）</p>
<p>总结：</p>
<p>​	接口里定义内部类、内部接口、内部枚举，默认采用public static 两个修饰符。</p>
<p>​	接口里定义普通方法默认使用public abstract修饰符，转换为抽象方法。</p>
<p>​	接口里定义静态常量默认使用public static final修饰符，并要定义时指定初始值。</p>
<p>​	接口里定义默认方法（实例方法）使用 public default修饰。</p>
<p>​	接口里定义类方法用public static，系统会自动添加public。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Output</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	接口里定义的成员变量只能是常量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">MAX_CACHE_LINE</span> <span class="operator">=</span> <span class="number">50</span>;  </span><br><span class="line">    <span class="comment">//等价于 public static final int MAX_CACHE_LINE = 50; </span></span><br><span class="line"><span class="comment">//	接口里定义的普通方法只能是public的抽象方法</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//等价与 public abstract void out();</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">getDate</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="comment">// 等价与 public abstract void getDate(String msg);</span></span><br><span class="line">    <span class="comment">//因为是抽象方法，所以不能有方法体。</span></span><br><span class="line"><span class="comment">//	在接口中定义默认方法，需要使用default修饰</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... msgs)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> msg:msgs)  <span class="comment">//看不懂</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	在接口中定义默认方法，需要使用default修饰</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;默认的test()方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	在接口中定义类方法，需要使用static修饰</span></span><br><span class="line">	<span class="keyword">static</span> String <span class="title function_">staticTest</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;接口里的类方法&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义私有方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;foo私有方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义私有静态方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bar私有静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​	接口里定义默认方法（实例方法）使用 public default修饰。由于不能使用static,所以不能直接使用接口来调用默认方法，需要使用接口的实现类的实例来调用这些默认方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> yeeku;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutoutFieldTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		访问另一个包中的Output接口的常量</span></span><br><span class="line">		System.out.println(lee.Output.MAX_CACHE_LINE);</span><br><span class="line"><span class="comment">//		下面编译将引发“为final变量赋值”编译异常</span></span><br><span class="line"><span class="comment">//		lee.Output.MAX_CACHE_LINE = 20;</span></span><br><span class="line"><span class="comment">//		使用接口调用类方法</span></span><br><span class="line">		System.out.println(lee.Output.staticTest());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从以上代码中可以看出，两个包之间访问，表名该成员变量时public访问权限的，而且可以通过接口访问成员变量，表名这个成员变量是一个类变量。</p>

        <h3 id="6-6-3接口的继承"   >
          <a href="#6-6-3接口的继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-3接口的继承" class="headerlink" title="6.6.3接口的继承"></a>6.6.3接口的继承</h3>
      <p>&#x3D;&#x3D;接口的继承与类的继承不同的是，接口完全支持多继承，即一个接口可以有多个直接父接口。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;相似的是，子接口继承某个父接口，将会得到父接口里定义的所有抽象方法、常量。&#x3D;&#x3D;</p>
<p>一个接口继承多个父接口时，多个父接口排在extends关键词之后，多个父接口之间以 . 隔开。</p>

        <h5 id="x3D-x3D-以下代码中纯在自己的很多错误-x3D-x3D"   >
          <a href="#x3D-x3D-以下代码中纯在自己的很多错误-x3D-x3D" class="heading-link"><i class="fas fa-link"></i></a><a href="#x3D-x3D-以下代码中纯在自己的很多错误-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;以下代码中纯在自己的很多错误&#x3D;&#x3D;"></a>&#x3D;&#x3D;以下代码中纯在自己的很多错误&#x3D;&#x3D;</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfanceA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义了一个静态变量和抽象方法</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">PROP_A</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//public static final</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span>;<span class="comment">//public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfanceB</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">PROP_B</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testD</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;在接口中定义除抽象方法的其他方法外都需要定义方法体。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceC</span> <span class="keyword">extends</span> <span class="title class_">InterfanceA</span>,InterfanceB</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">PROP_C</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">testC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceExtends</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(InterfaceC.PROP_A);</span><br><span class="line">		System.out.println(InterfaceC.PROP_B);</span><br><span class="line">		System.out.println(InterfaceC.PROP_C);</span><br><span class="line"><span class="comment">//		下面编译将会引起“没有为类型 InterfaceC 定义方法 testD”的错误</span></span><br><span class="line"><span class="comment">//		原因是接口在继承中只继承父类的抽象方法和常量，不继承类方法等···</span></span><br><span class="line"><span class="comment">//		System.out.println(InterfaceC.testD());</span></span><br><span class="line"><span class="comment">//		下面编译将会引起“ 类型 PrintStream 中的方法 println（boolean）对于参数（void）不适用”的错误</span></span><br><span class="line"><span class="comment">//		不能够输出方法，只能够调用方法。</span></span><br><span class="line"><span class="comment">//		System.out.println(InterfanceB.testD());</span></span><br><span class="line">		InterfanceB.testD();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-6-4使用接口"   >
          <a href="#6-6-4使用接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-4使用接口" class="headerlink" title="6.6.4使用接口"></a>6.6.4使用接口</h3>
      <p>接口不能用于创建实例，但接口可以用于声明引用类型变量。当使用接口来声明引用类型变量时，这个引用类型变量必须引用到其他现实类的对象。除此之外，接口的主要用途就是被实现类实现。归纳起来，接口主要有如下用途：</p>
<ul>
<li>定义变量，也可用于强制类型转换。</li>
<li>调用接口中定义的常量。</li>
<li>被其他类实现。</li>
</ul>
<p>一个类可以实现一个或多个接口，继承使用extends关键字，实现则用&#x3D;&#x3D;implements关键字&#x3D;&#x3D;。因为一个类可以实现多个接口，这也就是Java为单继承灵活性不足所做的补充。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类 implements 接口<span class="number">1</span>,接口<span class="number">2</span>···</span><br><span class="line">&#123;</span><br><span class="line">	类体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>实现接口与继承父类相似，一样可以获得所实现接口里定义的常量（成员变量）和方法（抽象方法，私有方法（public default修饰））。</p>
<p>一个类可以继承一个父类，并同时实现多个接口，implements部分必须放在extends部分之后。</p>
<p>一个类实现了一个或多个接口后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</p>
<p>一个类实现一个接口可以看成一个类继承了一个彻底抽象的类。下面看一个实现接口的类：</p>
<p>Printer.java</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">getProduceTime</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Output</span>,Product</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String[] printData </span><br><span class="line">		= <span class="keyword">new</span> <span class="title class_">String</span>[MAX_CACHE_LINE];</span><br><span class="line"><span class="comment">//	用以记录当前需要打印的作业数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">dataNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	实现实现 lee.Output.out()</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		只要还有作业，就继续打印</span></span><br><span class="line">		<span class="keyword">while</span>(dataNum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;打印机打印：&quot;</span> + printData[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//			把作业队列整体前移一位，并将剩下的作业数减1</span></span><br><span class="line">			System.arraycopy(printData,<span class="number">1</span>,</span><br><span class="line">					printData,<span class="number">0</span>,--dataNum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	实现 lee.Output.getDate</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDate</span><span class="params">(String msg)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dataNum &gt;= MAX_CACHE_LINE)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输出队列已满，添加失败。&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			把答应数据添加到队列里，已保存的数据加1</span></span><br><span class="line">			printData[dataNum++] = msg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	实现getProduceTime</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getProduceTime</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">45</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个Printer对象，当成Output使用</span></span><br><span class="line">		<span class="type">Output</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">		o.getDate(<span class="string">&quot;轻量级Java EE企业级应用实战&quot;</span>);</span><br><span class="line">		o.getDate(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		o.out();</span><br><span class="line"><span class="comment">//		调用Output接口中定义的默认方法</span></span><br><span class="line">		o.print(<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;猪八戒&quot;</span>,<span class="string">&quot;白骨精&quot;</span>);</span><br><span class="line">		o.test();</span><br><span class="line"><span class="comment">//		创建一个Printer对象，当成Product使用</span></span><br><span class="line">		<span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">		System.out.println(p.getProduceTime());</span><br><span class="line"><span class="comment">//		所有接口类型的引用变量都可以直接赋给Object类型变量</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Printer对象实现了Output接口和Product接口，因此Printer对象即可直接赋给Output变量，也可直接赋给Product变量。仿佛Printer类既是Output类的子类，也是Product类型子类，这就是Java提供的模拟多继承。</p>
<p>实现接口方法时，必须使用public访问控制修饰符，因为接口里的方法都是public的，而子类（相当于实现类）重写父类方法时访问权限只能更大或者相等，所以实现类实现接口里的方法时只能能使用public修饰。</p>
<p>接口不能显式的继承任何类，但所有接口类型的引用变量都可以直接赋给Object类型的引用变量。所以在上面程序中可以把Product类型的变量直接赋给Object类型变量，这就是利用向上转型实现的，因为编译器知道任何Java对象都必须时Object或其他子类的实例，Product类型的对象也不例外（它必须时Product接口实现类的对象，该实现类肯定时Object的显式或隐式子类）。</p>

        <h3 id="6-6-5接口和抽象类"   >
          <a href="#6-6-5接口和抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-5接口和抽象类" class="headerlink" title="6.6.5接口和抽象类"></a>6.6.5接口和抽象类</h3>
      <p>相似特征：</p>
<ul>
<li>接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>接口：</p>
<p>对于实现者而言</p>
<p>​	接口规定了实现者必须向外提供服务（以方法的形式来提供）</p>
<p>对于调用者而言</p>
<p>​	接口规定了调用者可以调用那些服务，以及如何调用这些服务（就是如何来调用方法）。</p>
<p>​	当一个程序使用接口时，接口是多个模块间的耦合标准。</p>
<p>​	当多个应用程序之间使用接口时，接口是多个程序之间的通信标准。</p>
<p>接口类似于整个程序的总纲，因此不要随意修改接口，一旦接口被改变，导致系统中大部分类都需要重写。</p>
</li>
<li><p>抽象类：</p>
<p>作为系统中多个子类的父类，所体现的是一种模板式设计。·需要进行进一步的完善。</p>
</li>
</ul>
<p>除此之外，<strong>用法</strong>上纯在如下差别：</p>
<p>①接口里只能包含抽象方法、静态方法、私有方法（类方法）和默认方法，不能为普通方法提供实现；抽象类则完全可以包含普通方法。</p>
<p>②接口里之恶能定义静态常量，不能定义普通常量；抽象类里则既可以定义普通成员变量，也可定义静态常量。</p>
<p>③接口里不包含构造器；抽象类里可以包含构造器，但是不可以用来创建对象，而是让其子类去调用构造器来完成属于抽象类的初始化操作。</p>
<p>④接口里不能包含初始化块，抽象类里可以。</p>
<p>⑤一个类最多只能由一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</p>

        <h3 id="6-6-6面向接口编程"   >
          <a href="#6-6-6面向接口编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-6-6面向接口编程" class="headerlink" title="6.6.6面向接口编程"></a>6.6.6面向接口编程</h3>
      <p>​	接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好的降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。</p>
<p>基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。下面介绍两种设计模式来示范面向接口编程的优势。</p>

        <h4 id="1-简单工程模式"   >
          <a href="#1-简单工程模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-简单工程模式" class="headerlink" title="1.简单工程模式"></a>1.简单工程模式</h4>
      <p>有一个场景：假设程序中有个Computer类需要组合一个输出设备，现在又两个选择：直接让Computer类组合一个Printer，或则让Computer类组合一个Output，那么到底哪种好呢。</p>
<p>工厂模式建议让Computer类组合一个Output类型的对象，将Computer类与Printer类完全分离。Computer对象实组合的是Printer对象还是BetterPrinter对象，对Computer完全透明。当Printer对象切换到BetterPrinter对象时，系统完全不受影响。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Output out;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(Output out)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.out = out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义一个模拟获取字符串输入的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyIn</span><span class="params">(String msg)</span></span><br><span class="line">	&#123;</span><br><span class="line">		out.getData(msg);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义一个模拟打印的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		out.out();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>​	上面的Computer类已经完全与Printer类分离，只是与Output接口耦合。Computer不再负责创建Output对象，系统提供一个Output工厂来负责生成Output对象。这个OutputFactory工厂类代码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> Output <span class="title function_">getOutput</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//创建了一个Printer对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">of</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputFactory</span>();</span><br><span class="line">		<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(of.getOutput());</span><br><span class="line">		c.keyIn(<span class="string">&quot;轻量级&quot;</span>);</span><br><span class="line">		c.keyIn(<span class="string">&quot;疯狂&quot;</span>);</span><br><span class="line">		c.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在该OutputFactory类中包含了一个getOutput()方法，该方法返回一个Output实现类的实例，该方法负责创建Output实例，具体创建哪一个实现类的对象由该方法决定（具体由该方法的return new Printer()控制，当然也可以增加更复杂的控制逻辑）。如果系统需要将Printer改为BetterPrinter实现类，只需要让BetterPrinter实现Output接口，并实现OutputFacyory类中的getOutput()方法即可。</p>
<p>下面时BetterPrinter实现类的代码，BetterPrinter只是对原有的Printer进行简单修改，以模拟系统重构后的改进。  </p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lee.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BetterPrinter</span> <span class="keyword">implements</span> <span class="title class_">Output</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String[] printData</span><br><span class="line">		= <span class="keyword">new</span> <span class="title class_">String</span>[MAX_CACHE_LINE * <span class="number">2</span>];</span><br><span class="line"><span class="comment">//	用以记录当前需打印的作业数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">dataNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		只要还有作业，就继续打印</span></span><br><span class="line">		<span class="keyword">while</span> (dataNum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;高速打印机正在打印：&quot;</span> + printData[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//			把作业队列整体前移一位，并将剩下的作业数减1</span></span><br><span class="line">			System.arraycopy(printData, <span class="number">1</span>, printData, <span class="number">0</span>, --dataNum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(String msg)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dataNum &gt;= MAX_CACHE_LINE * <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输出队列已满，添加失败&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			把打印数据添加到队列里，已保存数据的数量加1</span></span><br><span class="line">			printData[dataNum++] = msg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的BetterPrinter类也实现了Output接口，因此也可当成Output接口来使用，于是只要把OutputFactory工厂类的getOutput()方法中粗体部分改为如下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BetterPrinter</span>();</span><br></pre></td></tr></table></div></figure>

<p>再次运行OutputFactory.java，**发现系统运行时已经改为BetterPrinter对象,**而不再是原来的Printer对象。</p>
<p>通过这种方法，即可把所有生成的Output对象的逻辑集中在OutputFactory工厂类模式中管理，而所有需要使用Output对象的类只需要与Output接口耦合，而不是具体的实现类耦合。即使系统中有很多类使用了Printer对象，只要OutputFactory类的getOutput()方法生成的Output对象是BetterPrinter对象，则它们全部可以改为这个对象，而所有程序无需修改，只需要修改工厂类的getOutput方法实现即可。</p>

        <h4 id="2-命令模式"   >
          <a href="#2-命令模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-命令模式" class="headerlink" title="2.命令模式"></a>2.命令模式</h4>
      <p> 一个场景：某个方法需要完成某一个行为，但这个行为的具体实现无法确定，必须等到执行改方法时才可以确定。具体点：假设有个方法需要遍历某个数组的数组元素，但无法确定在遍历数组元素时如何处理这些元素，需要在调用该方法时指定具体的某个行为。</p>
<p>对于这样一个需求，必须把“处理行为”作为参数传入该方法，这个“处理行为”用编程来实现就是一段代码可以考虑使用一个Command接口来定义一个方法，用这个方法来封装“处理行为”。下面是该接口的代码。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	接口里定义的process方法用于封装“处理行为”</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>定义了一个process()方法，这个方法用于封装“处理行为”，但这个方法没有方法体——因为现在还无法确定这个处理行为。</p>
<p>下面是需要处理数组的处理类，在这个处理类中包含一个process()方法，这个方法无法确定处理数组的处理行为，所以定义该方法时使用了一个Command参数，这个Command参数负责对数组的处理行为。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessArray</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] target,Command cmd)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> t:target)  <span class="comment">//多态</span></span><br><span class="line">		&#123;</span><br><span class="line">			cmd.process(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过一个Command接口，就实现了让ProcessArray类和具体“处理行为”分离，程序使用Command接口代表了对数组元素的处理行为。Command接口也没有提供真正的处理，只有等到需要调用ProcessArray对象的process()方法时，才真正传入一个Command对象，才正在确定对数组的处理行为。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">		<span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//		第一次处理数组，具体处理行为取决于PrintCommand</span></span><br><span class="line">		pa.process(target, <span class="keyword">new</span> <span class="title class_">PrintCommand</span>());</span><br><span class="line">		System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">		pa.process(target, <span class="keyword">new</span> <span class="title class_">SquareCommand</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;迭代输出目标数组的元素&quot;</span>+element);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SquareCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span>+element * element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="6-7-内部类"   >
          <a href="#6-7-内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-内部类" class="headerlink" title="6.7 内部类"></a>6.7 内部类</h2>
      <p>大部分的时候，类被定义成一个独立的程序单元，在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就称作内部类（有的地方叫嵌套类），包含内部类的类也被称为外部类（有的地方也叫宿主类）。有以下作用：</p>
<ul>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li>
<li>内部类成员可以直接访问外部类的私有数据，因为内部类被当成外部类成员，同一个类的成员之间可以互相访问，但外部类不能访问内部类的实现细节，例如内部类的成员变量。</li>
<li>匿名内部类适合创建仅需要创建一次使用的类。</li>
</ul>
<p>内部类除需要定义在其他类里面还存在两点不同：</p>
<ul>
<li>内部类可以比外部类多三个修饰符private,protected,static——外部类不可以使用这三个修饰符。</li>
<li>非静态内部类不能拥有静态对象。</li>
</ul>

        <h3 id="6-7-1非静态内部类"   >
          <a href="#6-7-1非静态内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-1非静态内部类" class="headerlink" title="6.7.1非静态内部类"></a>6.7.1非静态内部类</h3>
      <p>大部分的时候，内部类都可以被当作成员内部类定义，而不是作为局部内部类。成员内部类是一种与成员变量、方法、构造器和初始化块相似的类成员；既不内部类和匿名内部类则不是类成员。</p>
<p>成员内部类分为：静态内部类和非静态内部类，内部类一定是放在另一个类的类体部分定义。  </p>
<p>下面程序在Cow类中创建了CowLeg非静态内部类，并在CowLeg类的实例方法中直接访问Cow的private访问权限下的实例方法，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cow</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"><span class="comment">//	外部类的两个重载的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cow</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Cow</span><span class="params">(<span class="type">double</span> weight)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	定义一个非静态内部类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CowLeg</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		非静态内部类的两个实例变量</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">double</span> lenght;</span><br><span class="line">		<span class="keyword">private</span> String color;</span><br><span class="line"><span class="comment">//		非静态内部类的两个重载构造器</span></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">CowLeg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">CowLeg</span><span class="params">(<span class="type">double</span> lenght,String color)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.lenght = lenght;</span><br><span class="line">			<span class="built_in">this</span>.color = color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLenght</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> lenght;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLenght</span><span class="params">(<span class="type">double</span> lenght)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.lenght = lenght;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.color = color;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;当前牛腿的颜色是：&quot;</span></span><br><span class="line">					+color + <span class="string">&quot;高：&quot;</span>+lenght);</span><br><span class="line">			System.out.println(<span class="string">&quot;本牛腿所在奶牛重：&quot;</span>+weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CowLeg</span>(<span class="number">1.12</span>,<span class="string">&quot;黑白相间&quot;</span>);</span><br><span class="line">		c1.info();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cow</span>(<span class="number">378.9</span>);</span><br><span class="line">		c2.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>生成两个class文件，内部类的class文件总是以OutClass$InnerClass.class。</p>
<p>在非静态内部类里可以直接访问外部类的private成员，System.out.println(“本牛腿所在奶牛重：”+weight);这行代码就是内部类直接访问外部类的private成员，这是因为在非静态内部类对象里，保存了一个他所寄生的外部类对象的引用（当调用非静态内部类的实例方法时（info()）,必须有一个非静态内部类实例（c1）非静态内部类实例必须寄生在外部类实例里）。</p>
<p>当非静态内部类的方法访问某个变量时，系统优先在该方法内寻找是否存在该名字的局部变量，如果存在就使用该变量，如果不存在就在该方法存在的内部类里查找是否存在该名字的成员变量，如果存在就使用不存在就在该内部类所在的外部类里查找是否存在该名字的成员变量，如果存在就使用，不存在系统将出现编译错误，提示找不到该变量。</p>
<p>因此，如果外部类成员变量、内部类成员变量与内部类里方法的局部变量同名，则可以通过外部类类名.this、this来限定区分。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscernVariable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="string">&quot;外部类的实例变量&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inclass</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">String</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="string">&quot;内部类的实例变量&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">porp</span> <span class="operator">=</span> <span class="string">&quot;局部变量&quot;</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;外部类的实例变量值：&quot;</span></span><br><span class="line">					+DiscernVariable.<span class="built_in">this</span>.prop);</span><br><span class="line">			System.out.println(<span class="string">&quot;内部类的实例变量值：&quot;</span></span><br><span class="line">					+<span class="built_in">this</span>.prop);</span><br><span class="line">			System.out.println(<span class="string">&quot;局部变量的值：&quot;</span></span><br><span class="line">					+porp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inclass</span>();</span><br><span class="line">		in.info();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">DiscernVariable</span>().test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>非静态的内部类成员可以访问外部类的实例成员，但反过来就不成立了。如果外部类需要访问非静态内部类的实例成员，则必须显式创建非静态内部类对象来调用访问其他实例成员。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">OutProp</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">inPror</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessOuterPerp</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			非静态内部类可以直接访问外部类的private实例变量</span></span><br><span class="line">			System.out.println(<span class="string">&quot;外部类的OutPror值&quot;</span></span><br><span class="line">					+OutProp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessInnerPerp</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		外部类不可以直接访问内部类的实例变量</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;内部类的inProp值：&quot;</span></span><br><span class="line"><span class="comment">//				+inProp);</span></span><br><span class="line"><span class="comment">//		必须创建显式内部类的对象来访问内部类的成员变量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;内部类的inProp值：&quot;</span></span><br><span class="line">				+ <span class="keyword">new</span> <span class="title class_">Inner</span>().inPror);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		执行下面代码只会创建外部类对象，还未创建内部类对象</span></span><br><span class="line">		<span class="type">Outer</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(); <span class="comment">//①</span></span><br><span class="line">		o1.accessInnerPerp();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>外部类不允许访问非静态内部类的实例成员的原因是，上面①号段代码创建了一个外部类对象，并调用外部类对象的accessInnerProp()方法，此时非静态内部类对象更不不存在，如果允许accessInnerProp()方法访问非静态内部类的实例成员，将肯定引起错误。</p>
<p>非静态内部类和外部类的关系：</p>
<p><strong>非静态内部类必须寄生在外部类对象里，而外部类对象则不必一定有非静态内部类对象寄生其中。简单的来说，如果存在一个非静态内部类对象，则一定存在一个被它寄生得外部类对象。但外部类对象存在时，外部类对象里不一定寄生了非静态内部类对象。因此外部类对象访问非静态内部类成员时，可能非静态普通内部类对象根本不存在！而非静态内部类对象访问外部类成员时，外部类对象一定存在。</strong></p>
<p>根据静态成员不能访问非静态成员的规则，外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量，创建实例等。总之，不允许在外部类的静态成员变量中直接用非静态内部类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个非静态的内部类，是一个空类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">In</span>&#123;&#125;</span><br><span class="line"><span class="comment">//	外部类的静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		下面代码引发编译异常，因为静态成员（main（）方法）</span></span><br><span class="line"><span class="comment">//		无法访问非静态成员（in类）</span></span><br><span class="line"><span class="comment">//		new In();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Java不允许在非静态内部类里定义静态成员，非静态内部类里不能有静态方法、静态成员变量、静态初始化块，所以上面三个静态声明都会引发错误。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerNoStatic</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 下面三个静态声明都将引发如下编译错误</span></span><br><span class="line"><span class="comment">		 * 非静态内部类不能有静态声明</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">//		static</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;========&quot;);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		private static int inProp;</span></span><br><span class="line"><span class="comment">//		private static void test() &#123;&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>非静态内部类里不可以有静态初始化块，但可以包含普通初始化块。非静态内部类普通初始化块的作用与外部初始化块的作用完全相同。</p>

        <h3 id="6-7-2静态内部类"   >
          <a href="#6-7-2静态内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-2静态内部类" class="headerlink" title="6.7.2静态内部类"></a>6.7.2静态内部类</h3>
      <p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为类内部类（静态内部类）。</p>
<p> static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员变量属于整个类而不属于单个对象。外部类的上一级程序单元是包，所以不能使用static修饰，内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部实例相关，因此static关键字不能修饰外部类，但可以修饰内部类。</p>
<p>静态内部类可以包含静态成员，也可以包含非静态成员。根据静态成员不能访问非静态成员的规则，静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">prop1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">prop2</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		静态内部类里可以包含静态成员</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;<span class="comment">//①</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">accessOutProp</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="comment">//			静态内部类无法访问外部类的实例变量</span></span><br><span class="line"><span class="comment">//			System.out.println(prop1);</span></span><br><span class="line">			System.out.println(prop2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>①中定义了一个静态成员变量 ，因为这个静态成员变量处于静态内部类中，所以完全没有问题。StaticInnerClass类中定义了一个accessOutProp()方法，这是一个实例方法，但依然不能访问外部类的prop1成员变量，但可以访问prop2成员变量，因为它是静态成员变量。</p>
<p>静态内部类的实例方法不能访问外部类的实例属性，因为静态内部类是与外部类相关的，而不是外部类对象相关的，也就是说，静态内部类对象不是寄生在外部类的实例中，而是寄生在外部类的类本身中。当静态内部类对象存在时，并不存在一个被它寄生的外部类对象，静态内部类对象只持有外部类引用，没有持有外部类对象的引用。如果允许静态内部类的实例方法访问外部类的实例成员，但找不到被寄生的外部类对象，这将引起错误。以下代码帮助理解。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Help</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>  <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> wight;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yea</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		不能对非静态字段 age 进行静态引用</span></span><br><span class="line"><span class="comment">//		age = 10;</span></span><br><span class="line">		wight = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-7-3使用内部类"   >
          <a href="#6-7-3使用内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-3使用内部类" class="headerlink" title="6.7.3使用内部类"></a>6.7.3使用内部类</h3>
      <p>1.在外部类内部使用内部类</p>
<p>2.在外部类以外使用非静态内部类</p>
<p>示范了如何在外部类以外的地方创建非静态内部类的对象，并把它赋给非静态内部类类型</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何在外部类以外的地方创建非静态内部类的对象，并把它赋给非静态内部类类型变量。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Out</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个内部类，不使用访问控制符</span></span><br><span class="line"><span class="comment">//	即只有同一个包中的其他类可访问该内部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">In</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">In</span><span class="params">(String msg)</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateInnerInstance</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//非静态内部类的构造器必须使用外部类对象来调用</span></span><br><span class="line">		Out.<span class="type">In</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Out</span>().<span class="keyword">new</span> <span class="title class_">In</span>(<span class="string">&quot;测试信息&quot;</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 上面的代码可改为如下三行代码</span></span><br><span class="line"><span class="comment">		 * 使用OuterClass.InnerClass的形式定义内部类变量</span></span><br><span class="line"><span class="comment">		 * Out.In in;  //调用内部类构造器</span></span><br><span class="line"><span class="comment">		 * 创建外部类实例,非静态内部类实例将寄生在该实例中</span></span><br><span class="line"><span class="comment">		 * Out out = new Out();</span></span><br><span class="line"><span class="comment">		 * 通过外部类实例和new来调用内部类构造器创建非静态实例</span></span><br><span class="line"><span class="comment">		 * in = out.new In(&quot;测试信息&quot;)；</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果需要在外部类以外的地方创建非静态内部类的子类，尤其要注意上面的规则：非静态内部类的构造器必须通过其外部类对象来调用。</p>
<p>当创建一个子类时，子类构造器总会调用父类构造器，因此在创建非静态内部类的子类时，必须保证让子类构造器可以调用非静态内部类的构造器，调用非静态内部类的构造器时，必须存在一个外部类对象。下面定义了一个子类继承了Out类的非静态内部类In类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">Out</span>.In</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(Out out)</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//		调用父类构造器</span></span><br><span class="line">		out.<span class="built_in">super</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>非静态内部类In类的构造器必须使用外部类对象来调用,代码中super代表调用In类的构造器,而out代表外部类对象.</p>
<p>如果需要创建一个SubClass对象,就必须创建一个Out对象.因为SubClass是非静态内部类In的子类,非静态内部类In对象里必须有一个对Out对象的引用,其子类SubClass对象里也应该持有对Out对象的引用.当创建SubClass对象是传给该构造器的Out对象,就是SubClass里Out对象引用所指向的对象.</p>
<p>3.在外部类以外使用静态内部类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">OuterClass</span>.InnerConstructor()</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticOut</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	定义一个静态内部类，不使用访问控制符</span></span><br><span class="line"><span class="comment">//	即同一个包中的其他类可访问该内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticIn</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">StaticIn</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;静态内部类的构造器。&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateStaticlnnerlnstance</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		StaticOut.<span class="type">StaticIn</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticOut</span>.StaticIn();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * StaticOut.StaticIn in</span></span><br><span class="line"><span class="comment">		 * in = new StaticOut.StaticIn();</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>创建内部类对象时,静态内部类只需要外部类即可调用构造器,而非静态类必须使用外部类对象来调用构造器。</strong></p>
<p>因为调用静态内部类的构造器时,无需使用外部类对象,所以创建静态内部类的子类也比较简单,下面代码就为静态内部类StaticIn类定义了一个空的子类。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticSubClass</span> <span class="keyword">extends</span> <span class="title class_">StaticOut</span>.StaticIn&#123;&#125; </span><br></pre></td></tr></table></div></figure>

<p>当定义一个静态内部类时,其外部类非常像一个包空间。</p>
<p>使用静态内部类比使用非静态内部类要简单，只要把外部类当成静态内部类的包空间即可，所以，当程序需要使用内部类时，应该&#x3D;&#x3D;优先考虑静态内部类&#x3D;&#x3D;。</p>
<p>内部类的类名不再是简单的内部类的类名构成，它实际上还把外部类的类名作为一个命名空间，作为内部类类名的限制。因此子类中的内部类和父类中的内部类不可能完全同名，即使二者所包含的内部类类名相同，但因为它们所处的外部类空间不同，所以它们不可能完全同名，也就不可能重写。</p>

        <h3 id="6-7-4-局部内部类"   >
          <a href="#6-7-4-局部内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-4-局部内部类" class="headerlink" title="6.7.4 局部内部类"></a>6.7.4 局部内部类</h3>
      <p>把一个内部类放在一个方法里定义，那么这个内部类就是一个局部内部类，局部内部类仅在该方法里有效。</p>
<p><strong>所有的局部变量都不能使用局部控制符。</strong></p>
<p>如果使用局部内部类定义变量、创建实例或派生子类，那么只能在局部内部类所在的方法内进行。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocallnnerClass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		定义局部内部类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">InnerBase</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> a;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		定义局部内部类子类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">InnerSub</span> <span class="keyword">extends</span> <span class="title class_">InnerBase</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> b;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		创建局部内部类的对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerSub</span>();</span><br><span class="line">		is.a = <span class="number">5</span>;</span><br><span class="line">		is.b = <span class="number">7</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;InnerSub对象的a和b实例变量是&quot;</span></span><br><span class="line">				+is.a+<span class="string">&quot;,&quot;</span>+is.b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译上面程序，会生成三个class文件LocallnnerClass$1InnerBase.class,	LocallnnerClass$1InnerSub.class,	LocallnnerClass.class。这表明内部类class文件总是遵循如下命名规则OutClass$NInnerClass.class。注意文件名比成员内部类的class文件多了有一个数字，这是因为同一个类里不可能有两个同名的成员内部类，而同一个类里则可能有两个以上同名的局部内部类（处于不同的方法中），所有增加了一个数字进行区分。</p>
<p>开发中很少用局部内部类</p>

        <h3 id="6-7-5-匿名内部类"   >
          <a href="#6-7-5-匿名内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-7-5-匿名内部类" class="headerlink" title="6.7.5 匿名内部类"></a>6.7.5 匿名内部类</h3>
      <p>匿名内部类适合创建那种只需要一次使用的类，例如前面介绍的命令模式所需要的Command对象，匿名内部类的语法有点奇怪，创建匿名内部类时会创建一个该类的实例，这个类定义立即消失，匿名内部类不能重复使用。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 实现接口() | 父类构造器(实参列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//匿名内部类的类题部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上面定义可以看出，匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口，还有两个规则如下：</p>
<ul>
<li>匿名内部类不能是抽象类，因为系统在创建匿名内部类时，会立即创建匿名内部类的对象。因此不允许匿名内部类定义成抽象类。</li>
<li>匿名内部类不能定义构造器。由于匿名内部类没有类名，所以无法定义构造器，但匿名内部类可以定义初始化块，可以通过实例初始化块来完成构造器需要完成的事情。</li>
</ul>
<blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">	String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Product p)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span> + p.getName()</span><br><span class="line">				+ <span class="string">&quot;,&quot;</span> + p.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousTest</span>();</span><br><span class="line"><span class="comment">//		调用test()方法时，需要传入一个Product参数</span></span><br><span class="line"><span class="comment">//		此处传入其匿名实现类的实例</span></span><br><span class="line">		ta.test(<span class="keyword">new</span> <span class="title class_">Product</span>()</span><br><span class="line">				&#123;<span class="comment">//匿名内部类类体部分</span></span><br><span class="line">					<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> </span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">567.8</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="string">&quot;AGP显卡&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;<span class="comment">//匿名内部类类体部分);</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                匿名内部类类体部分可分解为</span></span><br><span class="line"><span class="comment">                class AnounymousProduct implements Product</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                	public double getPrice() </span></span><br><span class="line"><span class="comment">					&#123;</span></span><br><span class="line"><span class="comment">						return 567.8;</span></span><br><span class="line"><span class="comment">					&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">					public String getName()</span></span><br><span class="line"><span class="comment">					&#123;</span></span><br><span class="line"><span class="comment">						return &quot;AGP显卡&quot;;</span></span><br><span class="line"><span class="comment">					&#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ta.test(new AnounymousProduct());</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</blockquote>
<p>上面程序中AnonymousTest类定义了一个test()方法，该方法需要一个Product对象作为参数，但Product只是一个接口，无法直接创建对象，因此此处考虑创建一个Product接口实现类的对象传入该方法——如果这个Pruduct接口实现类需要重复使用，则应该将该实现类定义成一个独立类；如果这个Product接口实现类只需一次使用，则可采用上面程序中的方式，定义一个匿名内部类。</p>
<p>正如上面程序所看到的，定义匿名内部类无需class关键字，而是在定义匿名内部类时直接生成该匿名内部类的对象。上面标注中为匿名内部类类体部分。</p>
<p>由于匿名内部类不能是抽象类，所以匿名内部类必须实现它的抽象父类或者接口里包含的所有抽象方法。</p>
<p>当通过实现接口来创建匿名内部类时，匿名内部类不能显式地定义构造器，因此匿名内部类只有一个隐式的无参数构造器，故new接口名后的括号里不能传入参数值。</p>
<p>但如果通过继承父类来创建匿名内部类时，匿名内部类将拥有和父类相似的构造器，此处的相似指的是拥有相同的形参列表。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Device</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Device</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Device</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInner</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Device d)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span> + d.getName()</span><br><span class="line">		+ <span class="string">&quot;,&quot;</span> + d.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">ai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnonymousInner</span>();</span><br><span class="line"><span class="comment">//		调用有参数的构造器创建Device匿名实现类的对象</span></span><br><span class="line">		ai.test(<span class="keyword">new</span> <span class="title class_">Device</span>(<span class="string">&quot;电子示波器&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">67.8</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line"><span class="comment">//		调用无参数的构造器创建Device匿名实现类的对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Device</span>()</span><br><span class="line">				&#123;</span><br><span class="line"><span class="comment">//					初始化块</span></span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;匿名内部类的初始化块。。。&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line"><span class="comment">//					实现抽象方法</span></span><br><span class="line">					<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">56.2</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="string">&quot;键盘&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				ai.test(d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>创建了一个抽象父类Decice类，包含两个构造器，一个无参，一个有参，当以Device为父类的匿名内部类时，既可以传入参数（代表调用父类带参数的构造器），也可以不传入参数。（代表调用父类不带参数的构造器）。</p>
<p>当创建匿名内部类时，必须实现接口或抽象父类里的所有抽象方法。如果有需要，也可以重写父类中的普通方法，其中getName()方法并不是抽象方法。</p>
<p><strong>如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 由于局部变量age被匿名内部类访问了，所以age将自动加上final修饰，所以不可修改age的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">//		age = 2;</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//						从Java 8以前下面语句将提示错误：age必须使用final修饰</span></span><br><span class="line"><span class="comment">//						从Java 8开始，匿名内部类、局部内部类允许访问非final的局部变量</span></span><br><span class="line">						System.out.println(age);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				a.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="6-8-Java-11增强的Lambda表达式"   >
          <a href="#6-8-Java-11增强的Lambda表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-8-Java-11增强的Lambda表达式" class="headerlink" title="6.8 Java 11增强的Lambda表达式"></a>6.8 Java 11增强的Lambda表达式</h2>
      <p>Lambda支持将代码块作为方法参数，Lambda表达式允许更简洁的代码来创建只有一个抽象方法的接口（这种接口被称为函数式接口）的实例。</p>

        <h3 id="6-8-1-Lambda表达式入门"   >
          <a href="#6-8-1-Lambda表达式入门" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-8-1-Lambda表达式入门" class="headerlink" title="6.8.1 Lambda表达式入门"></a>6.8.1 Lambda表达式入门</h3>
      <p>下面使用匿名内部类来改写command表达式的例子。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest1</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">		<span class="type">int</span>[] target = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//		处理数组，具体处理行为取决于匿名内部类</span></span><br><span class="line">		pa.process(target,<span class="keyword">new</span> <span class="title class_">Command</span>()</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> element)</span>  <span class="comment">//粗体字开始</span></span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span> + element * element);</span><br><span class="line">					&#125;	<span class="comment">//粗体字结束</span></span><br><span class="line">				&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>前面已经提到，processArray类的process()方法处理数组时，希望可以动态传入一段代码作为具体的处理行为，因此程序创建一个匿名内部类实例来封装处理行为。从上面代码可以看出，用于封装处理行为的关键就是实现程序中的粗体字方法。但是为了向process()方法传入这段粗体字代码，程序不得不使用匿名内部类的语法来创建对象。</p>
<p>Lambda表达式完全可以用于简化创建匿名内部类对象，如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">		<span class="type">int</span>[] array = &#123;<span class="number">3</span>,-<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//		处理数组，具体处理行为取决于匿名内部类</span></span><br><span class="line">		pa.process(array,(<span class="type">int</span> element)-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span> + element * element);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> element)-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组元素的平方是：&quot;</span> + element * element);</span><br></pre></td></tr></table></div></figure>

<p>这段代码中与创建匿名内部类时需要实现的process(int element)方法完全相同，只是不需要new Xxx(){}这种繁琐的代码，不需要指出重写的方法名字，也不需要给出重写的方法的返回值类型——只要给出重写的方法括号以及括号里的形参列表即可。</p>
<p>Lambda表达式的主要作用就是代替匿名内部类的繁琐语句。由</p>
<ul>
<li>形参列表：允许省略形参类型</li>
<li>箭头(-&gt;)</li>
<li>代码块：Lambda表达式需要返回值，而他的代码块中仅有一条省略了return的语句，Lambda表达式会自动返回这条语句的值。</li>
</ul>
<p>下面程序师范了Lambda表达式的几种简化写法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">taste</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span></span><br><span class="line">&#123;</span><br><span class="line">	String <span class="title function_">fly</span><span class="params">(String weather,String tool)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Addable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaQs</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	调用该方法需要Eatable对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Eatable a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		a.taste();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Flyable b)</span></span><br><span class="line">	&#123;</span><br><span class="line">		b.fly(<span class="string">&quot;【碧空如洗的晴天】&quot;</span>,<span class="string">&quot;【直升机】&quot;</span>);</span><br><span class="line"><span class="comment">//		System.out.println(&quot;我正在驾驶&quot; + b);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Addable add)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;5和3的和为：&quot;</span> + add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">lp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaQs</span>();</span><br><span class="line"><span class="comment">//		lp.eat(()-&gt;System.out.println(&quot;苹果的味道很不错&quot;));</span></span><br><span class="line"><span class="comment">////		lp.drive((String weather,String tool)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;今天的天气是：&quot; + weather);</span></span><br><span class="line"><span class="comment">//			System.out.println(&quot;直升机稳定飞行&quot;+tool);</span></span><br><span class="line"><span class="comment">//		&#125;);</span></span><br><span class="line"><span class="comment">//		lp.test((a,b)-&gt;a+b);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>此段代码书中会因为两个变量未赋值而出现乱码，上面代码是自己修改后的，但是还是不会改，后期改进。</strong></p>
<p>上面程序中的第一段粗体字代码使用Lambda表达式相当于不带形参的匿名方法由于该Lambda表达式的代码块只有一行代码，因此可以省略代码块的花括号；后两段同理。</p>
<p>第一段粗体字代码中调用了eat()方法，调用该方法需要一个Eatable类型的参数，但实际上传入的是Lambda表达式，后两段同理，但上面的程序可以正常变异，运行，这说明Lambda表达式实际上将会被当做“任意类型”的对象，到底需要当成何种类型的对象，这取决于运行环境的需要，下面详细介绍。</p>

        <h3 id="6-8-2-Lambda表达式与函数式接口"   >
          <a href="#6-8-2-Lambda表达式与函数式接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-8-2-Lambda表达式与函数式接口" class="headerlink" title="6.8.2 Lambda表达式与函数式接口"></a>6.8.2 Lambda表达式与函数式接口</h3>
      <p>Lambda表达式的类型，也被称为“目标类型（targert type）”，Lambda表达式的目标类型必须是“函数式接口(functional interface)”。函数式接口代表只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但只能声明一个抽象方法。</p>
<p>如果采用匿名内部类语法来创建函数式接口实例，则只需要实现一个抽象方法，在这种情况下，可采用Lambda表达式来创建对象，该表达式创建出来的对象的目标类型就是这个函数式接口。</p>
<p>由于Lambda表达式的接口就是被当成对象，因此程序中完全客户以使用Lambda表达式进行赋值</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//		Runnable 接口中只包含一个无参数的方法，</span></span><br><span class="line"><span class="comment">//		Lambda 表达式代表的匿名方法实现了Runnable 接口中唯一的、无参数的方法</span></span><br><span class="line"><span class="comment">//		因此下面的Lambda表达式创建了一个Runnable 对象</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Runnable是Java本身提供的一个函数式接口。</p>
<p>从上面代码可以看出，Lambda实现的是匿名方法——因此他只能实现特定函数式接口中的唯一方法。这意味着Lambda表达式有如下两个特性：</p>
<ul>
<li>Lambda表达式的目标类型必须是明确的函数式接口。</li>
<li>Lambda表达式只能为函数式接口创建对象。Lambda表达式只能实现一个方法，因此它只能为只有一个抽象方法的接口（函数式接口）创建对象。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></div></figure>

<p>上面的代码与前一段代码几乎完全相同，只是此时程序将Lambda表达式不在赋值给Runnable变量，而是直接复制给Object变量。编译上面代码，会报错（不兼容的类型：Object不是函数接口）。</p>
<p>从该错误可以看出，Lambda表达式的目标类型必须是明确的函数式接口。尚敏代码将Lambda表达式赋给Object变量，编译器只能确定该Lambda表达式的类型为Object，而Object并不是函数式接口，因此会报错。</p>
<p><strong>P220以后的Lambd内容暂时省略。（学不下去了）</strong></p>

        <h2 id="6-9-枚举类"   >
          <a href="#6-9-枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-枚举类" class="headerlink" title="6.9 枚举类"></a>6.9 枚举类</h2>
      <p>在某些情况下，一个类的对象是有限而且固定的，比如季节类，他只有4个对象；再比如行星类，目前只有8个对象。这种&#x3D;&#x3D;实例有限而且固定的类，在Java里被称为枚举类。&#x3D;&#x3D;</p>

        <h3 id="6-9-1-手动实现枚举类"   >
          <a href="#6-9-1-手动实现枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-1-手动实现枚举类" class="headerlink" title="6.9.1 手动实现枚举类"></a>6.9.1 手动实现枚举类</h3>
      <p>在早期代码中，可能会直接使用简单的静态常量来表示枚举，例如以下代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_SPRING</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_SUMMER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_FALL</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_WINTER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-9-2-枚举类入门"   >
          <a href="#6-9-2-枚举类入门" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-2-枚举类入门" class="headerlink" title="6.9.2 枚举类入门"></a>6.9.2 枚举类入门</h3>
      <p>Java 5新增了一个 enum 关键字（他与class interface关键字的地位相同），用以定义枚举类，枚举类是一种特殊的类，他一样可以有自己的成员变量，方法，可以实现一个或多个接口，也可以定义自己的构造器。一个Java源文件中最多只能定义一个public访问权限的枚举类，而且该Java源文件也必须与该枚举类的类名。</p>
<p>但枚举类终究不是普通类，他与普通类有如下区别</p>
<ul>
<li>枚举类可以实现一个或多个接口，使用enum定义的枚举默认继承了java.lang.Enum类，而不是默认继承了Object类，因此枚举类不能显式继承其他父类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang.Comparable两个接口。</li>
<li>使用enum定义、非抽象的枚举类默认会使用final修饰。</li>
<li>枚举类的构造器只能使用private访问控制符，如果省略了构造器的访问控制符，则默认使用private修饰；如果强制指定访问控制符，则只能指定private修饰符。由于枚举类的所有构造器都是private的，而子类构造器总要调用父类一次，因此枚举类不能派生子类。</li>
<li>枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远不能派生实例。列出这些实例时，系统会自动添加public static final修饰，无须程序员显式添加。</li>
</ul>
<p>枚举类默认提供了一个values()方法，该方法可以很方便的遍历所有的枚举值。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line"><span class="comment">//在第一行列出4个枚举实例</span></span><br><span class="line">	SPRING,SUMMER,FALL,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这些枚举值代表了该枚举类的所有可能的实例。</p>
<p>如果需要使用该枚举类的某个实例，则可以使用EnumClass.variable的形式。如SeasonEnum.SPRING。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">judge</span><span class="params">(SeasonEnum s)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		switch语句里的表达式可以是枚举值</span></span><br><span class="line">		<span class="keyword">switch</span>(s)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> SPRING:</span><br><span class="line">			System.out.println(<span class="string">&quot;春暖花开。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SUMMER:</span><br><span class="line">			System.out.println(<span class="string">&quot;夏日炎炎。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FALL:</span><br><span class="line">			System.out.println(<span class="string">&quot;秋风瑟瑟。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WINTER:</span><br><span class="line">			System.out.println(<span class="string">&quot;冬日雪飘。&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		枚举类默认有一个values()方法，返回该枚举值的所有实例</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> s : SeasonEnum.values())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		使用枚举实例时，可以通过EnumClass.variable形式来访问。</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">EnumTest</span>().judge(SeasonEnum.SPRING);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>switch的控制表达式可以是任何枚举类型。而且case表达式中的值直接使用枚举值的名字，无须添加枚举类进行限定。</p>
<p>下面是java.lang.Enum类中所包含的方法：</p>
<p>![](C:\Program Files\Typora\image\0ee5804edadb22c1bba5195a057dc5a.jpg)</p>
<p>![](C:\Program Files\Typora\image\825b1552f2d3b10d4e1cbe892dbd550.jpg)</p>

        <h3 id="6-9-3-枚举类的成员变量、方法和构造器"   >
          <a href="#6-9-3-枚举类的成员变量、方法和构造器" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-3-枚举类的成员变量、方法和构造器" class="headerlink" title="6.9.3 枚举类的成员变量、方法和构造器"></a>6.9.3 枚举类的成员变量、方法和构造器</h3>
      <p>枚举类也是一种类，只是它是一种比较特殊的类，因此他一样可以定义成员变量、方法和构造器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> </span><br><span class="line">&#123;</span><br><span class="line">	MALE,FEMALE;  <span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//	定义一个public修饰的实例变量</span></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		通过Enum的valueof()方法来获取指定枚举类的枚举值</span></span><br><span class="line">		<span class="type">Gender</span> <span class="variable">g</span> <span class="operator">=</span> Enum.valueOf(Gender.class, <span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line"><span class="comment">//		直接为枚举值的name实例变量赋值</span></span><br><span class="line">		g.name = <span class="string">&quot;女&quot;</span>;</span><br><span class="line"><span class="comment">//		直接访问枚举值的name实例变量</span></span><br><span class="line">		System.out.println(g + <span class="string">&quot;代表：&quot;</span> + g.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序使用Gender枚举类时与使用一个普通类没有太大的差别，差别只是产生Gender对象的方式不同，枚举类的实例只能是枚举类，而不是随意地通过new来创建枚举类对象。</p>
<p>正如前面所提到的，Java应该把所有类设计成良好的封装的类，所以不应该允许直接访问Gender类的name成员变量，而是应该通过方法来控制对name的访问。否则可能出现很混乱的情形，例如上面程序恰好设置了g.name&#x3D;”女”,要是采用g.name&#x3D;”男”，那程序就会非常混乱了，可能出现FEMALE代表男的局面了，下面做出了改进：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GenderBetter</span> </span><br><span class="line">&#123;</span><br><span class="line">	MALE,FEMALE;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(<span class="built_in">this</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> MALE:</span><br><span class="line">			<span class="keyword">if</span>(name.equals(<span class="string">&quot;男&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">this</span>.name = name;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> FEMALE:</span><br><span class="line">			<span class="keyword">if</span>(name.equals(<span class="string">&quot;女&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">this</span>.name = name;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序吧name设置成private，从而避免了其他程序直接访问该name成员变量，必须通过setName()方法来修改Getder实例的name变量，而setName()方法就可以保证不会产生混乱。上面程序中粗体字部分保证FEMALE枚举值的name变量只能设置成“女”，而MALE枚举值只能设置为男。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderBetterTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">GenderBetter</span> <span class="variable">g</span> <span class="operator">=</span> GenderBetter.valueOf(<span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">		g.setName(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">		System.out.println(g + <span class="string">&quot;代表&quot;</span> + g.getName());</span><br><span class="line"><span class="comment">//		此时设置name值是将会提醒参数错误</span></span><br><span class="line">		g.setName(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">		System.out.println(g + <span class="string">&quot;代表&quot;</span> + g.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面的代码还不够好，枚举类通常应该设置成不可变类，也就是说，他的成员变量值不应该允许改变这样会更加安全，而且代码更加简洁。因此建议枚举类的成员变量使用public final修饰。</p>
<p>如果将所有的成员变量都使用fianl修饰符来修饰，所以必须在构造器里为这些成员变量指定初始值（或者在定义成员变量是指定默认值，或者在初始化块中指定初始值，但这两种情况不常见），因此应该为枚举类显式定义带参数的构造器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GenderBest</span> &#123;</span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>), FEMALE(<span class="string">&quot;女&quot;</span>);  <span class="comment">//粗体字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">GenderBest</span><span class="params">(String name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序，为GenderBest枚举类构造一个GenderBest（String name）构造器之后，列出枚举值就应该采用粗体字来完成。也就是说。在枚举类中列出枚举值是，实际上就是调用构造器创建枚举类对象，只是这里无须使用new关键字，也无须显示调用构造器。前面列出枚举值时无须传入参数，升值无须使用括号，仅仅是因为前面的枚举值包含无参数的构造器。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出枚举值相当于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GenderBest</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenderBest</span>(<span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">GenderBest</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenderBest</span>(<span class="string">&quot;女&quot;</span>);</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-9-4-实现接口的枚举类"   >
          <a href="#6-9-4-实现接口的枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-4-实现接口的枚举类" class="headerlink" title="6.9.4 实现接口的枚举类"></a>6.9.4 实现接口的枚举类</h3>
      <p>枚举类也能实现一个或多个接口。与普通方法实现一个或多个接口完全一样，枚举类实现一个或多个接口是，也需要实现该接口所包含的方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenderDesc</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在上面GenderDesc接口中定义了一个Info()方法，下面的Gerder枚举类实现了接口，并实现了该接口里包含的info()方法。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender1</span> <span class="keyword">implements</span> <span class="title class_">GenderDesc</span></span><br><span class="line">&#123;</span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>), FEMALE(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Gender1</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;这是一个用于定义性别的枚举类&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>如果由枚举类来实现接口里的方法，则每个枚举类在调用该方法时都有相同的行为方式（因为方法体完全一样）。如果需要每个枚举值在调用该方法时呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法，每个枚举值提供不同的实现方法，从而让不同的枚举值调用该方法时具有不用的行为方式。在下面的Gender枚举类中，不同的枚举值对info()方法的实现各不相同。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender1</span> <span class="keyword">implements</span> <span class="title class_">GenderDesc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	此处的枚举值必须调用对应的构造器来完成</span></span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>)  </span><br><span class="line"><span class="comment">//	花括号部分实际上是一个类体部分</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;这个枚举类代表男性&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	FEMALE(<span class="string">&quot;女&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;这个枚举值代表女性&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;<span class="comment">//自己加的，感觉加上这一句话更符合下面的解释</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Gender1</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//下面为自己加的测试</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(Gender1.FEMALE+<span class="string">&quot;代表着&quot;</span>+Gender1.FEMALE.name);</span><br><span class="line">		System.out.println(Gender1.MALE+<span class="string">&quot;代表着&quot;</span>+Gender1.MALE.name);</span><br><span class="line">		<span class="comment">//System.out.println(Gender1.FEMALE.info());此行代码错误，学会后修改</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>上面的代码的粗体字部分看起啦有些奇怪，当创建MALE和FEMALE两个枚举值时，后面又紧跟了一对花括号，这对花括号里包括了一个info()方法来定义。如果还记得匿名内部类的语法的话，则可能对这样的语法有点印象了，花括号部分实际上就是一个类体部分，这种情况下，当创建MALE、FEMALE枚举值时，并不是直接创建Gender枚举类的实例，而是相当于创建Gender的匿名子类的实例。因为粗体字括号部分实际上是匿名内部类的类体部分，所以这个部分的代码部分与前面介绍的匿名内部类语法大致相同，只是它依然是枚举类的匿名内部类的子类。</p>
<p>对于一个抽象的枚举类而言——只要它包含了抽象方法，他就是抽象枚举类，系统会默认用abstract修饰，而不是使用final修饰。</p>
<p> 编译Gender1类即可发现出现三个class文件，即可证明MALE和FEMALE实际上是Gender1匿名子类的实例。</p>

        <h3 id="6-9-5-包含抽象方法的枚举类"   >
          <a href="#6-9-5-包含抽象方法的枚举类" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-9-5-包含抽象方法的枚举类" class="headerlink" title="6.9.5 包含抽象方法的枚举类"></a>6.9.5 包含抽象方法的枚举类</h3>
      <p>定义一个抽象类的枚举类Opration ，让4个枚举值分别为eval()方法实现不同的加减乘除。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Opration</span> </span><br><span class="line">&#123;</span><br><span class="line">	PIUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	MINUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x-y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	TIMES</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x*y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	DIVIDE</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span> x/y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(Opration.PIUS.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(Opration.MINUS.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(Opration.TIMES.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">		System.out.println(Opration.DIVIDE.eval(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>编译此程序会出现5个class方法，Opration 对应一个，其他四个为四个匿名内部子类。</p>
<p>枚举类里定义抽象方法时不能使用abstract关键字来讲枚举类定义成抽象类（因为体统会自动为他添加abstract关键字），但因为枚举类需要显示创建枚举类，而不是父类，所以定义每个枚举值时必须为抽象方法提供实现，否则会编译错误。</p>

        <h2 id="6-10-对象与垃圾回收"   >
          <a href="#6-10-对象与垃圾回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-对象与垃圾回收" class="headerlink" title="6.10 对象与垃圾回收"></a>6.10 对象与垃圾回收</h2>
      <p>Java的垃圾回收是Java语言的重要功能之一。当程序创建对象、数组等引用类型实体时，系统东辉在堆内存中为之分配一块内存，对象就保存在这块内存区中，当这块内存不再被任何引用类型引用时，这块内存就成了垃圾，等待垃圾回收机制进行回收。垃圾回收机制有如下机制：</p>
<ul>
<li>垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源（例如数据库练级，网络IO等资源）。</li>
<li>程序无法精确的控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性地失去引用后，系统就会在合适的时候回收他所占的内存。</li>
<li>在垃圾回收任何对象之前，总会先调用它的finalize()方法，该方法可能使该对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收。</li>
</ul>

        <h3 id="6-10-1-对象在内存中的状态"   >
          <a href="#6-10-1-对象在内存中的状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-1-对象在内存中的状态" class="headerlink" title="6.10.1 对象在内存中的状态"></a>6.10.1 对象在内存中的状态</h3>
      <p>当一个对象在堆内存中运行时，根据他被引用变量所引用的状态，可以把它所处的状态分成三种：</p>
<ul>
<li><p>可达状态：当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态，程序可通过引用变量来调用该对象的实例变量和方法。</p>
</li>
<li><p>可恢复状态：如果程序中某个对象不再有任何引用变量引用它，他就进入了可恢复状态。在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，系统会调用所有可恢复状态的finalize()方法进行资源清理。如果系统在调用finalize()方法时重新让一个引用变量引用该对象，则这个对象会再次变为可达状态；否则该对象将进入不可达状态。</p>
</li>
<li><p>不可达状态：当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize()方法后依然没有事该对象变成可达状态，那么这个对象将永久性地失去引用，最后变成不可达状态，系统才会真正回收该对象所占的资源。</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatusTranfer</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);<span class="comment">//此段代码执行结束后“轻量级Java EE企业应用实战”字符串对象处于可达状态</span></span><br><span class="line">		a = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>);<span class="comment">//“轻量级Java EE企业应用实战”此时处于可恢复状态，而&quot;疯狂Java讲义&quot;处于可达状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>  一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或被其他对象的实例变量引用。当某个对象呗其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；当某个对象被其他对象的还是实例变量引用时，只有当该对象被销毁后，该对象才会进入可恢复状态。</p>

        <h3 id="6-10-2-强制垃圾回收"   >
          <a href="#6-10-2-强制垃圾回收" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-2-强制垃圾回收" class="headerlink" title="6.10.2 强制垃圾回收"></a>6.10.2 强制垃圾回收</h3>
      <p>  当一个对象失去引用后，系统何时调用它的finalize()方法对他进行资源清理，何时他会变成不可达状态，系统核实回收他所占有的内存，对于程序完全透明。程序只能控制一个对象何时不再被任何引用变量引用，决不能控制它何时被回收。</p>
<p>但任然可以强制系统进行垃圾回收——这种强制只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不确定。大部分时候，程序强制系统垃圾回收后总会有一些效果。强制系统垃圾回收方式有两种：</p>
<ol>
<li>调用System类的gc()静态方法：System.gc()。</li>
<li>调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc()。</li>
</ol>
<p>下面创建了4个匿名对象，每个对象创建之后立即进入可恢复状态，等待系统回收，但直到系统退出，系统依然不会回收该资源。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">GcTest</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;系统正在清理GcTest对象的资源...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>系统不曾调用GcTest对象的finalize()方法，修改如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">GcTest</span>();</span><br><span class="line"><span class="comment">//			下面两行代码起的作用完全相同，强制系统进行垃圾回收</span></span><br><span class="line"><span class="comment">//			System.gc();</span></span><br><span class="line">			Runtime.getRuntime().gc();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;系统正在清理GcTest对象的资源...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>![](C:\Program Files\Typora\image\04edad008bb713dd080adae680fdca9.png)</p>
<p>运行java命令时指定-varbose:gc选项可以看待回收后的提示信息。</p>
<p>上面显示了程序强制垃圾回收的效果，但这种强制只是建议系统立即进行垃圾回收，系统完全有可能并不立即垃圾回收，垃圾回收机制也不会对程序的建议完全置之不理：垃圾回收机制会在收到通知后，尽快进行垃圾回收。</p>

        <h3 id="6-10-3-finalize方法"   >
          <a href="#6-10-3-finalize方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-3-finalize方法" class="headerlink" title="6.10.3 finalize方法"></a>6.10.3 finalize方法</h3>
      <p>在垃圾回收机制回收某个对象所占用的内存之前，通常要求程序调用适当的方法来清理资源，在没有明确指定清理资源的情况下，Java提供了默认机制来清理该对象的资源，这个机制就是finalize()方法。该方法是定义在Object类里的实例方法，方法原型为：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> thows Throwable</span><br></pre></td></tr></table></div></figure>

<p>当finalize()方法返回后，对象小时，垃圾回收机制开始执行。方法原型中的thows Throwable表示他可以抛出任何类型的异常。</p>
<p>记住以下几个特点：</p>
<ol>
<li>永远不要主动调用某个对象的finalize()方法，该方法应该交给垃圾回收机制调用。</li>
<li>finalize()方法何时被调用，是否被发调用具有不确定性，不要把finalize()方法当成一定会执行的方法。</li>
<li>当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。</li>
<li>当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。</li>
</ol>
<p>下面程序演示了如何在finalize()方法中复活自身，并可通过该程序看出垃圾回收的不确定性</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeTest</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//定义了ft类变量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;测试资源清理的finalize方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建FinalizeTest对象立即进入可恢复状态</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">FinalizeTest</span>();  <span class="comment">//创建了一个 FinalizeTest类的匿名对象</span></span><br><span class="line"><span class="comment">//		通知系统进行资源回收</span></span><br><span class="line">		System.gc();   <span class="comment">//①</span></span><br><span class="line"><span class="comment">//		强制垃圾回收机制调用可恢复对象的finalize()方法</span></span><br><span class="line"><span class="comment">//		Runtime.getRuntime().runFinalization();   //②</span></span><br><span class="line">		System.runFinalization();   <span class="comment">//③</span></span><br><span class="line">		ft.info();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		让ft引用到试图回收的可恢复对象，即可恢复对象重新变成可达</span></span><br><span class="line">		ft = <span class="built_in">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面程序中定义了一个FinalizeTest类，<strong>重写了该类的finalize()方法</strong>，在该方法中把需要清理的可慧夫妇向重新赋值给ft引用变量，从而让该可恢复对象重新变成可达状态。</p>
<p>创建了一个 FinalizeTest类的匿名对象，但是没有给该对象赋值，所以立即进入可恢复状态。随后系统调用①通知系统进行垃圾回收，②强制系统立即调用可恢复对象的finalize()方法，再次调用ft对象的info()方法。info()任然可以正常运行。</p>
<p>删除①，取消强制垃圾回收后<img src="C:\Users\MingyangLiu\Desktop\张智超\image\Snipaste_2021-03-15_18-02-27.png"></p>
<p>因为删除①后，程序并没有通知系统回收垃圾（因为内存并不紧张），也就意味着没有调用finalize()，也就是说ft类变量将依然保持为null，这样就导致了空指针异常。</p>
<p>②和③都用于强制回收垃圾机制调用可恢复对象的finalize()方法，如果程序仅执行System.gc();代码，而不执行②或③代码——由于JVM垃圾回收机制的不确定性，JVM往往不立即调用可恢复对象的finalize()方法，这样FinaizeTest的ft类变量可能依然为null，可能依然会导致空指针异常。</p>

        <h3 id="6-10-4-对象的软、弱和虚引用"   >
          <a href="#6-10-4-对象的软、弱和虚引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-10-4-对象的软、弱和虚引用" class="headerlink" title="6.10.4 对象的软、弱和虚引用"></a>6.10.4 对象的软、弱和虚引用</h3>
      <p>对于大部分对象而言，程序里会有一个引用变量引用该对象，这是最常见的引用方式。除此之外，java.lang.ref包下提供三个类：软引用(SoftReference)、虚引用(PhantomReference)、弱引用(WeakReference)，他们代表了系统对象的三种引用方式。因此Java对对象的引用有如下4种方式：</p>
<p>1、强引用(StrongReference)</p>
<p>​	Java程序中最常见的引用方式。</p>
<p>2、软引用(SoftReference)</p>
<p>​	通过SoftReference类实现，当一个对象只有软引用时，它有可能被垃圾回收机制回收（看内存是否紧张），通常用于对内存敏感的程序中。</p>
<p>3、弱引用(WeakReference)</p>
<p>​	通过WeakReference类实现，弱引用和软引用很像，但弱引用的引用级别更低，对于引用的对象而言，<strong>当系统运行垃圾回收机制时</strong>，不管系统内存是否足够，总会回收该对象所占用的内存。</p>
<p>4、虚引用(PhantomReference)</p>
<p>​	虚引用通过PhantomReference类实现，虚引用完全类型与没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列（ReferenceQueue）联合使用。</p>
<p>引用队列由java.ref.ReferenceQueue类表示，它用于保存被回收后对象的引用。当联合使用软引用、弱引用和饮用队列时，系统在回收被引用的对象之后，将把被回收对象对应的引用添加到关联的引用队列中。虚引用在对象被释放之前，将把它对应的虚引用添加到关联的引用队列中，这使得可以在对象被回收前采取行动。</p>
<p>虚引用的主要作用就是用于跟踪对象被垃圾回收的状态，程序可以通过检查与虚引用关联的引用队列中是否已经包含了该虚引用，从而了解虚引用所引用的对象是否即将被回收。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个字符串对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		创建一个弱引用，让此弱引用引用到“疯狂Java讲义”字符串</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(str);  <span class="comment">//①此处需要导包</span></span><br><span class="line"><span class="comment">//		切断str引用和“疯狂java讲义”字符串之间的引用联系</span></span><br><span class="line">		str = <span class="literal">null</span>;    <span class="comment">//②</span></span><br><span class="line"><span class="comment">//		取出弱引用所引用的对象</span></span><br><span class="line"><span class="comment">/*		.get()：返回这个引用对象的引用对象。</span></span><br><span class="line"><span class="comment">		如果这个引用对象已经被程序或垃圾收集器清除，那么这个方法将返回null。</span></span><br><span class="line"><span class="comment">		返回:该引用所引用的对象，如果该引用对象已被清除，则返回null</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		System.out.println(wr.get());   <span class="comment">//③</span></span><br><span class="line"><span class="comment">//		强制垃圾回收</span></span><br><span class="line">		System.gc();</span><br><span class="line">		System.runFinalization();</span><br><span class="line"><span class="comment">//		再次取出弱引用所引用的对象</span></span><br><span class="line">		System.out.println(wr.get());   <span class="comment">//④</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面：创建了一个疯狂Java讲义字符串对象，并让str引用变量引用。执行①，创建了一个弱引用对象，并让该对象与str引用同一对象。执行③，因为程序并不紧张，所以系统还不会回收wr所引用的对象，之后调用了System.gc()和System.runFinalize();通知系统进行垃圾回收，所以④输出null。</p>
<p>上面为弱引用，下面使用了虚引用来引用字符串对象，虚引用无法获取他引用的对象。下面还将虚引用与引用队列结合使用，可以看到虚引用所引用的对象被垃圾回收后，虚引用将被添加到引用队列中。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	<span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//		创建一个字符串对象</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line"><span class="comment">//		创建一个引用队列</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">rq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">//		创建一个虚引用，</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(str,rq);</span><br><span class="line"><span class="comment">//		切断str引用</span></span><br><span class="line">		str = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//		取出虚引用所引用的对象，并不能通过虚引用获取被引用的对象，所以输出null</span></span><br><span class="line">		System.out.println(pr.get());  <span class="comment">//①</span></span><br><span class="line"><span class="comment">//		强制垃圾回收</span></span><br><span class="line">		System.gc();</span><br><span class="line">		System.runFinalization();</span><br><span class="line"><span class="comment">//		垃圾回收后，虚引用将被放入引用队列中</span></span><br><span class="line"><span class="comment">//		取出引用队列中最先进入队列的引用与pr进行比较</span></span><br><span class="line">		System.out.println(rq.poll() == pr); <span class="comment">//②</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因为系统无法通过虚引用来获得被引用的对象，所以执行①号粗体字代码时，程序将输出null(即使此时并未通过强制进行垃圾回收)。当程序强制垃圾回收后，只有虚引用引用的字符串对象将会被垃圾回收，当被引用的对象被回收后，对应的虚引用将被添加到关联的引用队列中，因而将在②看到输出turn。</p>
<p>必须要指出的是，要使用这些特殊的引用类，就不能保留对对象的强引用；如果保留了对对象的强引用，就会浪费这些引用类所提供的任何好处。</p>
<p>由于垃圾回收的不确定性，当程序希望从软、弱引用中取出被引用对象时，可能这个被引用对象已经被释放了，如果程序需要使用那个被引用的对象，则必须重新创建该对象。这个过程可以采用两种方式完成，</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出弱引用所引用的对象</span></span><br><span class="line">obj = wr.get();</span><br><span class="line"><span class="comment">//如果取出的对象为null</span></span><br><span class="line"><span class="keyword">if</span>(obj == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重新创建一个新的对象，再次让弱引用去引用该对象</span></span><br><span class="line">    wr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(recreateIt());   <span class="comment">//①</span></span><br><span class="line">    <span class="comment">//取出弱引用所引用的对象，将其赋给obj变量</span></span><br><span class="line">    obj = wr.get();   <span class="comment">//②</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作obj对象</span></span><br><span class="line"><span class="comment">//再次切断obj与对象之间的联系</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取出弱引用所引用的对象</span></span><br><span class="line">obj = wr.get();</span><br><span class="line"><span class="comment">//如果取出的对象为null</span></span><br><span class="line"><span class="keyword">if</span>(obj == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重新创建一个新的对象，并使用强引用来引用它</span></span><br><span class="line">	obj = recreateIt();	</span><br><span class="line">    <span class="comment">//取出弱引用所引用的对象，将其赋给obj变量</span></span><br><span class="line">    wr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作obj对象</span></span><br><span class="line"><span class="comment">//再次切断obj与对象之间的联系</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></div></figure>

<p>上面两段代码采用的都是为嘛，其中recreateIt()方法用于生成一个obj对象。这两段代码都是判断obj对象是否已经被回收，如果已经被回收，则重新创建该对象。如果弱引用引用的对象已经被垃圾回收释放了，则重新创建该对象。但第一段代码中存在一定的问题，当if块执行完成后，obj还是有可能为null。因为垃圾回收的不确定性，假设系统在①和②代码之间进行了垃圾回收，则系统会再次将wr所引用的对象回收，从而导师obj依然是null。第二段代码则不会存在这个问题，当if结束后，obj一定不为null。</p>

        <h2 id="6-11-修饰符的使用范围"   >
          <a href="#6-11-修饰符的使用范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-11-修饰符的使用范围" class="headerlink" title="6.11 修饰符的使用范围"></a>6.11 修饰符的使用范围</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">外部类&#x2F;接口</th>
<th align="center">成员属性</th>
<th align="center">方法</th>
<th align="center">构造器</th>
<th align="center">初始化块</th>
<th align="center">成员内部类</th>
<th align="center">局部成员</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected(受保护的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">包访问控制符</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">private(私人的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">abstract(抽象的)</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">static</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">strictfp</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">synchronized(同步的)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">native</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">transient(短暂的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">volatile(不稳定的)</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table></div>
<p>包访问控制符是一个特殊的修饰符，不用任何访问控制符的就是包访问控制符。对于初始化块和局部成员而言，他们不能使用任何访问控制符，所以看起来像包访问控制符。</p>
<p>strictfp关键字的含义是FP-strict，也就是精确浮点的意思。</p>
<p>native 关键字主要用于修饰一个方法，使用native修饰的方法类似于一个抽象方法。与抽象方法不同的是，native方法通常采用C语言来实现。如果某个方法需要利用平台的相关特性，或者访问系统引荐等，则可以使用native修饰该方法，再把该方法交给C去实现。</p>
<p>Java中的四个访问控制符权限从高到低分别为private、protected、包访问权限和private。四个访问控制符是互斥的，最多只能出现一个，不仅如初，abstract和final永远不能同时使用；abstract和static不能同时修饰方法，可以同时修饰内部类；abstract和private不能同时修饰方法，可以同时修饰内部类。由于private修饰的方法不可能被子类重写，因此使用final修饰没什么意义。</p>

        <h2 id="6-12-多版本JAR包"   >
          <a href="#6-12-多版本JAR包" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-12-多版本JAR包" class="headerlink" title="6.12 多版本JAR包"></a>6.12 多版本JAR包</h2>
      <p>JAR文件的全称是Java Archive File，<small>（是一种与平台无关的文件格式，可将许多文件聚合为一个文件。可以将多个Java小程序及其必需的组件（.class文件，图像和声音）捆绑到JAR文件中，然后通过一次HTTP事务将其下载到浏览器中，从而大大提高了下载速度。JAR格式还支持压缩，从而减小了文件大小，从而进一步缩短了下载时间。此外，小程序作者可以对JAR文件中的各个条目进行数字签名，以验证其来源。它是完全可扩展的。）</small>&gt;意思就是Java档案文件。通常JAR文件是一种压缩文件，与常见的ZIP压缩文件兼容，通常也被称为JRA包，在JAR文件中默认包含了一个名为META-INF&#x2F;MANIFEST.MF的清单文件，这个清单文件是在生成JAR文件时由系统自动创建的。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://example.com">Xiao Zhang</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://example.com/2023/02/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/">http://example.com/2023/02/14/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/02/14/%E7%AC%AC%E4%B8%83%E7%AB%A0%20Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">《疯狂Java讲义——Java基础类库》</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/02/14/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E6%B3%9B%E5%9E%8B/"><span class="paginator-prev__text">《疯狂Java讲义——泛型》</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">
          第六章 面向对象（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">
          6.1包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">
          包装类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">
          缓存机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">
          6.2处理对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E5%92%8CtoString%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          6.2.1打印对象和toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-x3D-x3D-%E5%92%8Cequals%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          6.2.2  &#x3D;&#x3D;和equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">
          测试两个变量是否相等的两种方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#equals-%E9%87%8D%E5%86%99%E5%BA%94%E8%AF%A5%E6%BB%A1%E8%B6%B3%E4%B8%80%E4%B8%8B%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.3.0.0.1.</span> <span class="toc-text">
          equals()重写应该满足一下条件</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.3.</span> <span class="toc-text">
          6.3类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E6%88%90%E5%91%98%EF%BC%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%EF%BC%89-%E5%B1%9E%E4%BA%8E%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">
          static成员（成员变量，方法，内部类，初始化块）-属于类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E8%80%83%E7%82%B9%EF%BC%88%E7%AC%94%E8%AF%95%E5%BE%88%E5%B8%B8%E8%A7%81%EF%BC%89"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">
          static考点（笔试很常见）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">
          单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">
          如何创建单例模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2%E5%8D%95%E4%BE%8B%EF%BC%88Singleton%EF%BC%89%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          6.3.2单例（Singleton）类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-final%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">
          6.4   final修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-final%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          6.4.1 final成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          final局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-final%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          6.4.3 final修饰基本类型变量和引用类型变量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-44-%E5%8F%AF%E6%89%A7%E8%A1%8C%E2%80%9C%E5%AE%8F%E6%9B%BF%E6%8D%A2%E2%80%9D%E7%9A%84final%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">
          6.44 可执行“宏替换”的final变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5-final%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.5.</span> <span class="toc-text">
          6.4.5 final方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-6-final%E7%B1%BB"><span class="toc-number">1.4.6.</span> <span class="toc-text">
          6.4.6 final类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-7-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB"><span class="toc-number">1.4.7.</span> <span class="toc-text">
          6.4.7 不可变类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-8-%E7%BC%93%E5%AD%98%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB"><span class="toc-number">1.4.8.</span> <span class="toc-text">
          6.4.8 缓存实例的不可变类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%9D%A5%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E6%B1%A0%EF%BC%8C%E7%9C%8B%E4%B8%8D%E6%87%82"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">
          使用一个数组来作为缓存池，看不懂</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">
          6.5抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-1%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">
          6.5.1抽象方法和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-2%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">
          6.5.2抽象类的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Java-9%E6%94%B9%E8%BF%9B%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">
          6.6  Java 9改进的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">
          6.6.1 接口的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2Java-9%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">
          6.6.2	Java 9中接口的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.3.</span> <span class="toc-text">
          6.6.3接口的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x3D-x3D-%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%BA%AF%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BE%88%E5%A4%9A%E9%94%99%E8%AF%AF-x3D-x3D"><span class="toc-number">1.6.3.0.1.</span> <span class="toc-text">
          &#x3D;&#x3D;以下代码中纯在自己的很多错误&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-4%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.4.</span> <span class="toc-text">
          6.6.4使用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-5%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.6.5.</span> <span class="toc-text">
          6.6.5接口和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-6%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-number">1.6.6.</span> <span class="toc-text">
          6.6.6面向接口编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">
          1.简单工程模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">
          2.命令模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">
          6.7 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">
          6.7.1非静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-2%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.2.</span> <span class="toc-text">
          6.7.2静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-3%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.3.</span> <span class="toc-text">
          6.7.3使用内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-4-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.4.</span> <span class="toc-text">
          6.7.4 局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.5.</span> <span class="toc-text">
          6.7.5 匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-Java-11%E5%A2%9E%E5%BC%BA%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">
          6.8 Java 11增强的Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8"><span class="toc-number">1.8.1.</span> <span class="toc-text">
          6.8.1 Lambda表达式入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.2.</span> <span class="toc-text">
          6.8.2 Lambda表达式与函数式接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.9.</span> <span class="toc-text">
          6.9 枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-1-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.9.1.</span> <span class="toc-text">
          6.9.1 手动实现枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%85%A5%E9%97%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">
          6.9.2 枚举类入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.9.3.</span> <span class="toc-text">
          6.9.3 枚举类的成员变量、方法和构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-4-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.9.4.</span> <span class="toc-text">
          6.9.4 实现接口的枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-5-%E5%8C%85%E5%90%AB%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.9.5.</span> <span class="toc-text">
          6.9.5 包含抽象方法的枚举类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.10.</span> <span class="toc-text">
          6.10 对象与垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.10.1.</span> <span class="toc-text">
          6.10.1 对象在内存中的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2-%E5%BC%BA%E5%88%B6%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.10.2.</span> <span class="toc-text">
          6.10.2 强制垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-3-finalize%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.3.</span> <span class="toc-text">
          6.10.3 finalize方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AF%E3%80%81%E5%BC%B1%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">1.10.4.</span> <span class="toc-text">
          6.10.4 对象的软、弱和虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.11.</span> <span class="toc-text">
          6.11 修饰符的使用范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-%E5%A4%9A%E7%89%88%E6%9C%ACJAR%E5%8C%85"><span class="toc-number">1.12.</span> <span class="toc-text">
          6.12 多版本JAR包</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/头像.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Make great efforts</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://blog.csdn.net/weixin_45708609?spm=1000.2115.3001.5343/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="2215071022@qq.com" target="_blank" rel="noopener" data-popover="social.Gmail" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="2215071022" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="http://2215071022@qq.com" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email Subscribe</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>zhang</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v6.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>